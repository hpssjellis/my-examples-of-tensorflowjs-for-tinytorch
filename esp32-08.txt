#include "esp_camera.h"
#include <U8g2lib.h>
#include <Wire.h>
#include <math.h>

// 1. IMPORT YOUR MODEL DATA
// This file is generated by your browser tool (torchjs26.html)
#include "myModel.h" 

// Initialize the OLED display
U8G2_SSD1306_72X40_ER_1_HW_I2C u8g2(U8G2_R2, U8X8_PIN_NONE);

// --- CAMERA PINS (XIAO ESP32S3) ---
#define XCLK_GPIO_NUM  10
#define SIOD_GPIO_NUM  40
#define SIOC_GPIO_NUM  39
#define Y9_GPIO_NUM    48
#define Y8_GPIO_NUM    11
#define Y7_GPIO_NUM    12
#define Y6_GPIO_NUM    14
#define Y5_GPIO_NUM    16
#define Y4_GPIO_NUM    18
#define Y3_GPIO_NUM    17
#define Y2_GPIO_NUM    15
#define VSYNC_GPIO_NUM 38
#define HREF_GPIO_NUM  47
#define PCLK_GPIO_NUM  13

// Global buffers for inference
float myInputBuffer[64 * 64 * 3]; // 64x64 RGB pixels
float myConvOutput[62 * 62 * 4]; // Result of 3x3 convolution with 4 filters

// --- THE INFERENCE ENGINE (The "Raw" Math) ---

// 1. Convolution 2D
void myRunConv2D() {
    // This loop mimics exactly what TensorFlow.js does in the browser
    for (int f = 0; f < 4; f++) { // 4 Filters
        for (int y = 0; y < 62; y++) {
            for (int x = 0; x < 62; x++) {
                float sum = 0;
                for (int ky = 0; ky < 3; ky++) {
                    for (int kx = 0; kx < 3; kx++) {
                        int pixelIdx = ((y + ky) * 64 + (x + kx)) * 3;
                        int weightIdx = (f * 3 * 3 * 3) + (ky * 3 + kx) * 3;
                        // Add R, G, B contribution
                        sum += myInputBuffer[pixelIdx] * myConv1_w[weightIdx];
                        sum += myInputBuffer[pixelIdx+1] * myConv1_w[weightIdx+1];
                        sum += myInputBuffer[pixelIdx+2] * myConv1_w[weightIdx+2];
                    }
                }
                // Apply Bias and ReLU (Activation)
                sum += myConv1_b[f];
                myConvOutput[(f * 62 * 62) + (y * 62 + x)] = (sum > 0) ? sum : 0;
            }
        }
    }
}

// 2. Final Analysis (Dense Layer)
int myGetClassification() {
    float myLogits[3] = {0, 0, 0}; // 3 output classes
    
    for (int i = 0; i < 3; i++) {
        float sum = 0;
        for (int j = 0; j < (62 * 62 * 4); j++) {
            sum += myConvOutput[j] * myDense1_w[i * (62 * 62 * 4) + j];
        }
        myLogits[i] = sum + myDense1_b[i];
    }
    
    // Find the winner (ArgMax)
    int myWinner = 0;
    for (int i = 1; i < 3; i++) {
        if (myLogits[i] > myLogits[myWinner]) myWinner = i;
    }
    return myWinner;
}

// --- IMAGE PROCESSING ---

void myProcessCameraImage(camera_fb_t *fb) {
    uint8_t *rgbBuf = (uint8_t *)ps_malloc(fb->width * fb->height * 3);
    fmt2rgb888(fb->buf, fb->len, fb->format, rgbBuf);

    // Resize/Normalize 320x240 -> 64x64 and 0.0-1.0 range
    for (int y = 0; y < 64; y++) {
        for (int x = 0; x < 64; x++) {
            int srcX = x * (fb->width / 64);
            int srcY = y * (fb->height / 64);
            int srcIdx = (srcY * fb->width + srcX) * 3;
            int dstIdx = (y * 64 + x) * 3;
            
            myInputBuffer[dstIdx] = rgbBuf[srcIdx] / 255.0;
            myInputBuffer[dstIdx+1] = rgbBuf[srcIdx+1] / 255.0;
            myInputBuffer[dstIdx+2] = rgbBuf[srcIdx+2] / 255.0;
        }
    }
    free(rgbBuf);
}

void setup() {
    Serial.begin(115200);
    u8g2.begin();
    
    // Camera Config
    camera_config_t config;
    config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = Y2_GPIO_NUM;
    config.pin_d1 = Y3_GPIO_NUM;
    config.pin_d2 = Y4_GPIO_NUM;
    config.pin_d3 = Y5_GPIO_NUM;
    config.pin_d4 = Y6_GPIO_NUM;
    config.pin_d5 = Y7_GPIO_NUM;
    config.pin_d6 = Y8_GPIO_NUM;
    config.pin_d7 = Y9_GPIO_NUM;
    config.pin_xclk = XCLK_GPIO_NUM;
    config.pin_pclk = PCLK_GPIO_NUM;
    config.pin_vsync = VSYNC_GPIO_NUM;
    config.pin_href = HREF_GPIO_NUM;
    config.pin_sscb_sda = SIOD_GPIO_NUM;
    config.pin_sscb_scl = SIOC_GPIO_NUM;
    config.pin_pwdn = -1;
    config.pin_reset = -1;
    config.xclk_freq_hz = 20000000;
    config.frame_size = FRAMESIZE_QVGA;
    config.pixel_format = PIXFORMAT_JPEG;
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.fb_count = 2;

    esp_camera_init(&config);
}

void loop() {
    camera_fb_t *fb = esp_camera_fb_get();
    if (!fb) return;

    // 1. Convert and Resize
    myProcessCameraImage(fb);
    
    // 2. Run Brain
    myRunConv2D();
    int result = myGetClassification();

    // 3. Show Result on OLED
    u8g2.firstPage();
    do {
        u8g2.setFont(u8g2_font_ncenB10_tr);
        u8g2.setCursor(0, 20);
        u8g2.print("Class: ");
        u8g2.print(result);
    } while (u8g2.nextPage());

    esp_camera_fb_return(fb);
}
