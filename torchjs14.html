<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0"></script>

<body>

<h2 align="center">torchjs14.html - Stable X-Ray</h2>

<div style="font-size:15px; background-color:lightyellow; width:88%; border:5px solid blue; padding:5px; margin:5px;"> 
<b>Stable Update:</b> Changing code in the black box and clicking <b>Update</b> will restart the brain and X-Ray filters instantly without losing your camera stream.
</div><br>

<div id="myCodeSpace"> 
  <select id="myCameraSelect"></select>
  <input type="button" value="1. Start Camera & Brain" onclick="myStartAll()">
  <input type="button" value="2. Train B" onclick="myCollect(0)">
  <input type="button" value="3. Train H" onclick="myCollect(1)">
  <input type="button" value="4. Train P" onclick="myCollect(2)"><br>
  
  <input type="button" value="Save Disk" onclick="mySaveDisk()">
  <input type="text" id="myFileName" value="myModel14" size="10">
  <input type="button" value="Load Disk" onclick="document.getElementById('myFileLoader').click()">
  <input type="file" id="myFileLoader" style="display:none" multiple onchange="myLoadDisk(this.files)"><br>
  
  <b>Eye Intensity:</b> 
  <input type="range" id="myIntensity" min="0.1" max="5.0" step="0.1" value="1.0" oninput="document.getElementById('myIntensityVal').innerHTML = this.value">
  <span id="myIntensityVal">1.0</span>x<br><br>

  <div style="display: flex; gap: 10px; flex-wrap: wrap;">
    <div>
      <video id="myVideo1" width="320" height="240" autoplay playsinline style="border: 5px solid black; background: #ddd;"></video>
    </div>
    <div>
      <canvas id="myCanvasFilters" width="320" height="160" style="border: 5px solid green; background: black;"></canvas>
    </div>
  </div>

  <script>
    // Persistent variables outside the swappable function scope
    var myModel, myFeatureModel;
    var myTimer = null;
    var myTrainData = {0: [], 1: [], 2: []}, myValData = {0: [], 1: [], 2: []}; 
    var myClassNames = {0: "BACKGROUND", 1: "HAND", 2: "OBJECT"};
    var myLastClassID = -1, myValAccuracy = 0;

    async function myStartAll() {
      const myVideo = document.getElementById('myVideo1');
      const myDisplay = document.getElementById('myDiv1');
      const myHistory = document.getElementById('myDivHistory');
      const myCanvas = document.getElementById('myCanvasFilters');
      const myCtx = myCanvas.getContext('2d');
      const myDeviceId = document.getElementById('myCameraSelect').value;
      
      // Start camera if needed
      if (!myVideo.srcObject) {
        const myStream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: myDeviceId ? { exact: myDeviceId } : undefined }
        });
        myVideo.srcObject = myStream;
      }

      // Initialize Model if it doesn't exist
      if (!myModel) {
        myModel = tf.sequential();
        myModel.add(tf.layers.conv2d({name: 'myConv1', inputShape: [64, 64, 3], kernelSize: 5, filters: 8, strides: 4, activation: 'relu', padding: 'same'}));
        myModel.add(tf.layers.flatten());
        myModel.add(tf.layers.dense({units: 32, activation: 'relu'}));
        myModel.add(tf.layers.dense({units: 3, activation: 'softmax'})); 
        myModel.compile({optimizer: tf.train.adam(0.0005), loss: 'categoricalCrossentropy'});
        myFeatureModel = tf.model({inputs: myModel.inputs, outputs: myModel.getLayer('myConv1').output});
      }

      if (myTimer) clearInterval(myTimer);

      myTimer = setInterval(async () => {
        const myInput = tf.browser.fromPixels(myVideo).resizeBilinear([64, 64]).div(255.0).expandDims(0);

        // --- 1. TRAINING ---
        if (myTrainData[0].length > 0 && myTrainData[1].length > 0 && myTrainData[2].length > 0) {
            const myBatchInputs = tf.concat([
                myTrainData[0][Math.floor(Math.random() * myTrainData[0].length)],
                myTrainData[1][Math.floor(Math.random() * myTrainData[1].length)],
                myTrainData[2][Math.floor(Math.random() * myTrainData[2].length)]
            ]);
            await myModel.trainOnBatch(myBatchInputs, tf.tensor2d([[1,0,0], [0,1,0], [0,0,1]]));
            myBatchInputs.dispose();
        }

        // --- 2. VALIDATION EXAM ---
        if (myValData[0].length > 0 && myValData[1].length > 0 && myValData[2].length > 0) {
            const myExamInputs = tf.concat([
                myValData[0][Math.floor(Math.random() * myValData[0].length)],
                myValData[1][Math.floor(Math.random() * myValData[1].length)],
                myValData[2][Math.floor(Math.random() * myValData[2].length)]
            ]);
            const myExamOut = myModel.predict(myExamInputs);
            const myExamPreds = (await myExamOut.argMax(1).data());
            let myCorrect = 0;
            if (myExamPreds[0] === 0) myCorrect++;
            if (myExamPreds[1] === 1) myCorrect++;
            if (myExamPreds[2] === 2) myCorrect++;
            myValAccuracy = (myCorrect / 3.0) * 100;
            myExamOut.dispose(); myExamInputs.dispose();
        }

        // --- 3. X-RAY FILTERS ---
        const myFeatures = myFeatureModel.predict(myInput);
        const myMult = parseFloat(document.getElementById('myIntensity').value);
        myCtx.clearRect(0,0,320,160);
        for(let i=0; i<8; i++) {
            const myFData = tf.tidy(() => myFeatures.gather([i], 3).reshape([16, 16]).mul(myMult).clipByValue(0, 1));
            const myFCanvas = document.createElement('canvas');
            myFCanvas.width = 16; myFCanvas.height = 16;
            await tf.browser.toPixels(myFData, myFCanvas);
            myCtx.drawImage(myFCanvas, (i % 4) * 80, Math.floor(i / 4) * 80, 80, 80);
        }

        // --- 4. PREDICTION & LOGGING ---
        const myPredict = myModel.predict(myInput);
        const myClassID = (await myPredict.argMax(1).data())[0];
        const myConf = (await myPredict.data())[myClassID];

        myDisplay.innerHTML = `LIVE: <b>${myClassNames[myClassID]}</b> (${myConf.toFixed(2)})<br>`;
        myDisplay.innerHTML += `Exam Score: <b>${myValData[0].length > 0 ? myValAccuracy.toFixed(1) + '%' : 'Waiting for frames...'}</b>`;

        if (myClassID !== myLastClassID) {
            const myTime = new Date().toLocaleTimeString();
            myHistory.innerHTML = `[${myTime}] Guess: ${myClassNames[myClassID]} | Exam: ${myValAccuracy.toFixed(1)}%<br>` + myHistory.innerHTML;
        }
        myLastClassID = myClassID;
        myInput.dispose(); myPredict.dispose(); myFeatures.dispose();
      }, 100);
    }

    async function mySaveDisk() { await myModel.save('downloads://' + document.getElementById('myFileName').value); }

    async function myLoadDisk(myFileList) {
      if (myFileList.length < 2) return alert('Select both files.');
      let myFiles = Array.from(myFileList).sort((a,b) => a.name.endsWith('.json') ? -1 : 1);
      myModel = await tf.loadLayersModel(tf.io.browserFiles(myFiles));
      myModel.compile({optimizer: tf.train.adam(0.0005), loss: 'categoricalCrossentropy'});
      myFeatureModel = tf.model({inputs: myModel.inputs, outputs: myModel.getLayer('myConv1').output});
      alert('Brain & X-Ray Loaded!');
    }

    function myCollect(myID) {
      const myFrame = tf.browser.fromPixels(document.getElementById('myVideo1')).resizeBilinear([64, 64]).div(255.0).expandDims(0);
      if (Math.random() < 0.2) {
        myValData[myID].push(myFrame);
        if (myValData[myID].length > 10) myValData[myID].shift();
      } else {
        myTrainData[myID].push(myFrame);
        if (myTrainData[myID].length > 15) myTrainData[myID].shift();
      }
    }
  </script>
</div>

<div id="myDiv1" style="border: 2px solid green; padding: 10px; margin: 10px; font-family: monospace; background-color: #e0ffe0;">...</div>
<b>Detection History:</b>
<div id="myDivHistory" style="border: 2px solid blue; padding: 10px; margin: 10px; font-family: monospace; height: 100px; overflow-y: scroll; background-color: #f0f0f0;">Log...</div>

<input id="myUpdateBtn" type="button" value="Update and Run" style="visibility:hidden;" onclick="myApplyAndRun()"><br>
<textarea id="myTextarea1" wrap="off" rows="2" style="width:95%; background:black; color:white; font-family:monospace;" onclick="myToggleEditor()">
Click to see code...
</textarea>

<script>
let myOnce = true;

function myToggleEditor() {
    if (myOnce) {
       myTextGrow('myTextarea1', 'myCodeSpace');
       document.getElementById('myUpdateBtn').style.visibility = 'visible';
       myOnce = false;
    }
}

function myApplyAndRun() {
  let myLines = document.getElementById('myTextarea1').value.split('\n');
  myLines.shift(); myLines.shift(); myLines.pop(); myLines.pop();   
  document.getElementById('myCodeSpace').innerHTML = myLines.join('\n');
  myStartAll(); 
}

function myTextGrow(myT, myC) {
   const myArea = document.getElementById(myT);
   myArea.value = '\x3Cscript src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0">\x3C/script>\n\n' + document.getElementById(myC).innerHTML;
   myArea.value += '\n<div id=\'myDiv1\'>...</div><div id=\'myDivHistory\'>...</div>';
   setTimeout(() => { myArea.rows = myArea.value.split('\n').length + 3; }, 100);
}

(async function myListCameras() {
  const myDevices = await navigator.mediaDevices.enumerateDevices();
  const mySelect = document.getElementById('myCameraSelect');
  myDevices.filter(d => d.kind === 'videoinput').forEach((d, i) => {
    const myOpt = document.createElement('option');
    myOpt.value = d.deviceId;
    myOpt.text = d.label || `Camera ${i + 1}`;
    mySelect.appendChild(myOpt);
  });
})();
</script>

</body>