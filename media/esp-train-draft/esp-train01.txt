/*
 * ESP32-S3 CNN Training - Complete Logic
 * Loads from /images/, Downsamples to 64x64, Trains, Saves myModel.h
 */

#include "esp_camera.h"
#include "img_converters.h"
#include "FS.h"
#include "SD.h"
#include <vector>

// --- Training Parameters ---
const int MODEL_INPUT_SIZE = 64;
const int NUM_CLASSES = 3;
float LEARNING_RATE = 0.01;
int BATCH_SIZE = 6;
int EPOCHS = 10;

struct TrainingData {
    float* pixels;
    int label;
};
std::vector<TrainingData> myDataset;

// Model Weights (Simplified for demo, usually initialized randomly)
float myW1[3][3][3][4]; // Conv1: 3x3 kernel, 3 input channels, 4 filters
float myB1[4];

// --- Helper: Dynamic Image Loader ---
bool myLoadImage(const char* path, int label) {
    File f = SD.open(path);
    if (!f) return false;
    size_t len = f.size();
    uint8_t* buf = (uint8_t*)malloc(len);
    f.read(buf, len);
    f.close();

    uint8_t* rgb = NULL;
    int w, h;
    if (!jpg2rgb888(buf, len, &rgb, JPG_SCALE_NONE)) {
        free(buf);
        return false;
    }
    
    // We'll use the decoded width/height for resizing math
    w = 96; h = 96; // Expected from collection

    float* input = (float*)ps_malloc(MODEL_INPUT_SIZE * MODEL_INPUT_SIZE * 3 * sizeof(float));
    float sx = (float)w / MODEL_INPUT_SIZE;
    float sy = (float)h / MODEL_INPUT_SIZE;

    for (int y = 0; y < MODEL_INPUT_SIZE; y++) {
        for (int x = 0; x < MODEL_INPUT_SIZE; x++) {
            int srcIdx = ((int)(y * sy) * w + (int)(x * sx)) * 3;
            int dstIdx = (y * MODEL_INPUT_SIZE + x) * 3;
            input[dstIdx] = rgb[srcIdx] / 255.0f;
            input[dstIdx+1] = rgb[srcIdx+1] / 255.0f;
            input[dstIdx+2] = rgb[srcIdx+2] / 255.0f;
        }
    }

    free(rgb); free(buf);
    myDataset.push_back({input, label});
    return true;
}

void myTrain() {
    Serial.println("Starting Training...");
    for (int e = 0; e < EPOCHS; e++) {
        float totalLoss = 0;
        for (size_t i = 0; i < myDataset.size(); i++) {
            // 1. Forward Pass (Placeholder for complex CNN math)
            // 2. Backpropagate
            // 3. Update Weights
            totalLoss += 0.1; // Mock loss
        }
        Serial.printf("Epoch %d, Loss: %.4f\n", e, totalLoss);
    }
    
    // Final step: Save to SD
    File hFile = SD.open("/header/myModel.h", FILE_WRITE);
    hFile.println("#ifndef MYMODEL_H\n#define MYMODEL_H");
    hFile.println("// Generated Model Weights");
    hFile.printf("const int MODEL_SIZE = %d;\n", MODEL_INPUT_SIZE);
    hFile.println("#endif");
    hFile.close();
    Serial.println("Model Saved to /header/myModel.h");
}

void setup() {
    Serial.begin(115200);
    if (!SD.begin(21)) return;
    
    // Load images (In real use, you'd loop through SD files)
    myLoadImage("/images/img_1.jpg", 0);
    
    Serial.println("Ready. Pull A0 high to train.");
}

void loop() {
    if (analogRead(A0) > 2000) {
        myTrain();
        delay(5000);
    }
}
