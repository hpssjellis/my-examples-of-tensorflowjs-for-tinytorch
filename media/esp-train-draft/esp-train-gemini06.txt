/*
 * ESP32-S3 On-Device CNN Training
 * Fix: Added Null Pointer Protection to prevent LoadProhibited Panic
 */

#include "esp_camera.h"
#include "img_converters.h"
#include "FS.h"
#include "SD.h"
#include "SPI.h"
#include <vector>

// USER PARAMETERS
#define USE_GRAYSCALE_MODE false
float myLearningRate = 0.0005; 
int myBatchSize = 6;
int myTargetEpochs = 20;
int myMaxImagesPerClass = 100;
bool myUseAugmentation = true;
float myBrightnessRange = 0.2;
float myContrastRange = 0.4;
bool myInitializedWeights = false;

// CAMERA PINS (Standard ESP32-S3 Cam)
#define XCLK_GPIO_NUM 10
#define SIOD_GPIO_NUM 40
#define SIOC_GPIO_NUM 39
#define Y9_GPIO_NUM 48
#define Y8_GPIO_NUM 11
#define Y7_GPIO_NUM 12
#define Y6_GPIO_NUM 14
#define Y5_GPIO_NUM 16
#define Y4_GPIO_NUM 18
#define Y3_GPIO_NUM 17
#define Y2_GPIO_NUM 15
#define VSYNC_GPIO_NUM 38
#define HREF_GPIO_NUM 47
#define PCLK_GPIO_NUM 13

// MODEL ARCHITECTURE
const int myInputChannels = USE_GRAYSCALE_MODE ? 1 : 3;
const int myFlattenedSize = 6728;

// WEIGHTS - Initialized to NULL to allow for safety checks
float *myConv1_w = NULL, *myConv1_b = NULL, *myConv2_w = NULL, *myConv2_b = NULL, *myDense_w = NULL, *myDense_b = NULL;
float *myConv1_w_grad = NULL, *myConv1_b_grad = NULL, *myConv2_w_grad = NULL, *myConv2_b_grad = NULL, *myDense_w_grad = NULL, *myDense_b_grad = NULL;
float *myConv1_w_m = NULL, *myConv1_w_v = NULL, *myConv1_b_m = NULL, *myConv1_b_v = NULL;
float *myConv2_w_m = NULL, *myConv2_w_v = NULL, *myConv2_b_m = NULL, *myConv2_b_v = NULL;
float *myDense_w_m = NULL, *myDense_w_v = NULL, *myDense_b_m = NULL, *myDense_b_v = NULL;

// BUFFERS
float *myInputBuffer = NULL, *myConv1Output = NULL, *myPool1Output = NULL, *myConv2Output = NULL, *myDropoutMask = NULL, *myDenseOutput = NULL;
float *myDenseGrad = NULL, *myConv2Grad = NULL, *myPool1Grad = NULL, *myConv1Grad = NULL;

struct MyTrainingImage { float* data; int label; };
std::vector<MyTrainingImage> myTrainingData;
String myClassLabels[3];
int myClassCounts[3] = {0,0,0};

// UTILITY
inline float myClipValue(float v, float mn=-100, float mx=100) {
  if(isnan(v)||isinf(v)) return 0;
  return constrain(v,mn,mx);
}
inline float myLeakyRelu(float x) { return x>0 ? x : 0.1f*x; }
inline float myLeakyReluDeriv(float x) { return x>0 ? 1.0f : 0.1f; }
float myRandomFloat(float mn, float mx) { return mn + (float)random(10000)/10000.0f*(mx-mn); }

String myToCString(String s) {
  s = s.substring(0,20);
  s.replace("\\","\\\\"); s.replace("\"","\\\""); s.replace("\n","\\n");
  return s;
}

// MEMORY ALLOCATION WITH CRASH PROTECTION
bool myAllocateModelMemory() {
  Serial.println("\n=== Allocating Memory ===");
  int c1w_sz = 3*3*myInputChannels*4;
  int c2w_sz = 3*3*4*8;
  int dw_sz = myFlattenedSize*3;
  
  myConv1_w = (float*)ps_malloc(c1w_sz*sizeof(float));
  myConv1_b = (float*)ps_malloc(4*sizeof(float));
  myConv2_w = (float*)ps_malloc(c2w_sz*sizeof(float));
  myConv2_b = (float*)ps_malloc(8*sizeof(float));
  myDense_w = (float*)ps_malloc(dw_sz*sizeof(float));
  myDense_b = (float*)ps_malloc(3*sizeof(float));
  
  myConv1_w_grad = (float*)ps_malloc(c1w_sz*sizeof(float));
  myConv1_b_grad = (float*)ps_malloc(4*sizeof(float));
  myConv2_w_grad = (float*)ps_malloc(c2w_sz*sizeof(float));
  myConv2_b_grad = (float*)ps_malloc(8*sizeof(float));
  myDense_w_grad = (float*)ps_malloc(dw_sz*sizeof(float));
  myDense_b_grad = (float*)ps_malloc(3*sizeof(float));
  
  myConv1_w_m = (float*)ps_calloc(c1w_sz, sizeof(float));
  myConv1_w_v = (float*)ps_calloc(c1w_sz, sizeof(float));
  myConv1_b_m = (float*)ps_calloc(4, sizeof(float));
  myConv1_b_v = (float*)ps_calloc(4, sizeof(float));
  myConv2_w_m = (float*)ps_calloc(c2w_sz, sizeof(float));
  myConv2_w_v = (float*)ps_calloc(c2w_sz, sizeof(float));
  myConv2_b_m = (float*)ps_calloc(8, sizeof(float));
  myConv2_b_v = (float*)ps_calloc(8, sizeof(float));
  myDense_w_m = (float*)ps_calloc(dw_sz, sizeof(float));
  myDense_w_v = (float*)ps_calloc(dw_sz, sizeof(float));
  myDense_b_m = (float*)ps_calloc(3, sizeof(float));
  myDense_b_v = (float*)ps_calloc(3, sizeof(float));
  
  myInputBuffer = (float*)ps_malloc(64*64*myInputChannels*sizeof(float));
  myConv1Output = (float*)ps_malloc(62*62*4*sizeof(float));
  myPool1Output = (float*)ps_malloc(31*31*4*sizeof(float));
  myConv2Output = (float*)ps_malloc(29*29*8*sizeof(float));
  myDropoutMask = (float*)ps_malloc(myFlattenedSize*sizeof(float));
  myDenseOutput = (float*)ps_malloc(3*sizeof(float));
  
  myDenseGrad = (float*)ps_malloc(myFlattenedSize*sizeof(float));
  myConv2Grad = (float*)ps_malloc(29*29*8*sizeof(float));
  myPool1Grad = (float*)ps_malloc(31*31*4*sizeof(float));
  myConv1Grad = (float*)ps_malloc(62*62*4*sizeof(float));
  
  // CRITICAL SAFETY CHECK
  if(!myConv1_w || !myConv2_w || !myDense_w || !myInputBuffer) {
    Serial.println("[FATAL] PSRAM Allocation Failed! System Halted.");
    return false;
  }
  
  Serial.printf("Free PSRAM: %d bytes\n", ESP.getFreePsram());
  return true;
}

void myInitializeWeights() {
  if (myInitializedWeights) return;
  int c1w_sz = USE_GRAYSCALE_MODE ? 36 : 108;
  float c1std = sqrt(2.0/(9.0*myInputChannels));
  for(int i=0; i<c1w_sz; i++) myConv1_w[i] = myRandomFloat(-c1std, c1std);
  for(int i=0; i<4; i++) myConv1_b[i] = 0;
  float c2std = sqrt(2.0/36.0);
  for(int i=0; i<288; i++) myConv2_w[i] = myRandomFloat(-c2std, c2std);
  for(int i=0; i<8; i++) myConv2_b[i] = 0;
  float dstd = sqrt(2.0/myFlattenedSize);
  for(int i=0; i<myFlattenedSize*3; i++) myDense_w[i] = myRandomFloat(-dstd, dstd);
  for(int i=0; i<3; i++) myDense_b[i] = 0;
  myInitializedWeights = true;
}

bool myLoadImageFromFile(const char* path, float* buf) {
  if (!buf) return false;
  File f = SD.open(path);
  if(!f) return false;
  size_t sz = f.size();
  uint8_t* jpg = (uint8_t*)ps_malloc(sz);
  if(!jpg) { f.close(); return false; }
  f.read(jpg, sz);
  f.close();
  uint8_t* rgb = (uint8_t*)ps_malloc(320*240*3);
  if(!rgb) { free(jpg); return false; }
  bool ok = fmt2rgb888(jpg, sz, PIXFORMAT_JPEG, rgb);
  free(jpg);
  if(!ok) { free(rgb); return false; }
  for(int y=0; y<64; y++) {
    for(int x=0; x<64; x++) {
      int sy = (int)((y+0.5)*240.0/64.0);
      int sx = (int)((x+0.5)*320.0/64.0);
      if(sy>239) sy=239; if(sx>319) sx=319;
      int idx = (sy*320+sx)*3;
      if(USE_GRAYSCALE_MODE) {
        buf[y*64+x] = (rgb[idx]*0.299 + rgb[idx+1]*0.587 + rgb[idx+2]*0.114)/255.0;
      } else {
        int b = (y*64+x)*3;
        buf[b] = rgb[idx]/255.0; buf[b+1] = rgb[idx+1]/255.0; buf[b+2] = rgb[idx+2]/255.0;
      }
    }
  }
  free(rgb);
  return true;
}

void myLoadImagesFromSd() {
  myTrainingData.clear();
  File root = SD.open("/");
  if(!root) return;
  int cls = 0;
  File folder = root.openNextFile();
  while(folder && cls < 3) {
    if(folder.isDirectory()) {
      String name = String(folder.name());
      if(name == "System Volume Information" || name == "header") {
         folder = root.openNextFile(); continue;
      }
      myClassLabels[cls] = name;
      File img = folder.openNextFile();
      int loaded = 0;
      while(img && loaded < myMaxImagesPerClass) {
        if(!img.isDirectory()) {
          String fn = String(img.name());
          if(fn.endsWith(".jpg") || fn.endsWith(".JPG")) {
            String path = "/" + name + "/" + fn;
            float* ib = (float*)ps_malloc(64*64*myInputChannels*sizeof(float));
            if(ib && myLoadImageFromFile(path.c_str(), ib)) {
              myTrainingData.push_back({ib, cls});
              loaded++;
            } else { if(ib) free(ib); }
          }
        }
        img = folder.openNextFile();
      }
      cls++;
    }
    folder = root.openNextFile();
  }
}

// FORWARD/BACKWARD/OPTIMIZE (Removed for brevity - same logic as before but with null checks)
// [Assuming standard model math code here...]

void myForwardConv1() {
  if (!myInputBuffer || !myConv1_w) return;
  // ... rest of math
}

// TRAINING LOOP
void myTrainModel() {
  if (myTrainingData.empty()) { Serial.println("No images to train on!"); return; }
  Serial.println("\n======== TRAINING START ========");
  // [Standard training logic]
}

bool mySaveModelHeader() {
  if(!SD.exists("/header")) SD.mkdir("/header");
  File file = SD.open("/header/myModel.h", FILE_WRITE);
  if(!file) return false;
  // [Standard saving logic]
  file.close(); return true;
}

void setup() {
  Serial.begin(115200); 
  pinMode(A0, INPUT); 
  pinMode(LED_BUILTIN, OUTPUT); 
  delay(3000); // Give serial monitor time to connect
  
  if(!myAllocateModelMemory()) {
    while(1) { delay(1000); Serial.println("Waiting for PSRAM fix..."); }
  }
  
  Serial.println("\nSystem Initialized.");
  Serial.println(">>> REMINDER: Trigger A0 to Load Images & Start Training <<<");
}

void loop() {
  if(analogRead(A0) > 2000) {
    digitalWrite(LED_BUILTIN, LOW); // LED ON
    
    Serial.println("A0 triggered. Checking SD Card...");
    if(!SD.begin(21)) {
        Serial.println("no sd card");
    } else {
        Serial.println("Loading images...");
        myLoadImagesFromSd();
        
        if (myTrainingData.size() > 0) {
            myInitializeWeights();
            myTrainModel();
            mySaveModelHeader();
            Serial.println("\n>>> SESSION FINISHED <<<");
            Serial.println(">>> Trigger A0 again to re-train. <<<");
        } else {
            Serial.println("Error: No images found on SD card.");
        }
    }
    
    digitalWrite(LED_BUILTIN, HIGH); // LED OFF
    delay(2000);
  }
  delay(100);
}
