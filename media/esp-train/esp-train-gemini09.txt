/*
 * ESP32-S3 On-Device CNN Training - OLED INTEGRATED VERSION
 * 1. Loads images from /images/ folder
 * 2. Saves/Loads binary weights from /header/myWeights.bin for permanence
 * 3. Displays Loss and Status on 72x40 OLED
 * Press A0 to start training, saves myModel.h to SD /header/ folder
 */

#include "esp_camera.h"
#include "img_converters.h"
#include "FS.h"
#include "SD.h"
#include "SPI.h"
#include <vector>
#include <U8g2lib.h>
#include <Wire.h>

// OLED DISPLAY INITIALIZATION
// SSD1306 controller, 72x40 resolution, I2C interface
U8G2_SSD1306_72X40_ER_1_HW_I2C u8g2(U8G2_R2, U8X8_PIN_NONE);

// USER PARAMETERS
#define USE_GRAYSCALE_MODE false
#define USE_INT8_QUANTIZATION false
float LEARNING_RATE = 0.001;
float DROPOUT_RATE = 0.3;
int BATCH_SIZE = 6;
int TARGET_EPOCHS = 10;
int MAX_IMAGES_PER_CLASS = 100;
bool USE_AUGMENTATION = true;
float BRIGHTNESS_RANGE = 0.2;
float CONTRAST_RANGE = 0.4;

// CAMERA PINS
#define XCLK_GPIO_NUM 10
#define SIOD_GPIO_NUM 40
#define SIOC_GPIO_NUM 39
#define Y9_GPIO_NUM 48
#define Y8_GPIO_NUM 11
#define Y7_GPIO_NUM 12
#define Y6_GPIO_NUM 14
#define Y5_GPIO_NUM 16
#define Y4_GPIO_NUM 18
#define Y3_GPIO_NUM 17
#define Y2_GPIO_NUM 15
#define VSYNC_GPIO_NUM 38
#define HREF_GPIO_NUM 47
#define PCLK_GPIO_NUM 13

// MODEL ARCHITECTURE
const int INPUT_CHANNELS = USE_GRAYSCALE_MODE ? 1 : 3;
const int FLATTENED_SIZE = 6728;

// WEIGHTS
float *conv1_w, *conv1_b, *conv2_w, *conv2_b, *dense_w, *dense_b;
float *conv1_w_grad, *conv1_b_grad, *conv2_w_grad, *conv2_b_grad, *dense_w_grad, *dense_b_grad;
float *conv1_w_m, *conv1_w_v, *conv1_b_m, *conv1_b_v;
float *conv2_w_m, *conv2_w_v, *conv2_b_m, *conv2_b_v;
float *dense_w_m, *dense_w_v, *dense_b_m, *dense_b_v;

// BUFFERS
float *input_buffer, *conv1_output, *pool1_output, *conv2_output, *dropout_mask, *dense_output;
float *dense_grad, *conv2_grad, *pool1_grad, *conv1_grad;

// DATA
struct TrainingImage { float* data; int label; };
std::vector<TrainingImage> training_data;
String class_labels[3];
int class_counts[3] = {0,0,0};

// UTILITY
inline float clip_value(float v, float mn=-100, float mx=100) {
  if(isnan(v)||isinf(v)) return 0;
  return constrain(v,mn,mx);
}
inline float leaky_relu(float x) { return x>0 ? x : 0.1f*x; }
inline float leaky_relu_deriv(float x) { return x>0 ? 1.0f : 0.1f; }
float random_float(float mn, float mx) { return mn + (float)random(10000)/10000.0f*(mx-mn); }

String toCString(String s) {
  s = s.substring(0,20);
  s.replace("\\","\\\\"); s.replace("\"","\\\""); s.replace("\n","\\n");
  return s;
}

// OLED HELPER
void myDisplayStatus(String myLine1, String myLine2) {
  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_ncenB08_tr);
    u8g2.setCursor(4, 15);
    u8g2.print(myLine1);
    u8g2.setCursor(4, 32);
    u8g2.print(myLine2);
    u8g2.drawFrame(0, 0, 72, 40);
  } while (u8g2.nextPage());
}

// MEMORY ALLOCATION
bool allocate_model_memory() {
  Serial.println("\n=== Allocating Memory ===");
  int c1w_sz = 3*3*INPUT_CHANNELS*4;
  int c2w_sz = 3*3*4*8;
  int dw_sz = FLATTENED_SIZE*3;
  
  conv1_w = (float*)ps_malloc(c1w_sz*sizeof(float));
  conv1_b = (float*)ps_malloc(4*sizeof(float));
  conv2_w = (float*)ps_malloc(c2w_sz*sizeof(float));
  conv2_b = (float*)ps_malloc(8*sizeof(float));
  dense_w = (float*)ps_malloc(dw_sz*sizeof(float));
  dense_b = (float*)ps_malloc(3*sizeof(float));
  
  conv1_w_grad = (float*)ps_malloc(c1w_sz*sizeof(float));
  conv1_b_grad = (float*)ps_malloc(4*sizeof(float));
  conv2_w_grad = (float*)ps_malloc(c2w_sz*sizeof(float));
  conv2_b_grad = (float*)ps_malloc(8*sizeof(float));
  dense_w_grad = (float*)ps_malloc(dw_sz*sizeof(float));
  dense_b_grad = (float*)ps_malloc(3*sizeof(float));
  
  conv1_w_m = (float*)ps_calloc(c1w_sz, sizeof(float));
  conv1_w_v = (float*)ps_calloc(c1w_sz, sizeof(float));
  conv1_b_m = (float*)ps_calloc(4, sizeof(float));
  conv1_b_v = (float*)ps_calloc(4, sizeof(float));
  conv2_w_m = (float*)ps_calloc(c2w_sz, sizeof(float));
  conv2_w_v = (float*)ps_calloc(c2w_sz, sizeof(float));
  conv2_b_m = (float*)ps_calloc(8, sizeof(float));
  conv2_b_v = (float*)ps_calloc(8, sizeof(float));
  dense_w_m = (float*)ps_calloc(dw_sz, sizeof(float));
  dense_w_v = (float*)ps_calloc(dw_sz, sizeof(float));
  dense_b_m = (float*)ps_calloc(3, sizeof(float));
  dense_b_v = (float*)ps_calloc(3, sizeof(float));
  
  input_buffer = (float*)ps_malloc(64*64*INPUT_CHANNELS*sizeof(float));
  conv1_output = (float*)ps_malloc(62*62*4*sizeof(float));
  pool1_output = (float*)ps_malloc(31*31*4*sizeof(float));
  conv2_output = (float*)ps_malloc(29*29*8*sizeof(float));
  dropout_mask = (float*)ps_malloc(FLATTENED_SIZE*sizeof(float));
  dense_output = (float*)ps_malloc(3*sizeof(float));
  
  dense_grad = (float*)ps_malloc(FLATTENED_SIZE*sizeof(float));
  conv2_grad = (float*)ps_malloc(29*29*8*sizeof(float));
  pool1_grad = (float*)ps_malloc(31*31*4*sizeof(float));
  conv1_grad = (float*)ps_malloc(62*62*4*sizeof(float));
  
  if(!conv1_w || !conv2_w || !dense_w) { Serial.println("[ERR] Alloc failed!"); return false; }
  Serial.printf("Free PSRAM: %d bytes\n", ESP.getFreePsram());
  return true;
}

// Binary Weight Permanence
bool myLoadWeightsFromSD() {
  if(!SD.exists("/header/myWeights.bin")) return false;
  fs::File myWeightFile = SD.open("/header/myWeights.bin", FILE_READ);
  if(!myWeightFile) return false;

  int myC1sz = (USE_GRAYSCALE_MODE ? 36 : 108);
  myWeightFile.read((uint8_t*)conv1_w, myC1sz * sizeof(float));
  myWeightFile.read((uint8_t*)conv1_b, 4 * sizeof(float));
  myWeightFile.read((uint8_t*)conv2_w, 288 * sizeof(float));
  myWeightFile.read((uint8_t*)conv2_b, 8 * sizeof(float));
  myWeightFile.read((uint8_t*)dense_w, (FLATTENED_SIZE * 3) * sizeof(float));
  myWeightFile.read((uint8_t*)dense_b, 3 * sizeof(float));
  
  myWeightFile.close();
  return true;
}

void initialize_weights() {
  if(myLoadWeightsFromSD()) {
    Serial.println("Weights loaded from SD.");
    return;
  }
  Serial.println("Initializing weights randomly...");
  int c1w_sz = USE_GRAYSCALE_MODE ? 36 : 108;
  float c1std = sqrt(2.0/(9.0*INPUT_CHANNELS));
  for(int i=0; i<c1w_sz; i++) conv1_w[i] = random_float(-c1std, c1std);
  for(int i=0; i<4; i++) conv1_b[i] = 0;
  
  float c2std = sqrt(2.0/36.0);
  for(int i=0; i<288; i++) conv2_w[i] = random_float(-c2std, c2std);
  for(int i=0; i<8; i++) conv2_b[i] = 0;
  
  float dstd = sqrt(2.0/FLATTENED_SIZE);
  for(int i=0; i<FLATTENED_SIZE*3; i++) dense_w[i] = random_float(-dstd, dstd);
  for(int i=0; i<3; i++) dense_b[i] = 0;
}

// IMAGE LOADING
bool load_image_from_file(const char* path, float* buf) {
  File f = SD.open(path);
  if(!f) return false;
  
  size_t sz = f.size();
  uint8_t* jpg = (uint8_t*)ps_malloc(sz);
  if(!jpg) { f.close(); return false; }
  f.read(jpg, sz);
  f.close();
  
  uint8_t* rgb = (uint8_t*)ps_malloc(320*240*3);
  if(!rgb) { free(jpg); return false; }
  
  bool ok = fmt2rgb888(jpg, sz, PIXFORMAT_JPEG, rgb);
  free(jpg);
  if(!ok) { free(rgb); return false; }
  
  for(int y=0; y<64; y++) {
    for(int x=0; x<64; x++) {
      int sy = (int)((y+0.5)*240.0/64.0);
      int sx = (int)((x+0.5)*320.0/64.0);
      if(sy>239) sy=239;
      if(sx>319) sx=319;
      int idx = (sy*320+sx)*3;
      if(USE_GRAYSCALE_MODE) {
        buf[y*64+x] = (rgb[idx]*0.299 + rgb[idx+1]*0.587 + rgb[idx+2]*0.114)/255.0;
      } else {
        int b = (y*64+x)*3;
        buf[b] = rgb[idx]/255.0;
        buf[b+1] = rgb[idx+1]/255.0;
        buf[b+2] = rgb[idx+2]/255.0;
      }
    }
  }
  
  free(rgb);
  return true;
}

void load_images_from_sd() {
  Serial.println("\n=== Loading Images ===");
  File root = SD.open("/images");
  if(!root) { Serial.println("[ERR] SD /images not found"); return; }
  
  int cls = 0;
  File folder = root.openNextFile();
  while(folder && cls < 3) {
    if(folder.isDirectory()) {
      String name = String(folder.name());
      if(name.startsWith(".") || name=="header" || name=="System Volume Information") {
        folder = root.openNextFile();
        continue;
      }
      
      class_labels[cls] = name;
      Serial.printf("\nClass %d: %s\n", cls, name.c_str());
      File img = folder.openNextFile();
      int loaded = 0;
      
      while(img && loaded < MAX_IMAGES_PER_CLASS) {
        if(!img.isDirectory()) {
          String fn = String(img.name());
          if(fn.endsWith(".jpg") || fn.endsWith(".JPG")) {
            String path = "/images/" + name + "/" + fn;
            float* ib = (float*)ps_malloc(64*64*INPUT_CHANNELS*sizeof(float));
            if(ib && load_image_from_file(path.c_str(), ib)) {
              TrainingImage ti;
              ti.data = ib;
              ti.label = cls;
              training_data.push_back(ti);
              loaded++;
              class_counts[cls]++;
            } else {
              if(ib) free(ib);
            }
          }
        }
        img = folder.openNextFile();
      }
      
      Serial.printf("  Loaded: %d\n", loaded);
      cls++;
    }
    folder = root.openNextFile();
  }
  
  Serial.printf("\nTotal: %d [%d,%d,%d]\n", training_data.size(), class_counts[0], class_counts[1], class_counts[2]);
}

void augment_image(float* src, float* dst) {
  int sz = 64*64*INPUT_CHANNELS;
  if(!USE_AUGMENTATION) { memcpy(dst, src, sz*sizeof(float)); return; }
  
  float br = random_float(-BRIGHTNESS_RANGE, BRIGHTNESS_RANGE);
  float co = random_float(1.0-CONTRAST_RANGE/2, 1.0+CONTRAST_RANGE/2);
  for(int i=0; i<sz; i++) {
    dst[i] = clip_value((src[i]-0.5)*co+0.5+br, 0.0, 1.0);
  }
}

// FORWARD
void forward_conv1() {
  for(int f=0; f<4; f++) {
    int ob = f*3844;
    for(int y=0; y<62; y++) {
      for(int x=0; x<62; x++) {
        float s = 0;
        if(USE_GRAYSCALE_MODE) {
          for(int ky=0; ky<3; ky++)
            for(int kx=0; kx<3; kx++)
              s += input_buffer[(y+ky)*64+(x+kx)] * conv1_w[f*9+ky*3+kx];
        } else {
          for(int ky=0; ky<3; ky++) {
            for(int kx=0; kx<3; kx++) {
              int p = ((y+ky)*64+(x+kx))*3;
              int w = f*27+ky*9+kx*3;
              s += input_buffer[p]*conv1_w[w] + input_buffer[p+1]*conv1_w[w+1] + input_buffer[p+2]*conv1_w[w+2];
            }
          }
        }
        conv1_output[ob+y*62+x] = leaky_relu(clip_value(s+conv1_b[f]));
      }
    }
  }
}

void forward_pool1() {
  for(int f=0; f<4; f++) {
    int ib=f*3844, ob=f*961;
    for(int y=0; y<31; y++) {
      for(int x=0; x<31; x++) {
        int iy=y*2, ix=x*2;
        float m = conv1_output[ib+iy*62+ix];
        m = max(m, conv1_output[ib+iy*62+ix+1]);
        m = max(m, conv1_output[ib+(iy+1)*62+ix]);
        m = max(m, conv1_output[ib+(iy+1)*62+ix+1]);
        pool1_output[ob+y*31+x] = m;
      }
    }
  }
}

void forward_conv2() {
  for(int f=0; f<8; f++) {
    int ob=f*841;
    for(int y=0; y<29; y++) {
      for(int x=0; x<29; x++) {
        float s = 0;
        for(int c=0; c<4; c++) {
          int ib=c*961;
          for(int ky=0; ky<3; ky++)
            for(int kx=0; kx<3; kx++)
              s += pool1_output[ib+(y+ky)*31+(x+kx)] * conv2_w[f*36+c*9+ky*3+kx];
        }
        conv2_output[ob+y*29+x] = leaky_relu(clip_value(s+conv2_b[f]));
      }
    }
  }
}

void forward_dropout(bool training) {
  if(training && DROPOUT_RATE>0) {
    float kp = 1.0-DROPOUT_RATE;
    for(int i=0; i<FLATTENED_SIZE; i++) {
      dropout_mask[i] = (random_float(0,1)<kp) ? (1.0/kp) : 0.0;
      conv2_output[i] *= dropout_mask[i];
    }
  } else {
    for(int i=0; i<FLATTENED_SIZE; i++) dropout_mask[i] = 1.0;
  }
}

void forward_dense() {
  for(int c=0; c<3; c++) {
    double s=0, comp=0;
    for(int i=0; i<FLATTENED_SIZE; i++) {
      double t = conv2_output[i]*dense_w[c*FLATTENED_SIZE+i];
      double y = t-comp;
      double tt = s+y;
      comp = (tt-s)-y;
      s = tt;
    }
    dense_output[c] = clip_value((float)s+dense_b[c], -50, 50);
  }
  
  float mx = max(max(dense_output[0], dense_output[1]), dense_output[2]);
  float es = exp(dense_output[0]-mx) + exp(dense_output[1]-mx) + exp(dense_output[2]-mx);
  for(int i=0; i<3; i++) dense_output[i] = exp(dense_output[i]-mx)/es;
}

// BACKWARD
void backward_dense(int lbl) {
  for(int c=0; c<3; c++) {
    float e = dense_output[c] - (c==lbl ? 1.0f : 0.0f);
    for(int i=0; i<FLATTENED_SIZE; i++) {
      dense_w_grad[c*FLATTENED_SIZE+i] = e*conv2_output[i];
      dense_grad[i] = (c==0) ? e*dense_w[c*FLATTENED_SIZE+i] : dense_grad[i]+e*dense_w[c*FLATTENED_SIZE+i];
    }
    dense_b_grad[c] = e;
  }
}

void backward_dropout() {
  for(int i=0; i<FLATTENED_SIZE; i++) dense_grad[i] *= dropout_mask[i];
}

void backward_conv2() {
  for(int i=0; i<FLATTENED_SIZE; i++) conv2_grad[i] = dense_grad[i]*leaky_relu_deriv(conv2_output[i]);
  
  memset(conv2_w_grad, 0, 288*sizeof(float));
  memset(conv2_b_grad, 0, 8*sizeof(float));
  memset(pool1_grad, 0, 3844*sizeof(float));
  for(int f=0; f<8; f++) {
    int ob=f*841;
    for(int y=0; y<29; y++) {
      for(int x=0; x<29; x++) {
        float g = conv2_grad[ob+y*29+x];
        conv2_b_grad[f] += g;
        for(int c=0; c<4; c++) {
          int ib=c*961;
          for(int ky=0; ky<3; ky++) {
            for(int kx=0; kx<3; kx++) {
              int pi = ib+(y+ky)*31+(x+kx);
              int wi = f*36+c*9+ky*3+kx;
              conv2_w_grad[wi] += g*pool1_output[pi];
              pool1_grad[pi] += g*conv2_w[wi];
            }
          }
        }
      }
    }
  }
}

void backward_pool1() {
  memset(conv1_grad, 0, 15376*sizeof(float));
  for(int f=0; f<4; f++) {
    int ib=f*3844, ob=f*961;
    for(int y=0; y<31; y++) {
      for(int x=0; x<31; x++) {
        int iy=y*2, ix=x*2;
        float pv = pool1_output[ob+y*31+x];
        float g = pool1_grad[ob+y*31+x];
        if(conv1_output[ib+iy*62+ix] == pv) conv1_grad[ib+iy*62+ix] += g;
        if(conv1_output[ib+iy*62+ix+1] == pv) conv1_grad[ib+iy*62+ix+1] += g;
        if(conv1_output[ib+(iy+1)*62+ix] == pv) conv1_grad[ib+(iy+1)*62+ix] += g;
        if(conv1_output[ib+(iy+1)*62+ix+1] == pv) conv1_grad[ib+(iy+1)*62+ix+1] += g;
      }
    }
  }
}

void backward_conv1() {
  for(int i=0; i<15376; i++) conv1_grad[i] *= leaky_relu_deriv(conv1_output[i]);
  int wsz = USE_GRAYSCALE_MODE ? 36 : 108;
  memset(conv1_w_grad, 0, wsz*sizeof(float));
  memset(conv1_b_grad, 0, 4*sizeof(float));
  for(int f=0; f<4; f++) {
    int ob=f*3844;
    for(int y=0; y<62; y++) {
      for(int x=0; x<62; x++) {
        float g = conv1_grad[ob+y*62+x];
        conv1_b_grad[f] += g;
        
        if(USE_GRAYSCALE_MODE) {
          for(int ky=0; ky<3; ky++)
            for(int kx=0; kx<3; kx++)
              conv1_w_grad[f*9+ky*3+kx] += g*input_buffer[(y+ky)*64+(x+kx)];
        } else {
          for(int ky=0; ky<3; ky++) {
            for(int kx=0; kx<3; kx++) {
              int p = ((y+ky)*64+(x+kx))*3;
              int w = f*27+ky*9+kx*3;
              conv1_w_grad[w] += g*input_buffer[p];
              conv1_w_grad[w+1] += g*input_buffer[p+1];
              conv1_w_grad[w+2] += g*input_buffer[p+2];
            }
          }
        }
      }
    }
  }
}

// ADAM UPDATE
void adam_update(float* w, float* g, float* m, float* v, int sz, int step) {
  float b1=0.9, b2=0.999, eps=1e-8;
  float lr_t = LEARNING_RATE * sqrt(1-pow(b2,step)) / (1-pow(b1,step));
  for(int i=0; i<sz; i++) {
    m[i] = b1*m[i] + (1-b1)*g[i];
    v[i] = b2*v[i] + (1-b2)*g[i]*g[i];
    w[i] -= lr_t*m[i]/(sqrt(v[i])+eps);
    w[i] = clip_value(w[i], -10, 10);
  }
}

void update_weights(int step) {
  int c1sz = USE_GRAYSCALE_MODE ? 36 : 108;
  adam_update(conv1_w, conv1_w_grad, conv1_w_m, conv1_w_v, c1sz, step);
  adam_update(conv1_b, conv1_b_grad, conv1_b_m, conv1_b_v, 4, step);
  adam_update(conv2_w, conv2_w_grad, conv2_w_m, conv2_w_v, 288, step);
  adam_update(conv2_b, conv2_b_grad, conv2_b_m, conv2_b_v, 8, step);
  adam_update(dense_w, dense_w_grad, dense_w_m, dense_w_v, FLATTENED_SIZE*3, step);
  adam_update(dense_b, dense_b_grad, dense_b_m, dense_b_v, 3, step);
}

// TRAINING
void train_model() {
  Serial.println("\n======== TRAINING START ========");
  myDisplayStatus("Training", "Started...");
  
  int total = training_data.size();
  int batches_per_epoch = (total + BATCH_SIZE - 1) / BATCH_SIZE;
  int total_batches = TARGET_EPOCHS * batches_per_epoch;
  
  std::vector<int> indices;
  for(int i=0; i<total; i++) indices.push_back(i);
  
  float running_loss = 0;
  int loss_count = 0;
  for(int batch=0; batch<total_batches; batch++) {
    if(batch % batches_per_epoch == 0) {
      Serial.printf("\n--- Epoch %d/%d ---\n", batch/batches_per_epoch + 1, TARGET_EPOCHS);
      for(int i=total-1; i>0; i--) {
        int j = random(i+1);
        int tmp = indices[i];
        indices[i] = indices[j];
        indices[j] = tmp;
      }
    }
    
    int batch_start = (batch % batches_per_epoch) * BATCH_SIZE;
    int batch_end = min(batch_start + BATCH_SIZE, total);
    
    float batch_loss = 0;
    for(int i=batch_start; i<batch_end; i++) {
      int idx = indices[i];
      TrainingImage& img = training_data[idx];
      
      augment_image(img.data, input_buffer);
      forward_conv1();
      forward_pool1();
      forward_conv2();
      forward_dropout(true);
      forward_dense();
      
      backward_dense(img.label);
      backward_dropout();
      backward_conv2();
      backward_pool1();
      backward_conv1();
      
      float loss = 0;
      for(int c=0; c<3; c++) {
        float target = (c == img.label) ? 1.0f : 0.0f;
        loss -= target * log(max(dense_output[c], 1e-7f));
      }
      batch_loss += loss;
    }
    
    update_weights(batch+1);
    
    running_loss += batch_loss / (batch_end - batch_start);
    loss_count++;
    
    // OLED Update every 10 batches
    if((batch+1) % 10 == 0) {
      float avg_loss = running_loss / loss_count;
      myDisplayStatus("Batch " + String(batch+1), "Loss: " + String(avg_loss, 3));
      running_loss = 0;
      loss_count = 0;
    }
  }
  
  Serial.println("\n======== TRAINING COMPLETE ========");
  myDisplayStatus("Training", "Complete!");
}

// SAVE MODEL TO SD CARD
bool save_model_header() {
  Serial.println("\n=== Saving Model ===");
  if(!SD.exists("/header")) {
    if(!SD.mkdir("/header")) {
      Serial.println("[ERR] Cannot create /header folder");
      return false;
    }
  }

  // Backup Binary weights
  fs::File myBinFile = SD.open("/header/myWeights.bin", FILE_WRITE);
  if(myBinFile) {
    int myC1sz = (USE_GRAYSCALE_MODE ? 36 : 108);
    myBinFile.write((uint8_t*)conv1_w, myC1sz * sizeof(float));
    myBinFile.write((uint8_t*)conv1_b, 4 * sizeof(float));
    myBinFile.write((uint8_t*)conv2_w, 288 * sizeof(float));
    myBinFile.write((uint8_t*)conv2_b, 8 * sizeof(float));
    myBinFile.write((uint8_t*)dense_w, (FLATTENED_SIZE * 3) * sizeof(float));
    myBinFile.write((uint8_t*)dense_b, 3 * sizeof(float));
    myBinFile.close();
  }
  
  if(SD.exists("/header/myModel.h")) {
    SD.remove("/header/myModel.h");
    delay(100);
  }
  
  File file = SD.open("/header/myModel.h", FILE_WRITE);
  if(!file) {
    Serial.println("[ERR] Cannot open /header/myModel.h");
    return false;
  }
  
  file.println("// Auto-generated model");
  file.println("#ifndef MY_MODEL_H");
  file.println("#define MY_MODEL_H");
  file.println();
  
  file.println("const char* myClassLabels[3] = {");
  file.print("  \""); file.print(toCString(class_labels[0])); file.println("\",");
  file.print("  \""); file.print(toCString(class_labels[1])); file.println("\",");
  file.print("  \""); file.print(toCString(class_labels[2])); file.println("\"");
  file.println("};");
  
  // Weight dump logic
  int c1w_sz = USE_GRAYSCALE_MODE ? 36 : 108;
  file.print("const float myConv1_w[] = { ");
  for(int i=0; i<c1w_sz; i++) {
    file.print(conv1_w[i],6); file.print("f");
    if(i<c1w_sz-1) file.print(", ");
    if((i+1)%10==0) file.println();
  }
  file.println(" };");
  
  file.println("#endif");
  file.close();
  return true;
}

// SETUP
void setup() {
  Serial.begin(115200);
  pinMode(A0, INPUT);
  pinMode(LED_BUILTIN, OUTPUT);
  
  // Initialize Display
  u8g2.begin();
  myDisplayStatus("XIAO S3", "Ready...");
  
  if(!SD.begin(21)) {
    myDisplayStatus("SD Error", "Check Card");
    while(1) { delay(1000); }
  }
  
  load_images_from_sd();
  if(training_data.size() < 3) {
    myDisplayStatus("Data Error", "No Images");
    while(1) { delay(1000); }
  }
  
  if(!allocate_model_memory()) {
    myDisplayStatus("Mem Error", "PSRAM Full");
    while(1) { delay(1000); }
  }
  
  myDisplayStatus("Press A0", "To Train");
  Serial.println("Press A0 to start training...");
}

// LOOP
void loop() {
  if(analogRead(A0) > 2000) {
    digitalWrite(LED_BUILTIN, LOW);
    
    initialize_weights();
    train_model();
    
    if(save_model_header()) {
      myDisplayStatus("Saved!", "/header/");
    } else {
      myDisplayStatus("Save", "Failed!");
    }
    
    digitalWrite(LED_BUILTIN, HIGH);
    delay(3000);
    myDisplayStatus("Ready", "Press A0");
  }
  delay(100);
}
