#include <Arduino.h>
#include <FS.h>
#include <SD.h>
#include <SPI.h>
#include <vector>
#include <algorithm>

// ================= USER PARAMETERS =================
#define USE_GRAYSCALE_MODE false
#define USE_INT8_QUANTIZATION false

float LEARNING_RATE = 0.001;
float DROPOUT_RATE  = 0.3;

int BATCH_SIZE = 6;
int TARGET_EPOCHS = 10;
int MAX_IMAGES_PER_CLASS = 100;

bool  USE_AUGMENTATION = true;
float BRIGHTNESS_RANGE = 0.2;
float CONTRAST_RANGE   = 0.4;

// ================= PATHS =================
#define IMAGE_ROOT_FOLDER "/images"
#define MODEL_FOLDER      "/header"
#define MODEL_BIN_PATH    "/header/myModel.bin"
#define MODEL_HEADER_PATH "/header/myModel.h"

// ================= MODEL SHAPES (MATCH INFERENCE) =================
#define IMG_W 64
#define IMG_H 64
#define IMG_C 3
#define NUM_CLASSES 3

// Conv sizes confirmed by you
const int CONV1_W_SIZE = 108;
const int CONV2_W_SIZE = 288;
const int OUTPUT_W_SIZE = 20184;

// ================= DATA STRUCTURES =================
struct myImageSample {
  std::vector<float> myPixels;
  int myLabel;
};

// ================= MODEL PARAMETERS =================
float myConv1_w[CONV1_W_SIZE];
float myConv1_b[4];

float myConv2_w[CONV2_W_SIZE];
float myConv2_b[8];

float myOutput_w[OUTPUT_W_SIZE];
float myOutput_b[NUM_CLASSES];

// ================= GLOBAL STATE =================
std::vector<String> myLabelNames;
std::vector<myImageSample> myDataset;

// ================= FORWARD DECLARATIONS =================
bool myLoadModelBinary();
void mySaveModelBinary();
void mySaveModelHeader();
void myInitializeWeights();
void myLoadDataset();
float myTrainEpoch();
float myTrainSample(myImageSample &mySample);

// ================= UTILS =================
float myRandf(float a, float b) {
  return a + (b - a) * ((float)rand() / RAND_MAX);
}

// ================= SETUP =================
void setup() {
  Serial.begin(115200);
  delay(2000);

  pinMode(A0, INPUT);

  if (!SD.begin()) {
    Serial.println("❌ SD init failed");
    while (true);
  }

  if (!SD.exists(MODEL_FOLDER)) {
    SD.mkdir(MODEL_FOLDER);
  }

  srand(millis()); // augmentation randomness per run

  if (!myLoadModelBinary()) {
    Serial.println("⚠ No binary model found — initializing weights");
    myInitializeWeights();
  } else {
    Serial.println("✅ Loaded model from binary");
  }

  myLoadDataset();
  Serial.println("✅ Setup complete");
}

// ================= LOOP =================
void loop() {
  if (analogRead(A0) > 2000) {
    Serial.println("\n===== TRAINING START =====");

    for (int e = 0; e < TARGET_EPOCHS; e++) {
      float myEpochLoss = myTrainEpoch();
      Serial.print("Epoch ");
      Serial.print(e + 1);
      Serial.print("/");
      Serial.print(TARGET_EPOCHS);
      Serial.print(" — Avg Loss: ");
      Serial.println(myEpochLoss, 6);
    }

    mySaveModelBinary();
    mySaveModelHeader();

    Serial.println("===== TRAINING DONE =====");
    delay(2000); // debounce
  }
}

// ================= DATASET LOADING =================
void myLoadDataset() {
  myDataset.clear();
  myLabelNames.clear();

  File myRoot = SD.open(IMAGE_ROOT_FOLDER);
  if (!myRoot) {
    Serial.println("❌ Cannot open images folder");
    return;
  }

  // Collect label folders
  std::vector<String> myFolders;
  File myFile;
  while ((myFile = myRoot.openNextFile())) {
    if (myFile.isDirectory()) {
      myFolders.push_back(String(myFile.name()));
    }
    myFile.close();
  }
  myRoot.close();

  std::sort(myFolders.begin(), myFolders.end());
  myLabelNames = myFolders;

  for (int l = 0; l < myFolders.size(); l++) {
    String myLabelPath = String(IMAGE_ROOT_FOLDER) + "/" + myFolders[l];
    File myDir = SD.open(myLabelPath);

    std::vector<String> myFiles;
    File f;
    while ((f = myDir.openNextFile())) {
      if (!f.isDirectory()) {
        myFiles.push_back(String(f.name()));
      }
      f.close();
    }
    myDir.close();

    std::sort(myFiles.begin(), myFiles.end());

    int count = 0;
    for (String fname : myFiles) {
      if (count >= MAX_IMAGES_PER_CLASS) break;

      // Placeholder: real image decode already exists in your working version
      myImageSample s;
      s.myPixels.resize(IMG_W * IMG_H * IMG_C, 0.5f);
      s.myLabel = l;
      myDataset.push_back(s);
      count++;
    }
  }

  Serial.print("Loaded samples: ");
  Serial.println(myDataset.size());
}

// ================= TRAINING =================
float myTrainEpoch() {
  float myLossSum = 0.0;
  int correct = 0;

  for (int i = 0; i < BATCH_SIZE; i++) {
    myImageSample &s = myDataset[random(myDataset.size())];
    float loss = myTrainSample(s);
    myLossSum += loss;
  }

  return myLossSum / BATCH_SIZE;
}

float myTrainSample(myImageSample &mySample) {
  // This function intentionally assumes your EXISTING forward/backward math
  // Replace body with your already-working implementation

  // Dummy loss placeholder so code compiles
  return myRandf(0.2, 1.0);
}

// ================= WEIGHTS =================
void myInitializeWeights() {
  for (int i = 0; i < CONV1_W_SIZE; i++) myConv1_w[i] = myRandf(-0.1, 0.1);
  for (int i = 0; i < 4; i++) myConv1_b[i] = 0;

  for (int i = 0; i < CONV2_W_SIZE; i++) myConv2_w[i] = myRandf(-0.1, 0.1);
  for (int i = 0; i < 8; i++) myConv2_b[i] = 0;

  for (int i = 0; i < OUTPUT_W_SIZE; i++) myOutput_w[i] = myRandf(-0.1, 0.1);
  for (int i = 0; i < NUM_CLASSES; i++) myOutput_b[i] = 0;
}

// ================= BINARY SAVE / LOAD =================
bool myLoadModelBinary() {
  if (!SD.exists(MODEL_BIN_PATH)) return false;

  File f = SD.open(MODEL_BIN_PATH, FILE_READ);
  if (!f) return false;

  f.read((uint8_t*)myConv1_w, sizeof(myConv1_w));
  f.read((uint8_t*)myConv1_b, sizeof(myConv1_b));
  f.read((uint8_t*)myConv2_w, sizeof(myConv2_w));
  f.read((uint8_t*)myConv2_b, sizeof(myConv2_b));
  f.read((uint8_t*)myOutput_w, sizeof(myOutput_w));
  f.read((uint8_t*)myOutput_b, sizeof(myOutput_b));

  f.close();
  return true;
}

void mySaveModelBinary() {
  File f = SD.open(MODEL_BIN_PATH, FILE_WRITE);
  if (!f) return;

  f.write((uint8_t*)myConv1_w, sizeof(myConv1_w));
  f.write((uint8_t*)myConv1_b, sizeof(myConv1_b));
  f.write((uint8_t*)myConv2_w, sizeof(myConv2_w));
  f.write((uint8_t*)myConv2_b, sizeof(myConv2_b));
  f.write((uint8_t*)myOutput_w, sizeof(myOutput_w));
  f.write((uint8_t*)myOutput_b, sizeof(myOutput_b));

  f.close();
}

// ================= HEADER EXPORT =================
void mySaveModelHeader() {
  File f = SD.open(MODEL_HEADER_PATH, FILE_WRITE);
  if (!f) return;

  f.println("#ifndef MY_MODEL_H");
  f.println("#define MY_MODEL_H");
  f.println();

  f.print("const float myConv1_w[");
  f.print(CONV1_W_SIZE);
  f.println("] = {...};");

  f.print("const float myConv2_w[");
  f.print(CONV2_W_SIZE);
  f.println("] = {...};");

  f.print("const float myOutput_w[");
  f.print(OUTPUT_W_SIZE);
  f.println("] = {...};");

  f.println("#endif");
  f.close();
}
