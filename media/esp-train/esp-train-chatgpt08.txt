#include <Arduino.h>
#include <SD.h>
#include <SPI.h>

// =======================================================
// CONFIGURATION
// =======================================================

#define MY_A0_TRIGGER_PIN A0

#define MY_IMAGE_ROOT     "/images"   // /images/<label>/*.jpg
#define MY_MODEL_FOLDER   "/header"   // trained outputs only

#define MY_MODEL_HEADER   "/header/myModel_trained.h"
#define MY_MODEL_BIN      "/header/myModel_trained.bin"

// =======================================================
// MODEL SHAPE (MATCHES INFERENCE)
// =======================================================

#define MY_IMAGE_W        32
#define MY_IMAGE_H        32
#define MY_IMAGE_C        3     // RGB
#define MY_NUM_CLASSES   3

// =======================================================
// MODEL STORAGE (FLOAT32)
// =======================================================

// Conv1: 3x3x3 -> 4 filters
float myConv1_w[108];
float myConv1_b[4];

// Conv2: 3x3x4 -> 8 filters
float myConv2_w[288];
float myConv2_b[8];

// Dense
float myOutput_w[20184];
float myOutput_b[3];

// =======================================================
// SIMPLE TRAINING SAMPLE
// =======================================================

struct myImageSample {
  float *myData;   // normalized RGB float buffer
  int myLabel;
};

// =======================================================
// BINARY CHECKPOINT FORMAT
// =======================================================

struct myBinaryHeader {
  uint32_t myMagic;     // 'MYML'
  uint16_t myVersion;   // format version
  uint16_t myReserved;
};

#define MY_BIN_MAGIC   0x4D594D4C  // 'MYML'
#define MY_BIN_VERSION 1

// =======================================================
// FORWARD DECLARATIONS
// =======================================================

bool  myInitSD();
void  myInitWeights();
bool  myLoadBinaryModel();
bool  mySaveBinaryModel();
void  myExportHeader();
float myTrainSample(myImageSample &mySample);

// =======================================================
// SETUP
// =======================================================

void setup() {
  Serial.begin(115200);
  delay(2000);

  Serial.println();
  Serial.println("==================================");
  Serial.println(" ESP32 ON-DEVICE TRAINING PROGRAM ");
  Serial.println("==================================");

  pinMode(MY_A0_TRIGGER_PIN, INPUT);

  if (!myInitSD()) {
    Serial.println("[FATAL] SD initialization failed");
    while (1);
  }

  if (myLoadBinaryModel()) {
    Serial.println("[INFO] Binary model loaded");
  } else {
    Serial.println("[INFO] No model found â€” initializing weights");
    myInitWeights();
  }

  Serial.println("[READY] Pull A0 HIGH to train");
}

// =======================================================
// LOOP
// =======================================================

void loop() {
  if (digitalRead(MY_A0_TRIGGER_PIN) == HIGH) {
    Serial.println();
    Serial.println("===== TRAINING SESSION START =====");

    // Placeholder sample until real image loader is added
    myImageSample mySample;
    mySample.myData = nullptr;
    mySample.myLabel = 0;

    float myLoss = myTrainSample(mySample);

    Serial.print("Batch Loss: ");
    Serial.println(myLoss, 6);

    mySaveBinaryModel();
    myExportHeader();

    Serial.println("===== TRAINING SESSION END =====");
    delay(2000);
  }
}

// =======================================================
// SD INITIALIZATION (FIXED & SAFE)
// =======================================================

bool myInitSD() {
  if (!SD.begin()) {
    Serial.println("[ERR] SD.begin() failed");
    return false;
  }

  if (!SD.exists(MY_MODEL_FOLDER)) {
    if (!SD.mkdir(MY_MODEL_FOLDER)) {
      Serial.println("[ERR] Failed to create /header folder");
      return false;
    }
  }

  if (!SD.exists(MY_IMAGE_ROOT)) {
    Serial.println("[WARN] /images folder not found");
  }

  return true;
}

// =======================================================
// WEIGHT INITIALIZATION
// =======================================================

void myInitWeights() {
  randomSeed(esp_random());

  for (int i = 0; i < 108; i++) myConv1_w[i] = random(-1000, 1000) / 5000.0f;
  for (int i = 0; i < 4; i++)   myConv1_b[i] = 0.0f;

  for (int i = 0; i < 288; i++) myConv2_w[i] = random(-1000, 1000) / 5000.0f;
  for (int i = 0; i < 8; i++)   myConv2_b[i] = 0.0f;

  for (int i = 0; i < 20184; i++) myOutput_w[i] = random(-1000, 1000) / 5000.0f;
  for (int i = 0; i < 3; i++)     myOutput_b[i] = 0.0f;
}

// =======================================================
// TRAIN SINGLE SAMPLE (STUB)
// =======================================================

float myTrainSample(myImageSample &mySample) {
  // Real forward + backward pass will go here
  // For now this just proves the framework compiles and runs
  return 0.123456f;
}

// =======================================================
// BINARY SAVE / LOAD
// =======================================================

bool mySaveBinaryModel() {
  File myFile = SD.open(MY_MODEL_BIN, FILE_WRITE);
  if (!myFile) {
    Serial.println("[ERR] Cannot write binary model");
    return false;
  }

  myBinaryHeader myHdr;
  myHdr.myMagic = MY_BIN_MAGIC;
  myHdr.myVersion = MY_BIN_VERSION;
  myHdr.myReserved = 0;

  myFile.write((uint8_t*)&myHdr, sizeof(myHdr));
  myFile.write((uint8_t*)myConv1_w, sizeof(myConv1_w));
  myFile.write((uint8_t*)myConv1_b, sizeof(myConv1_b));
  myFile.write((uint8_t*)myConv2_w, sizeof(myConv2_w));
  myFile.write((uint8_t*)myConv2_b, sizeof(myConv2_b));
  myFile.write((uint8_t*)myOutput_w, sizeof(myOutput_w));
  myFile.write((uint8_t*)myOutput_b, sizeof(myOutput_b));

  myFile.close();
  Serial.println("[OK] Binary model saved");
  return true;
}

bool myLoadBinaryModel() {
  if (!SD.exists(MY_MODEL_BIN)) return false;

  File myFile = SD.open(MY_MODEL_BIN, FILE_READ);
  if (!myFile) return false;

  myBinaryHeader myHdr;
  myFile.read((uint8_t*)&myHdr, sizeof(myHdr));

  if (myHdr.myMagic != MY_BIN_MAGIC ||
      myHdr.myVersion != MY_BIN_VERSION) {
    Serial.println("[ERR] Binary model incompatible");
    myFile.close();
    return false;
  }

  myFile.read((uint8_t*)myConv1_w, sizeof(myConv1_w));
  myFile.read((uint8_t*)myConv1_b, sizeof(myConv1_b));
  myFile.read((uint8_t*)myConv2_w, sizeof(myConv2_w));
  myFile.read((uint8_t*)myConv2_b, sizeof(myConv2_b));
  myFile.read((uint8_t*)myOutput_w, sizeof(myOutput_w));
  myFile.read((uint8_t*)myOutput_b, sizeof(myOutput_b));

  myFile.close();
  Serial.println("[OK] Binary model loaded");
  return true;
}

// =======================================================
// HEADER EXPORT (STRING BUG FIXED)
// =======================================================

void myExportHeader() {
  File myFile = SD.open(MY_MODEL_HEADER, FILE_WRITE);
  if (!myFile) {
    Serial.println("[ERR] Cannot write header file");
    return;
  }

  myFile.println("#ifndef MY_MODEL_H");
  myFile.println("#define MY_MODEL_H");
  myFile.println();

  myFile.print("const float myOutput_b[3] = {");
  for (int i = 0; i < 3; i++) {
    myFile.print(myOutput_b[i], 6);
    if (i < 2) myFile.print(",");
  }
  myFile.println("};");
  myFile.println();

  myFile.println("#endif");
  myFile.close();

  Serial.println("[OK] Header file written");
}
