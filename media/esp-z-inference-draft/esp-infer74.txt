/*
 * ESP32-S3 Inference Engine - Complete Version
 * Captures 96x96 -> Scales to 64x64 -> Runs CNN
 */

#include "esp_camera.h"
#include "img_converters.h"
#include "myModel.h" // Generated by trainer

// Camera Pins
#define XCLK_GPIO_NUM 10
#define SIOD_GPIO_NUM 40
#define SIOC_GPIO_NUM 39
#define Y9_GPIO_NUM 48
#define Y8_GPIO_NUM 11
#define Y7_GPIO_NUM 12
#define Y6_GPIO_NUM 14
#define Y5_GPIO_NUM 16
#define Y4_GPIO_NUM 18
#define Y3_GPIO_NUM 17
#define Y2_GPIO_NUM 15
#define VSYNC_GPIO_NUM 38
#define HREF_GPIO_NUM 47
#define PCLK_GPIO_NUM 13

const int myCapSize = 96;
const int myInSize = 64;

// Buffers
float myInput[64 * 64 * 3];
float myConv1Out[62 * 62 * 4];  // 64-3+1 = 62
float myPool1Out[31 * 31 * 4];  // 62/2 = 31
float myConv2Out[29 * 29 * 8];  // 31-3+1 = 29
float myLogits[3]; 

// --- CNN Layer Implementations ---

void myRunConv1() {
    // 64x64x3 -> 62x62x4
    for (int f = 0; f < 4; f++) {
        for (int y = 0; y < 62; y++) {
            for (int x = 0; x < 62; x++) {
                float sum = myB1[f];
                for (int ky = 0; ky < 3; ky++) {
                    for (int kx = 0; kx < 3; kx++) {
                        for (int c = 0; c < 3; c++) {
                            int inIdx = ((y + ky) * 64 + (x + kx)) * 3 + c;
                            sum += myInput[inIdx] * myW1[f][ky][kx][c];
                        }
                    }
                }
                myConv1Out[(y * 62 + x) * 4 + f] = (sum > 0) ? sum : 0; // ReLU
            }
        }
    }
}

void myRunMaxPool() {
    // 62x62x4 -> 31x31x4
    for (int f = 0; f < 4; f++) {
        for (int y = 0; y < 31; y++) {
            for (int x = 0; x < 31; x++) {
                float maxVal = -1e10;
                for (int py = 0; py < 2; py++) {
                    for (int px = 0; px < 2; px++) {
                        float val = myConv1Out[((y * 2 + py) * 62 + (x * 2 + px)) * 4 + f];
                        if (val > maxVal) maxVal = val;
                    }
                }
                myPool1Out[(y * 31 + x) * 4 + f] = maxVal;
            }
        }
    }
}

void myRunConv2() {
    // 31x31x4 -> 29x29x8
    for (int f = 0; f < 8; f++) {
        for (int y = 0; y < 29; y++) {
            for (int x = 0; x < 29; x++) {
                float sum = myB2[f];
                for (int ky = 0; ky < 3; ky++) {
                    for (int kx = 0; kx < 3; kx++) {
                        for (int c = 0; c < 4; c++) {
                            int inIdx = ((y + ky) * 31 + (x + kx)) * 4 + c;
                            sum += myPool1Out[inIdx] * myW2[f][ky][kx][c];
                        }
                    }
                }
                myConv2Out[(y * 29 + x) * 8 + f] = (sum > 0) ? sum : 0; // ReLU
            }
        }
    }
}

void myRunSoftmax() {
    float sumExp = 0;
    float flattened[29 * 29 * 8];
    memcpy(flattened, myConv2Out, sizeof(myConv2Out));

    for (int i = 0; i < 3; i++) {
        float logit = myOutputBias[i];
        for (int j = 0; j < (29 * 29 * 8); j++) {
            logit += flattened[j] * myOutputWeights[i][j];
        }
        myLogits[i] = exp(logit);
        sumExp += myLogits[i];
    }

    for (int i = 0; i < 3; i++) {
        myLogits[i] /= sumExp;
    }
}

// --- Main Inference Loop ---

void myRunInference() {
    camera_fb_t *fb = esp_camera_fb_get();
    if (!fb) {
        Serial.println("Camera capture failed");
        return;
    }

    uint8_t *rgb = (uint8_t *)ps_malloc(fb->width * fb->height * 3);
    if (rgb && fmt2rgb888(fb->buf, fb->len, fb->format, rgb)) {
        
        // Scale 96 to 64
        float s = (float)fb->width / myInSize;
        for (int y = 0; y < myInSize; y++) {
            for (int x = 0; x < myInSize; x++) {
                int si = ((int)(y * s) * fb->width + (int)(x * s)) * 3;
                int di = (y * myInSize + x) * 3;
                myInput[di]   = rgb[si] / 255.0f;
                myInput[di+1] = rgb[si+1] / 255.0f;
                myInput[di+2] = rgb[si+2] / 255.0f;
            }
        }

        // --- Execute CNN Layers ---
        Serial.println("Processing Layers...");
        myRunConv1();
        myRunMaxPool();
        myRunConv2();
        myRunSoftmax();

        int winner = 0;
        for (int i = 1; i < 3; i++) {
            if (myLogits[i] > myLogits[winner]) winner = i;
        }
        
        Serial.printf("Prediction: Class %d (Confidence: %.2f%%)\n", winner, myLogits[winner] * 100.0f);
    }

    if (rgb) free(rgb);
    esp_camera_fb_return(fb);
}

void setup() {
    Serial.begin(115200);

    camera_config_t config;
    config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = Y2_GPIO_NUM;
    config.pin_d1 = Y3_GPIO_NUM;
    config.pin_d2 = Y4_GPIO_NUM;
    config.pin_d3 = Y5_GPIO_NUM;
    config.pin_d4 = Y6_GPIO_NUM;
    config.pin_d5 = Y7_GPIO_NUM;
    config.pin_d6 = Y8_GPIO_NUM;
    config.pin_d7 = Y9_GPIO_NUM;
    config.pin_xclk = XCLK_GPIO_NUM;
    config.pin_pclk = PCLK_GPIO_NUM;
    config.pin_vsync = VSYNC_GPIO_NUM;
    config.pin_href = HREF_GPIO_NUM;
    config.pin_sscb_sda = SIOD_GPIO_NUM;
    config.pin_sscb_scl = SIOC_GPIO_NUM;
    config.pin_pwdn = PWDN_GPIO_NUM;
    config.pin_reset = RESET_GPIO_NUM;
    config.xclk_freq_hz = 20000000;
    config.frame_size = FRAMESIZE_96X96;
    config.pixel_format = PIXFORMAT_JPEG;
    config.grab_mode = CAMERA_GRAB_LATEST;
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.jpeg_quality = 12;
    config.fb_count = 1;

    esp_err_t err = esp_camera_init(&config);
    if (err != ESP_OK) {
        Serial.printf("Camera init failed with error 0x%x", err);
        return;
    }
}

void loop() {
    myRunInference();
    delay(1000);
}
