// ======================================================
// XIAO ML KIT (OR XIAO ESP32S3 SENSE)
// FULL VISION ML
// Small Image collection, training, inference for education and proof of concept
//
// SD card stores: images in class folders
// SD card stores: weights in /header/myWeights.bin  (ASCII JSON header + float32 binary)
// Serial monitor and OLED output
// By jeremy Ellis
// Use at your own risk!
// MIT license
// Github Profile https://github.com/hpssjellis
// LinkedIn https://www.linkedin.com/in/jeremy-ellis-4237a9bb/
//
// For platformio you need the U8g2 and ArduinoJson libraries and OPI PSRAM set:
// lib_deps =
//   olikraus/U8g2 @ ^2.35.30
//   bblanchon/ArduinoJson @ ^7.3.1
// build_flags =
//   -DBOARD_HAS_PSRAM
//   -DARDUINO_USB_CDC_ON_BOOT=1
// board_build.arduino.memory_type = qio_opi
// board_build.flash_mode = qio
// board_upload.flash_size = 8MB
//
// Arduino IDE (Tools menu):
//   Board          : XIAO_ESP32S3  (or "Seeed Studio XIAO ESP32S3 Sense")
//   PSRAM          : OPI PSRAM
//   USB CDC On Boot: Enabled
//   Flash Size     : 8MB (64Mb)
//   Flash Mode     : QIO 80MHz
//
// Libraries required (Sketch → Include Library → Manage Libraries):
//   U8g2         by olikraus
//   ArduinoJson  by Benoit Blanchon  >= 7.x
//
// .bin file format:
//   --- WEIGHTS HEADER BEGIN ---
//   { "inputSize":64, "numClasses":3, "conv1Filters":4, "conv2Filters":8,
//     "quantization":"float32", "labels":["0Blank","1Circle","2Square"] }
//   --- WEIGHTS HEADER END ---
//   <blank line>
//   <raw float32 binary: conv1_w, conv1_b, conv2_w, conv2_b, output_w, output_b>
// ======================================================


// ██████████████████████████████████████████████████████████████████████████████
// ██                                                                          ██
// ██  PART 0: CORE SYSTEM                                                     ██
// ██  Includes, Config, Globals, Touch, Setup, Loop                           ██
// ██                                                                          ██
// ██████████████████████████████████████████████████████████████████████████████

#include "esp_camera.h"
#include "img_converters.h"
#include "FS.h"
#include "SD.h"
#include "SPI.h"
#include <vector>
#include <U8g2lib.h>
#include <Wire.h>
#include <ArduinoJson.h>

U8G2_SSD1306_72X40_ER_1_HW_I2C u8g2(U8G2_R2, U8X8_PIN_NONE);

// ======================================================
// COMPILED-IN DEFAULTS
// Used when /header/config.json is absent or a key missing.
// Written out as config.json on first boot.
// ======================================================
#define DEFAULT_INPUT_SIZE       64
#define DEFAULT_NUM_CLASSES       3
#define DEFAULT_CONV1_FILTERS     4
#define DEFAULT_CONV2_FILTERS     8
#define DEFAULT_LEARNING_RATE     0.0003f
#define DEFAULT_BATCH_SIZE       12
#define DEFAULT_TARGET_EPOCHS    10
#define DEFAULT_THRESHOLD_PRESS  1100
#define DEFAULT_THRESHOLD_RELEASE 900
#define DEFAULT_SCREEN_TIMEOUT   300000UL   // 5 minutes in ms
#define DEFAULT_WEIGHTS_FILE     "myWeights.bin"
#define DEFAULT_NUM_LABELS        3
const char* DEFAULT_LABELS[] = { "0Blank", "1Circle", "2Square" };

// ======================================================
// RUNTIME CONFIG STRUCT
// ======================================================
struct MyConfig {
  int   inputSize;
  int   numClasses;
  int   conv1Filters;
  int   conv2Filters;

  // Derived (computed by myComputeArchSizes)
  int   conv1OutputSize;
  int   pool1OutputSize;
  int   conv2OutputSize;
  int   flattenedSize;
  int   conv1Weights;
  int   conv2Weights;
  int   outputWeights;

  float learningRate;
  int   batchSize;
  int   targetEpochs;

  int           thresholdPress;
  int           thresholdRelease;
  unsigned long screenTimeout;

  int    numLabels;
  String classLabels[8];

  String weightsFile;
};

MyConfig myCfg;

void myComputeArchSizes() {
  myCfg.conv1OutputSize = myCfg.inputSize - 2;
  myCfg.pool1OutputSize = myCfg.conv1OutputSize / 2;
  myCfg.conv2OutputSize = myCfg.pool1OutputSize - 2;
  myCfg.flattenedSize   = myCfg.conv2OutputSize * myCfg.conv2OutputSize * myCfg.conv2Filters;
  myCfg.conv1Weights    = 3 * 3 * 3 * myCfg.conv1Filters;
  myCfg.conv2Weights    = 3 * 3 * myCfg.conv1Filters * myCfg.conv2Filters;
  myCfg.outputWeights   = myCfg.flattenedSize * myCfg.numClasses;
}

void myApplyDefaultConfig() {
  myCfg.inputSize        = DEFAULT_INPUT_SIZE;
  myCfg.numClasses       = DEFAULT_NUM_CLASSES;
  myCfg.conv1Filters     = DEFAULT_CONV1_FILTERS;
  myCfg.conv2Filters     = DEFAULT_CONV2_FILTERS;
  myCfg.learningRate     = DEFAULT_LEARNING_RATE;
  myCfg.batchSize        = DEFAULT_BATCH_SIZE;
  myCfg.targetEpochs     = DEFAULT_TARGET_EPOCHS;
  myCfg.thresholdPress   = DEFAULT_THRESHOLD_PRESS;
  myCfg.thresholdRelease = DEFAULT_THRESHOLD_RELEASE;
  myCfg.screenTimeout    = DEFAULT_SCREEN_TIMEOUT;
  myCfg.weightsFile      = DEFAULT_WEIGHTS_FILE;
  myCfg.numLabels        = DEFAULT_NUM_LABELS;
  for (int i = 0; i < DEFAULT_NUM_LABELS; i++)
    myCfg.classLabels[i] = String(DEFAULT_LABELS[i]);
  myComputeArchSizes();
}

void mySaveConfig() {
  if (!SD.exists("/header")) SD.mkdir("/header");
  File f = SD.open("/header/config.json", FILE_WRITE);
  if (!f) { Serial.println("[config] ERROR: could not write config.json"); return; }
  JsonDocument doc;
  doc["inputSize"]        = myCfg.inputSize;
  doc["numClasses"]       = myCfg.numClasses;
  doc["conv1Filters"]     = myCfg.conv1Filters;
  doc["conv2Filters"]     = myCfg.conv2Filters;
  doc["learningRate"]     = myCfg.learningRate;
  doc["batchSize"]        = myCfg.batchSize;
  doc["targetEpochs"]     = myCfg.targetEpochs;
  doc["thresholdPress"]   = myCfg.thresholdPress;
  doc["thresholdRelease"] = myCfg.thresholdRelease;
  doc["screenTimeout"]    = (unsigned long)myCfg.screenTimeout;
  doc["weightsFile"]      = myCfg.weightsFile;
  JsonArray labels = doc["classLabels"].to<JsonArray>();
  for (int i = 0; i < myCfg.numLabels; i++) labels.add(myCfg.classLabels[i]);
  serializeJsonPretty(doc, f);
  f.close();
  Serial.println("[config] Wrote default config to /header/config.json");
}

void myLoadConfig() {
  myApplyDefaultConfig();
  const char* path = "/header/config.json";
  if (!SD.exists(path)) {
    Serial.println("[config] config.json not found — using defaults");
    mySaveConfig();
    return;
  }
  File f = SD.open(path, FILE_READ);
  if (!f) { Serial.println("[config] ERROR: could not open config.json"); return; }
  JsonDocument doc;
  DeserializationError err = deserializeJson(doc, f);
  f.close();
  if (err) {
    Serial.printf("[config] JSON parse error: %s — using defaults\n", err.c_str());
    return;
  }
  myCfg.inputSize        = doc["inputSize"]        | DEFAULT_INPUT_SIZE;
  myCfg.numClasses       = doc["numClasses"]       | DEFAULT_NUM_CLASSES;
  myCfg.conv1Filters     = doc["conv1Filters"]     | DEFAULT_CONV1_FILTERS;
  myCfg.conv2Filters     = doc["conv2Filters"]     | DEFAULT_CONV2_FILTERS;
  myCfg.learningRate     = doc["learningRate"]      | DEFAULT_LEARNING_RATE;
  myCfg.batchSize        = doc["batchSize"]        | DEFAULT_BATCH_SIZE;
  myCfg.targetEpochs     = doc["targetEpochs"]     | DEFAULT_TARGET_EPOCHS;
  myCfg.thresholdPress   = doc["thresholdPress"]   | DEFAULT_THRESHOLD_PRESS;
  myCfg.thresholdRelease = doc["thresholdRelease"] | DEFAULT_THRESHOLD_RELEASE;
  myCfg.screenTimeout    = doc["screenTimeout"]    | (int)DEFAULT_SCREEN_TIMEOUT;
  myCfg.weightsFile      = doc["weightsFile"]      | DEFAULT_WEIGHTS_FILE;
  if (doc["classLabels"].is<JsonArray>()) {
    JsonArray arr = doc["classLabels"].as<JsonArray>();
    int count = 0;
    for (JsonVariant v : arr) {
      if (count >= 8) break;
      myCfg.classLabels[count++] = v.as<String>();
    }
    if (count > 0) { myCfg.numLabels = count; myCfg.numClasses = count; }
  }
  myComputeArchSizes();
  Serial.println("[config] Loaded /header/config.json:");
  Serial.printf("  inputSize=%d  numClasses=%d  conv1F=%d  conv2F=%d\n",
                myCfg.inputSize, myCfg.numClasses, myCfg.conv1Filters, myCfg.conv2Filters);
  Serial.printf("  flattenedSize=%d  outputWeights=%d\n",
                myCfg.flattenedSize, myCfg.outputWeights);
  Serial.printf("  learningRate=%.5f  batchSize=%d  targetEpochs=%d\n",
                myCfg.learningRate, myCfg.batchSize, myCfg.targetEpochs);
  Serial.printf("  weightsFile=%s\n", myCfg.weightsFile.c_str());
  Serial.print ("  classLabels=");
  for (int i = 0; i < myCfg.numLabels; i++) {
    Serial.print(myCfg.classLabels[i]);
    if (i < myCfg.numLabels - 1) Serial.print(", ");
  }
  Serial.println();
}

// ======================================================
// LEGACY SHIM — keeps myClassLabels[] working in Parts 1-4
// ======================================================
String myClassLabels[8];

void mySyncLegacyVars() {
  for (int i = 0; i < myCfg.numLabels; i++)
    myClassLabels[i] = myCfg.classLabels[i];
}

#define LEARNING_RATE     (myCfg.learningRate)
#define BATCH_SIZE        (myCfg.batchSize)
#define TARGET_EPOCHS     (myCfg.targetEpochs)
#define NUM_CLASSES       (myCfg.numClasses)
#define INPUT_SIZE        (myCfg.inputSize)
#define CONV1_FILTERS     (myCfg.conv1Filters)
#define CONV2_FILTERS     (myCfg.conv2Filters)
#define CONV1_WEIGHTS     (myCfg.conv1Weights)
#define CONV2_WEIGHTS     (myCfg.conv2Weights)
#define FLATTENED_SIZE    (myCfg.flattenedSize)
#define OUTPUT_WEIGHTS    (myCfg.outputWeights)
#define CONV1_OUTPUT_SIZE (myCfg.conv1OutputSize)
#define POOL1_OUTPUT_SIZE (myCfg.pool1OutputSize)
#define CONV2_OUTPUT_SIZE (myCfg.conv2OutputSize)

// ======================================================
// UI PARAMETERS
// ======================================================
const int myTotalItems = 5;
#define myThresholdPress   (myCfg.thresholdPress)
#define myThresholdRelease (myCfg.thresholdRelease)
#define myScreenTimeout    (myCfg.screenTimeout)

// ======================================================
// UNIFIED TOUCH INPUT SYSTEM
// ======================================================
struct TouchState {
  bool isTouching               = false;
  int  tapCount                 = 0;
  unsigned long firstTapTime    = 0;
  unsigned long lastReleaseTime = 0;
  unsigned long lastCheckTime   = 0;
  const unsigned long tapWindow    = 800;
  const int           longPressTaps = 3;
  const unsigned long debounceDelay = 50;
};
TouchState myTouch;

unsigned long myLastActivityTime = 0;
unsigned long myLastTapTime      = 0;
const int     myTapCooldown      = 250;
int           myMenuIndex        = 1;
bool          myIsSelected       = false;

// ======================================================
// XIAO ESP32-S3 CAMERA PINS
// ======================================================
#define PWDN_GPIO_NUM   -1
#define RESET_GPIO_NUM  -1
#define XCLK_GPIO_NUM   10
#define SIOD_GPIO_NUM   40
#define SIOC_GPIO_NUM   39
#define Y9_GPIO_NUM     48
#define Y8_GPIO_NUM     11
#define Y7_GPIO_NUM     12
#define Y6_GPIO_NUM     14
#define Y5_GPIO_NUM     16
#define Y4_GPIO_NUM     18
#define Y3_GPIO_NUM     17
#define Y2_GPIO_NUM     15
#define VSYNC_GPIO_NUM  38
#define HREF_GPIO_NUM   47
#define PCLK_GPIO_NUM   13

// ======================================================
// GLOBAL ML BUFFERS  (all PSRAM, allocated after config)
// ======================================================
uint8_t* myRgbBuffer   = nullptr;
float* myInputBuffer   = nullptr;
float* myConv1_w       = nullptr;
float* myConv1_b       = nullptr;
float* myConv2_w       = nullptr;
float* myConv2_b       = nullptr;
float* myOutput_w      = nullptr;
float* myOutput_b      = nullptr;
float* myConv1_w_grad  = nullptr;
float* myConv1_b_grad  = nullptr;
float* myConv2_w_grad  = nullptr;
float* myConv2_b_grad  = nullptr;
float* myOutput_w_grad = nullptr;
float* myOutput_b_grad = nullptr;
float* myConv1_w_m     = nullptr;
float* myConv1_w_v     = nullptr;
float* myConv1_b_m     = nullptr;
float* myConv1_b_v     = nullptr;
float* myConv2_w_m     = nullptr;
float* myConv2_w_v     = nullptr;
float* myConv2_b_m     = nullptr;
float* myConv2_b_v     = nullptr;
float* myOutput_w_m    = nullptr;
float* myOutput_w_v    = nullptr;
float* myOutput_b_m    = nullptr;
float* myOutput_b_v    = nullptr;
float* myConv1_output  = nullptr;
float* myPool1_output  = nullptr;
float* myConv2_output  = nullptr;
float* myDense_output  = nullptr;
float* myDense_grad    = nullptr;
float* myConv2_grad    = nullptr;
float* myPool1_grad    = nullptr;
float* myConv1_grad    = nullptr;

struct TrainingItem { String path; int label; };
std::vector<TrainingItem> myTrainingData;

// ======================================================
// UTILITY FUNCTIONS
// ======================================================
inline float clip_value(float v, float mn = -100, float mx = 100) {
  if (isnan(v) || isinf(v)) return 0;
  return constrain(v, mn, mx);
}
inline float leaky_relu(float x)       { return x > 0 ? x : 0.1f * x; }
inline float leaky_relu_deriv(float x) { return x > 0 ? 1.0f : 0.1f; }

// ======================================================
// TOUCH FUNCTIONS
// ======================================================
int myReadTouch() {
  int sum = 0;
  for (int i = 0; i < 3; i++) { sum += analogRead(A0); delayMicroseconds(100); }
  return sum / 3;
}

void myResetTouchState() {
  myTouch.isTouching = false;
  myTouch.tapCount   = 0;
  myTouch.firstTapTime = myTouch.lastReleaseTime = myTouch.lastCheckTime = 0;
}

void myUpdateTouchState() {
  unsigned long now = millis();
  if (now - myTouch.lastCheckTime < 20) return;
  myTouch.lastCheckTime = now;
  int val = myReadTouch();
  bool touchActive = myTouch.isTouching ? (val > myThresholdRelease) : (val > myThresholdPress);
  if (touchActive && !myTouch.isTouching) {
    if (now - myTouch.lastReleaseTime < myTouch.debounceDelay) return;
    myTouch.isTouching = true;
    if (myTouch.tapCount == 0 || (now - myTouch.firstTapTime < myTouch.tapWindow)) {
      if (myTouch.tapCount == 0) myTouch.firstTapTime = now;
      myTouch.tapCount++;
      Serial.printf("Tap #%d\n", myTouch.tapCount);
    } else {
      myTouch.tapCount = 1;
      myTouch.firstTapTime = now;
      Serial.println("Tap #1 (new window)");
    }
  }
  if (!touchActive && myTouch.isTouching) {
    myTouch.isTouching = false;
    myTouch.lastReleaseTime = now;
  }
}

int myCheckTouchInput() {
  myUpdateTouchState();
  unsigned long now = millis();
  if (myTouch.tapCount > 0 && !myTouch.isTouching) {
    if (now - myTouch.firstTapTime > myTouch.tapWindow) {
      int result = (myTouch.tapCount >= myTouch.longPressTaps) ? 2 : 1;
      int count  = myTouch.tapCount;
      myResetTouchState();
      Serial.printf(result == 2 ? "LONG PRESS (%d taps)\n" : "TAP (%d tap%s)\n",
                    count, count > 1 ? "s" : "");
      return result;
    }
  }
  return 0;
}

void myCheckTouchBackground() { myUpdateTouchState(); }

int myPeekTouchAction() {
  myUpdateTouchState();
  unsigned long now = millis();
  if (myTouch.tapCount > 0 && !myTouch.isTouching)
    if (now - myTouch.firstTapTime > myTouch.tapWindow)
      return (myTouch.tapCount >= myTouch.longPressTaps) ? 2 : 1;
  return 0;
}

// ======================================================
// FORWARD DECLARATIONS
// ======================================================
void myActionCollect(int classIdx);
void myActionTrain();
void myActionInfer();
void myResetMenuState();
void myHandleMenuNavigation();
void myDrawMenu();
bool myLoadWeights(bool resetMoments = true);

// ======================================================
// SETUP
// ======================================================
void setup() {
  Serial.begin(115200);
  while (!Serial && millis() < 3000);
  delay(1000);
  Serial.println("\n=== XIAO ESP32-S3 ML System Starting ===");
  Serial.printf("Free heap:  %d bytes\n", ESP.getFreeHeap());
  Serial.printf("Free PSRAM: %d bytes\n", ESP.getFreePsram());

  pinMode(A0, INPUT);
  u8g2.begin();

  if (!SD.begin(21)) {
    Serial.println("SD card initialization failed");
    u8g2.firstPage();
    do { u8g2.drawStr(0, 15, "SD CARD ERROR!"); } while (u8g2.nextPage());
    while (1) { delay(1000); }
  }
  Serial.println("SD card mounted");

  myLoadConfig();
  mySyncLegacyVars();

  // Shared RGB decode buffer (always 240x240 from camera)
  myRgbBuffer = (uint8_t*)ps_malloc(240 * 240 * 3);
  if (!myRgbBuffer) Serial.println("WARNING: RGB buffer alloc failed!");

  // Camera
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;  config.pin_pclk  = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;  config.pin_href  = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_240X240;
  config.jpeg_quality = 12;
  config.fb_count     = 1;
  esp_camera_init(&config);
  Serial.println("Camera initialized");

  myLastActivityTime = millis();
  myResetMenuState();
  delay(2000);
  Serial.println("System ready — Tap A0 to navigate, 3+ taps to select");
  myDrawMenu();
}

void loop() {
  myHandleMenuNavigation();
}


// ██████████████████████████████████████████████████████████████████████████████
// ██                                                                          ██
// ██  CORE ML FUNCTIONS                                                       ██
// ██  myAllocateMemory, mySaveWeights, myLoadWeights, myLoadImageFromFile     ██
// ██                                                                          ██
// ██████████████████████████████████████████████████████████████████████████████

// -------------------------------------------------------
// Allocate (or reallocate) all ML buffers in PSRAM.
// Always frees existing allocations before allocating
// to prevent PSRAM leaks on repeated training sessions.
//
// resetMoments = true  → zero + reallocate all 12 Adam moment buffers
// resetMoments = false → leave moment buffers untouched (warm Adam resume)
// -------------------------------------------------------
void myAllocateMemory(bool resetMoments = true) {

  #define MY_REALLOC(ptr, size) \
    do { if (ptr) { free(ptr); ptr = nullptr; } \
         ptr = (float*)ps_malloc(size); } while(0)

  // Weight buffers
  MY_REALLOC(myConv1_w,       CONV1_WEIGHTS  * sizeof(float));
  MY_REALLOC(myConv1_b,       CONV1_FILTERS  * sizeof(float));
  MY_REALLOC(myConv2_w,       CONV2_WEIGHTS  * sizeof(float));
  MY_REALLOC(myConv2_b,       CONV2_FILTERS  * sizeof(float));
  MY_REALLOC(myOutput_w,      OUTPUT_WEIGHTS * sizeof(float));
  MY_REALLOC(myOutput_b,      NUM_CLASSES    * sizeof(float));

  // Gradient buffers
  MY_REALLOC(myConv1_w_grad,  CONV1_WEIGHTS  * sizeof(float));
  MY_REALLOC(myConv1_b_grad,  CONV1_FILTERS  * sizeof(float));
  MY_REALLOC(myConv2_w_grad,  CONV2_WEIGHTS  * sizeof(float));
  MY_REALLOC(myConv2_b_grad,  CONV2_FILTERS  * sizeof(float));
  MY_REALLOC(myOutput_w_grad, OUTPUT_WEIGHTS * sizeof(float));
  MY_REALLOC(myOutput_b_grad, NUM_CLASSES    * sizeof(float));

  // Activation / intermediate buffers
  MY_REALLOC(myConv1_output,  CONV1_OUTPUT_SIZE * CONV1_OUTPUT_SIZE * CONV1_FILTERS * sizeof(float));
  MY_REALLOC(myPool1_output,  POOL1_OUTPUT_SIZE * POOL1_OUTPUT_SIZE * CONV1_FILTERS * sizeof(float));
  MY_REALLOC(myConv2_output,  CONV2_OUTPUT_SIZE * CONV2_OUTPUT_SIZE * CONV2_FILTERS * sizeof(float));
  MY_REALLOC(myDense_output,  NUM_CLASSES * sizeof(float));
  MY_REALLOC(myDense_grad,    FLATTENED_SIZE * sizeof(float));
  MY_REALLOC(myConv2_grad,    CONV2_OUTPUT_SIZE * CONV2_OUTPUT_SIZE * CONV2_FILTERS * sizeof(float));
  MY_REALLOC(myPool1_grad,    POOL1_OUTPUT_SIZE * POOL1_OUTPUT_SIZE * CONV1_FILTERS * sizeof(float));
  MY_REALLOC(myConv1_grad,    CONV1_OUTPUT_SIZE * CONV1_OUTPUT_SIZE * CONV1_FILTERS * sizeof(float));
  MY_REALLOC(myInputBuffer,   INPUT_SIZE * INPUT_SIZE * 3 * sizeof(float));

  #undef MY_REALLOC

  // Adam moment buffers — only reset when requested
  if (resetMoments) {
    #define MY_REALLOC_ZERO(ptr, size) \
      do { if (ptr) { free(ptr); ptr = nullptr; } \
           ptr = (float*)ps_malloc(size); \
           if (ptr) memset(ptr, 0, size); } while(0)

    MY_REALLOC_ZERO(myConv1_w_m,  CONV1_WEIGHTS  * sizeof(float));
    MY_REALLOC_ZERO(myConv1_w_v,  CONV1_WEIGHTS  * sizeof(float));
    MY_REALLOC_ZERO(myConv1_b_m,  CONV1_FILTERS  * sizeof(float));
    MY_REALLOC_ZERO(myConv1_b_v,  CONV1_FILTERS  * sizeof(float));
    MY_REALLOC_ZERO(myConv2_w_m,  CONV2_WEIGHTS  * sizeof(float));
    MY_REALLOC_ZERO(myConv2_w_v,  CONV2_WEIGHTS  * sizeof(float));
    MY_REALLOC_ZERO(myConv2_b_m,  CONV2_FILTERS  * sizeof(float));
    MY_REALLOC_ZERO(myConv2_b_v,  CONV2_FILTERS  * sizeof(float));
    MY_REALLOC_ZERO(myOutput_w_m, OUTPUT_WEIGHTS * sizeof(float));
    MY_REALLOC_ZERO(myOutput_w_v, OUTPUT_WEIGHTS * sizeof(float));
    MY_REALLOC_ZERO(myOutput_b_m, NUM_CLASSES    * sizeof(float));
    MY_REALLOC_ZERO(myOutput_b_v, NUM_CLASSES    * sizeof(float));

    #undef MY_REALLOC_ZERO
    Serial.println("[mem] Adam moments reset (cold start)");
  } else {
    Serial.println("[mem] Adam moments preserved (warm resume)");
  }

  // Always zero gradient and activation buffers
  if (myConv1_w_grad)  memset(myConv1_w_grad,  0, CONV1_WEIGHTS  * sizeof(float));
  if (myConv1_b_grad)  memset(myConv1_b_grad,  0, CONV1_FILTERS  * sizeof(float));
  if (myConv2_w_grad)  memset(myConv2_w_grad,  0, CONV2_WEIGHTS  * sizeof(float));
  if (myConv2_b_grad)  memset(myConv2_b_grad,  0, CONV2_FILTERS  * sizeof(float));
  if (myOutput_w_grad) memset(myOutput_w_grad,  0, OUTPUT_WEIGHTS * sizeof(float));
  if (myOutput_b_grad) memset(myOutput_b_grad,  0, NUM_CLASSES    * sizeof(float));

  // Randomise weights (overwritten immediately when loading from file)
  if (myConv1_w)  for (int i = 0; i < CONV1_WEIGHTS;  i++) myConv1_w[i]  = ((float)random(-1000,1000)) / 100000.0f;
  if (myConv2_w)  for (int i = 0; i < CONV2_WEIGHTS;  i++) myConv2_w[i]  = ((float)random(-1000,1000)) / 100000.0f;
  if (myOutput_w) for (int i = 0; i < OUTPUT_WEIGHTS;  i++) myOutput_w[i] = ((float)random(-1000,1000)) / 100000.0f;
  if (myConv1_b)  memset(myConv1_b,  0, CONV1_FILTERS * sizeof(float));
  if (myConv2_b)  memset(myConv2_b,  0, CONV2_FILTERS * sizeof(float));
  if (myOutput_b) memset(myOutput_b, 0, NUM_CLASSES   * sizeof(float));

  Serial.printf("[mem] Alloc done. Free PSRAM: %d bytes\n", ESP.getFreePsram());
}

// -------------------------------------------------------
// Save weights to SD with ASCII JSON header block
// -------------------------------------------------------
void mySaveWeights() {
  String filePath = "/header/" + myCfg.weightsFile;
  if (!SD.exists("/header")) SD.mkdir("/header");
  File f = SD.open(filePath.c_str(), FILE_WRITE);
  if (!f) { Serial.println("[weights] ERROR: could not open file for writing"); return; }

  f.println("--- WEIGHTS HEADER BEGIN ---");

  JsonDocument doc;
  doc["inputSize"]    = myCfg.inputSize;
  doc["numClasses"]   = myCfg.numClasses;
  doc["conv1Filters"] = myCfg.conv1Filters;
  doc["conv2Filters"] = myCfg.conv2Filters;
  doc["quantization"] = "float32";
  JsonArray labels = doc["labels"].to<JsonArray>();
  for (int i = 0; i < myCfg.numLabels; i++) labels.add(myCfg.classLabels[i]);

  serializeJsonPretty(doc, f);
  f.println();
  f.println("--- WEIGHTS HEADER END ---");
  f.println();   // blank line before binary payload

  f.write((uint8_t*)myConv1_w,  CONV1_WEIGHTS  * sizeof(float));
  f.write((uint8_t*)myConv1_b,  CONV1_FILTERS  * sizeof(float));
  f.write((uint8_t*)myConv2_w,  CONV2_WEIGHTS  * sizeof(float));
  f.write((uint8_t*)myConv2_b,  CONV2_FILTERS  * sizeof(float));
  f.write((uint8_t*)myOutput_w, OUTPUT_WEIGHTS * sizeof(float));
  f.write((uint8_t*)myOutput_b, NUM_CLASSES    * sizeof(float));
  f.close();
  Serial.printf("[weights] Saved to %s\n", filePath.c_str());
}

// -------------------------------------------------------
// Load weights from SD — parses ASCII JSON header first.
// resetMoments passed through to myAllocateMemory().
// Returns true on success.
// -------------------------------------------------------
bool myLoadWeights(bool resetMoments) {
  String filePath = "/header/" + myCfg.weightsFile;
  if (!SD.exists(filePath.c_str())) {
    Serial.printf("[weights] File not found: %s\n", filePath.c_str());
    return false;
  }
  File f = SD.open(filePath.c_str(), FILE_READ);
  if (!f) { Serial.println("[weights] ERROR: could not open file"); return false; }

  const char* BEGIN_TAG = "--- WEIGHTS HEADER BEGIN ---";
  const char* END_TAG   = "--- WEIGHTS HEADER END ---";

  // Scan for BEGIN sentinel
  bool foundBegin = false;
  while (f.available()) {
    String line = f.readStringUntil('\n'); line.trim();
    if (line == BEGIN_TAG) { foundBegin = true; break; }
  }
  if (!foundBegin) {
    Serial.println("[weights] ERROR: BEGIN sentinel not found — old format or corrupt file");
    f.close(); return false;
  }

  // Accumulate JSON until END sentinel
  String jsonStr = "";
  bool foundEnd = false;
  while (f.available()) {
    String line = f.readStringUntil('\n'); line.trim();
    if (line == END_TAG) { foundEnd = true; break; }
    jsonStr += line;
  }
  if (!foundEnd) {
    Serial.println("[weights] ERROR: END sentinel not found — truncated file?");
    f.close(); return false;
  }

  // Consume blank separator line
  if (f.available()) f.readStringUntil('\n');

  // Parse JSON header
  JsonDocument doc;
  DeserializationError err = deserializeJson(doc, jsonStr);
  if (err) {
    Serial.printf("[weights] JSON parse error: %s\n", err.c_str());
    f.close(); return false;
  }

  // Check quantization
  String quant = doc["quantization"] | "float32";
  if (quant != "float32") {
    Serial.printf("[weights] Quantization is '%s'.\n", quant.c_str());
    Serial.println("[weights] Cannot train on int8 weights. Int8 inference path coming in Step 2.");
    f.close(); return false;
  }

  // Validate architecture
  int hInputSize  = doc["inputSize"]    | 0;
  int hNumClasses = doc["numClasses"]   | 0;
  int hConv1F     = doc["conv1Filters"] | 0;
  int hConv2F     = doc["conv2Filters"] | 0;
  if (hInputSize  != myCfg.inputSize    ||
      hNumClasses != myCfg.numClasses   ||
      hConv1F     != myCfg.conv1Filters ||
      hConv2F     != myCfg.conv2Filters) {
    Serial.println("[weights] Architecture mismatch!");
    Serial.printf("  File  : inputSize=%d numClasses=%d conv1F=%d conv2F=%d\n",
                  hInputSize, hNumClasses, hConv1F, hConv2F);
    Serial.printf("  Config: inputSize=%d numClasses=%d conv1F=%d conv2F=%d\n",
                  myCfg.inputSize, myCfg.numClasses, myCfg.conv1Filters, myCfg.conv2Filters);
    f.close(); return false;
  }

  // Allocate buffers
  myAllocateMemory(resetMoments);

  // Read binary payload
  f.read((uint8_t*)myConv1_w,  CONV1_WEIGHTS  * sizeof(float));
  f.read((uint8_t*)myConv1_b,  CONV1_FILTERS  * sizeof(float));
  f.read((uint8_t*)myConv2_w,  CONV2_WEIGHTS  * sizeof(float));
  f.read((uint8_t*)myConv2_b,  CONV2_FILTERS  * sizeof(float));
  f.read((uint8_t*)myOutput_w, OUTPUT_WEIGHTS * sizeof(float));
  f.read((uint8_t*)myOutput_b, NUM_CLASSES    * sizeof(float));
  f.close();

  Serial.printf("[weights] Loaded float32 from %s\n", filePath.c_str());
  return true;
}

// -------------------------------------------------------
// Load a JPEG from SD, decode, resize to INPUT_SIZE,
// normalise to [0,1], store in buf (float RGB interleaved).
// -------------------------------------------------------
bool myLoadImageFromFile(const char* path, float* buf) {
  File f = SD.open(path, FILE_READ);
  if (!f) { Serial.printf("[img] Cannot open: %s\n", path); return false; }
  size_t jpgLen = f.size();
  uint8_t* jpgBuf = (uint8_t*)ps_malloc(jpgLen);
  if (!jpgBuf) { Serial.println("[img] ps_malloc failed for JPEG"); f.close(); return false; }
  f.read(jpgBuf, jpgLen);
  f.close();

  const int MAX_DIM = 240;
  uint8_t* rgbBuf = (uint8_t*)ps_malloc(MAX_DIM * MAX_DIM * 3);
  if (!rgbBuf) { Serial.println("[img] ps_malloc failed for RGB"); free(jpgBuf); return false; }

  bool ok = fmt2rgb888(jpgBuf, jpgLen, PIXFORMAT_JPEG, rgbBuf);
  free(jpgBuf);
  if (!ok) { Serial.printf("[img] JPEG decode failed: %s\n", path); free(rgbBuf); return false; }

  int inSize = myCfg.inputSize;
  for (int y = 0; y < inSize; y++) {
    int sy = min((int)((y + 0.5f) * MAX_DIM / inSize), MAX_DIM - 1);
    for (int x = 0; x < inSize; x++) {
      int sx     = min((int)((x + 0.5f) * MAX_DIM / inSize), MAX_DIM - 1);
      int srcIdx = (sy * MAX_DIM + sx) * 3;
      int dstIdx = (y  * inSize  + x ) * 3;
      buf[dstIdx]   = rgbBuf[srcIdx]   * 0.003921569f;
      buf[dstIdx+1] = rgbBuf[srcIdx+1] * 0.003921569f;
      buf[dstIdx+2] = rgbBuf[srcIdx+2] * 0.003921569f;
    }
  }
  free(rgbBuf);
  return true;
}


// ██████████████████████████████████████████████████████████████████████████████
// ██                                                                          ██
// ██  PART 1: IMAGE COLLECTION                                                ██
// ██                                                                          ██
// ██████████████████████████████████████████████████████████████████████████████

// -------------------------------------------------------
// Draw the camera image onto the OLED (downsampled).
// Overlays a small count number in the top-left corner.
// -------------------------------------------------------
void myDisplayImageOnOLED(camera_fb_t* fb, int imageCount) {
  size_t myRgbBufSize = fb->width * fb->height * 3;
  uint8_t* buf = (uint8_t*)ps_malloc(myRgbBufSize);
  if (!buf) { Serial.println("OLED: alloc failed"); return; }
  if (!fmt2rgb888(fb->buf, fb->len, fb->format, buf)) {
    free(buf); Serial.println("OLED: JPEG convert failed"); return;
  }

  int oW = u8g2.getDisplayWidth();
  int oH = u8g2.getDisplayHeight();
  int scX = fb->width  / oW;
  int scY = fb->height / oH;

  u8g2.firstPage();
  do {
    for (int ox = 0; ox < oW; ox++) {
      for (int oy = 0; oy < oH; oy++) {
        size_t pi = ((oy * scY) * fb->width + (ox * scX)) * 3;
        if (pi + 2 < myRgbBufSize) {
          uint8_t bright = (buf[pi] + buf[pi+1] + buf[pi+2]) / 3;
          if (bright > 100) u8g2.drawPixel(ox, oy);
        }
      }
    }
    // Count overlay
    u8g2.setFont(u8g2_font_ncenB10_tr);
    u8g2.setColorIndex(0); u8g2.drawBox(0, 0, 20, 15);
    u8g2.setColorIndex(1); u8g2.setCursor(3, 10);
    u8g2.print(String(imageCount));
  } while (u8g2.nextPage());

  free(buf);
}

// -------------------------------------------------------
// Show live camera preview on OLED.
// Used during image collection and inference.
// Optionally overlays a short label string (pass nullptr for none).
// -------------------------------------------------------
void myDisplayLiveCameraOnOLED(camera_fb_t* fb, const char* overlayLabel = nullptr) {
  if (!fb) return;
  size_t myRgbBufSize = fb->width * fb->height * 3;
  uint8_t* buf = (uint8_t*)ps_malloc(myRgbBufSize);
  if (!buf) return;

  if (fmt2rgb888(fb->buf, fb->len, fb->format, buf)) {
    int oW  = u8g2.getDisplayWidth();
    int oH  = u8g2.getDisplayHeight();
    int scX = fb->width  / oW;
    int scY = fb->height / oH;

    u8g2.firstPage();
    do {
      // Draw downsampled image
      for (int ox = 0; ox < oW; ox++) {
        for (int oy = 0; oy < oH; oy++) {
          size_t pi = ((oy * scY) * fb->width + (ox * scX)) * 3;
          if (pi + 2 < myRgbBufSize) {
            uint8_t bright = (buf[pi] + buf[pi+1] + buf[pi+2]) / 3;
            if (bright > 100) u8g2.drawPixel(ox, oy);
          }
        }
      }
      // Overlay label if provided
      if (overlayLabel) {
        u8g2.setFont(u8g2_font_5x7_tf);
        u8g2.setColorIndex(0);
        u8g2.drawBox(0, oH - 9, oW, 9);   // dark bar at bottom
        u8g2.setColorIndex(1);
        u8g2.drawStr(1, oH - 1, overlayLabel);
      }
    } while (u8g2.nextPage());
  }
  free(buf);
}

void myActionCollect(int classIdx) {
  Serial.printf("\n>>> Collection mode: %s\n", myClassLabels[classIdx].c_str());
  Serial.println("  TAP (1-2 taps) = Capture image");
  Serial.println("  LONG PRESS (3+ taps) = Exit to menu");
  Serial.println("  Serial: T=capture  L=exit");

  myResetTouchState();

  String path = "/images/" + myClassLabels[classIdx];
  if (!SD.exists("/images")) SD.mkdir("/images");
  if (!SD.exists(path))      SD.mkdir(path);

  // Count existing images per class for display
  int counts[8] = {0};
  for (int i = 0; i < myCfg.numClasses; i++) {
    File root = SD.open("/images/" + myClassLabels[i]);
    if (root) {
      while (File file = root.openNextFile()) {
        if (!file.isDirectory()) {
          String fn = String(file.name());
          if (fn.endsWith(".jpg") || fn.endsWith(".JPG")) counts[i]++;
        }
        file.close();
      }
      root.close();
    }
  }

  unsigned long lastPreview = 0;
  bool shouldCapture = false;

  while (true) {
    // Live preview every 100 ms
    if (millis() - lastPreview > 100) {
      camera_fb_t* fb = esp_camera_fb_get();
      if (fb) {
        myDisplayLiveCameraOnOLED(fb, myClassLabels[classIdx].c_str());
        esp_camera_fb_return(fb);
      }
      lastPreview = millis();
    }

    // Serial input
    if (Serial.available()) {
      char c = Serial.read();
      if (c == 'l' || c == 'L') { myResetMenuState(); return; }
      else if (c == 't' || c == 'T') shouldCapture = true;
    }

    // Touch input
    int touchAction = myCheckTouchInput();
    if (touchAction == 2) { Serial.println("Exiting collection"); myResetMenuState(); return; }
    else if (touchAction == 1) shouldCapture = true;

    // Capture
    if (shouldCapture) {
      shouldCapture = false;
      camera_fb_t* fb = esp_camera_fb_get();
      if (fb) {
        String fileName = path + "/img_" + String(millis()) + ".jpg";
        File file = SD.open(fileName, FILE_WRITE);
        if (file) {
          file.write(fb->buf, fb->len);
          file.close();
          counts[classIdx]++;
          Serial.printf("Saved: %s (Total: %d)\n", fileName.c_str(), counts[classIdx]);
          myDisplayImageOnOLED(fb, counts[classIdx]);
          delay(300);
        }
        esp_camera_fb_return(fb);
      }
    }
    delay(10);
  }
}


// ██████████████████████████████████████████████████████████████████████████████
// ██                                                                          ██
// ██  PART 2: TRAINING (FORWARD/BACKWARD PASS, OPTIMIZER)                     ██
// ██                                                                          ██
// ██████████████████████████████████████████████████████████████████████████████

// ======================================================
// FORWARD PASS
// ======================================================
void myForwardPass(float* input, float* logits) {
  // Conv1
  for (int f = 0; f < CONV1_FILTERS; f++) {
    int ob = f * CONV1_OUTPUT_SIZE * CONV1_OUTPUT_SIZE;
    for (int y = 0; y < CONV1_OUTPUT_SIZE; y++) {
      for (int x = 0; x < CONV1_OUTPUT_SIZE; x++) {
        float sum = 0;
        for (int ky = 0; ky < 3; ky++) {
          for (int kx = 0; kx < 3; kx++) {
            int inPos = ((y+ky)*INPUT_SIZE+(x+kx))*3;
            int wPos  = f*27 + ky*9 + kx*3;
            sum += input[inPos]  *myConv1_w[wPos]   +
                   input[inPos+1]*myConv1_w[wPos+1] +
                   input[inPos+2]*myConv1_w[wPos+2];
          }
        }
        myConv1_output[ob + y*CONV1_OUTPUT_SIZE + x] = leaky_relu(clip_value(sum + myConv1_b[f]));
      }
    }
  }

  // Pool1
  for (int f = 0; f < CONV1_FILTERS; f++) {
    int ib = f*CONV1_OUTPUT_SIZE*CONV1_OUTPUT_SIZE;
    int ob = f*POOL1_OUTPUT_SIZE*POOL1_OUTPUT_SIZE;
    for (int y = 0; y < POOL1_OUTPUT_SIZE; y++) {
      for (int x = 0; x < POOL1_OUTPUT_SIZE; x++) {
        int iy = y*2, ix = x*2;
        float maxVal = myConv1_output[ib + iy*CONV1_OUTPUT_SIZE + ix];
        maxVal = max(maxVal, myConv1_output[ib + iy*CONV1_OUTPUT_SIZE     + ix+1]);
        maxVal = max(maxVal, myConv1_output[ib + (iy+1)*CONV1_OUTPUT_SIZE + ix]);
        maxVal = max(maxVal, myConv1_output[ib + (iy+1)*CONV1_OUTPUT_SIZE + ix+1]);
        myPool1_output[ob + y*POOL1_OUTPUT_SIZE + x] = maxVal;
      }
    }
  }

  // Conv2
  for (int f = 0; f < CONV2_FILTERS; f++) {
    int ob = f*CONV2_OUTPUT_SIZE*CONV2_OUTPUT_SIZE;
    for (int y = 0; y < CONV2_OUTPUT_SIZE; y++) {
      for (int x = 0; x < CONV2_OUTPUT_SIZE; x++) {
        float sum = 0;
        for (int c = 0; c < CONV1_FILTERS; c++) {
          int ib = c*POOL1_OUTPUT_SIZE*POOL1_OUTPUT_SIZE;
          for (int ky = 0; ky < 3; ky++) {
            for (int kx = 0; kx < 3; kx++) {
              sum += myPool1_output[ib + (y+ky)*POOL1_OUTPUT_SIZE + (x+kx)] *
                     myConv2_w[f*36 + c*9 + ky*3 + kx];
            }
          }
        }
        myConv2_output[ob + y*CONV2_OUTPUT_SIZE + x] = leaky_relu(clip_value(sum + myConv2_b[f]));
      }
    }
  }

  // Dense layer (Kahan summation for stability)
  for (int c = 0; c < NUM_CLASSES; c++) {
    double sum = 0, comp = 0;
    for (int i = 0; i < FLATTENED_SIZE; i++) {
      double term = myConv2_output[i] * myOutput_w[c*FLATTENED_SIZE + i];
      double y2   = term - comp;
      double t    = sum + y2;
      comp = (t - sum) - y2;
      sum  = t;
    }
    myDense_output[c] = clip_value((float)sum + myOutput_b[c], -50, 50);
  }

  // Softmax
  float mx = myDense_output[0];
  for (int i = 1; i < NUM_CLASSES; i++) if (myDense_output[i] > mx) mx = myDense_output[i];
  float expSum = 0;
  for (int i = 0; i < NUM_CLASSES; i++) expSum += exp(myDense_output[i] - mx);
  for (int i = 0; i < NUM_CLASSES; i++) {
    logits[i]         = myDense_output[i];
    myDense_output[i] = exp(myDense_output[i] - mx) / expSum;
  }
}

// ======================================================
// BACKWARD PASS
// ======================================================
void myBackwardDense(int label) {
  for (int c = 0; c < NUM_CLASSES; c++) {
    float error = myDense_output[c] - (c == label ? 1.0f : 0.0f);
    for (int i = 0; i < FLATTENED_SIZE; i++) {
      myOutput_w_grad[c*FLATTENED_SIZE+i] = error * myConv2_output[i];
      myDense_grad[i] = (c == 0) ? error * myOutput_w[c*FLATTENED_SIZE+i]
                                 : myDense_grad[i] + error * myOutput_w[c*FLATTENED_SIZE+i];
    }
    myOutput_b_grad[c] = error;
  }
}

void myBackwardConv2() {
  for (int i = 0; i < FLATTENED_SIZE; i++)
    myConv2_grad[i] = myDense_grad[i] * leaky_relu_deriv(myConv2_output[i]);

  memset(myConv2_w_grad, 0, CONV2_WEIGHTS * sizeof(float));
  memset(myConv2_b_grad, 0, CONV2_FILTERS * sizeof(float));
  memset(myPool1_grad,   0, POOL1_OUTPUT_SIZE * POOL1_OUTPUT_SIZE * CONV1_FILTERS * sizeof(float));

  for (int f = 0; f < CONV2_FILTERS; f++) {
    int ob = f*CONV2_OUTPUT_SIZE*CONV2_OUTPUT_SIZE;
    for (int y = 0; y < CONV2_OUTPUT_SIZE; y++) {
      for (int x = 0; x < CONV2_OUTPUT_SIZE; x++) {
        float grad = myConv2_grad[ob + y*CONV2_OUTPUT_SIZE + x];
        myConv2_b_grad[f] += grad;
        for (int c = 0; c < CONV1_FILTERS; c++) {
          int ib = c*POOL1_OUTPUT_SIZE*POOL1_OUTPUT_SIZE;
          for (int ky = 0; ky < 3; ky++) {
            for (int kx = 0; kx < 3; kx++) {
              int pi = ib + (y+ky)*POOL1_OUTPUT_SIZE + (x+kx);
              int wi = f*36 + c*9 + ky*3 + kx;
              myConv2_w_grad[wi] += grad * myPool1_output[pi];
              myPool1_grad[pi]   += grad * myConv2_w[wi];
            }
          }
        }
      }
    }
  }
}

void myBackwardPool1() {
  memset(myConv1_grad, 0, CONV1_OUTPUT_SIZE * CONV1_OUTPUT_SIZE * CONV1_FILTERS * sizeof(float));
  for (int f = 0; f < CONV1_FILTERS; f++) {
    int ib = f*CONV1_OUTPUT_SIZE*CONV1_OUTPUT_SIZE;
    int ob = f*POOL1_OUTPUT_SIZE*POOL1_OUTPUT_SIZE;
    for (int y = 0; y < POOL1_OUTPUT_SIZE; y++) {
      for (int x = 0; x < POOL1_OUTPUT_SIZE; x++) {
        int iy = y*2, ix = x*2;
        float poolVal = myPool1_output[ob + y*POOL1_OUTPUT_SIZE + x];
        float grad    = myPool1_grad  [ob + y*POOL1_OUTPUT_SIZE + x];
        if (myConv1_output[ib + iy    *CONV1_OUTPUT_SIZE + ix  ] == poolVal) myConv1_grad[ib + iy    *CONV1_OUTPUT_SIZE + ix  ] += grad;
        if (myConv1_output[ib + iy    *CONV1_OUTPUT_SIZE + ix+1] == poolVal) myConv1_grad[ib + iy    *CONV1_OUTPUT_SIZE + ix+1] += grad;
        if (myConv1_output[ib + (iy+1)*CONV1_OUTPUT_SIZE + ix  ] == poolVal) myConv1_grad[ib + (iy+1)*CONV1_OUTPUT_SIZE + ix  ] += grad;
        if (myConv1_output[ib + (iy+1)*CONV1_OUTPUT_SIZE + ix+1] == poolVal) myConv1_grad[ib + (iy+1)*CONV1_OUTPUT_SIZE + ix+1] += grad;
      }
    }
  }
}

void myBackwardConv1() {
  for (int i = 0; i < CONV1_OUTPUT_SIZE*CONV1_OUTPUT_SIZE*CONV1_FILTERS; i++)
    myConv1_grad[i] *= leaky_relu_deriv(myConv1_output[i]);

  memset(myConv1_w_grad, 0, CONV1_WEIGHTS * sizeof(float));
  memset(myConv1_b_grad, 0, CONV1_FILTERS * sizeof(float));

  for (int f = 0; f < CONV1_FILTERS; f++) {
    int ob = f*CONV1_OUTPUT_SIZE*CONV1_OUTPUT_SIZE;
    for (int y = 0; y < CONV1_OUTPUT_SIZE; y++) {
      for (int x = 0; x < CONV1_OUTPUT_SIZE; x++) {
        float grad = myConv1_grad[ob + y*CONV1_OUTPUT_SIZE + x];
        myConv1_b_grad[f] += grad;
        for (int ky = 0; ky < 3; ky++) {
          for (int kx = 0; kx < 3; kx++) {
            int inPos = ((y+ky)*INPUT_SIZE + (x+kx)) * 3;
            int wPos  = f*27 + ky*9 + kx*3;
            myConv1_w_grad[wPos]   += grad * myInputBuffer[inPos];
            myConv1_w_grad[wPos+1] += grad * myInputBuffer[inPos+1];
            myConv1_w_grad[wPos+2] += grad * myInputBuffer[inPos+2];
          }
        }
      }
    }
  }
}

// ======================================================
// ADAM OPTIMIZER
// ======================================================
void myAdamUpdate(float* w, float* g, float* m, float* v, int size, int step) {
  float b1 = 0.9f, b2 = 0.999f, eps = 1e-8f;
  float lr_t = LEARNING_RATE * sqrt(1.0f - pow(b2, step)) / (1.0f - pow(b1, step));
  for (int i = 0; i < size; i++) {
    m[i]  = b1*m[i] + (1-b1)*g[i];
    v[i]  = b2*v[i] + (1-b2)*g[i]*g[i];
    w[i] -= lr_t * m[i] / (sqrt(v[i]) + eps);
    w[i]  = clip_value(w[i], -10, 10);
  }
}

void myUpdateWeights(int step) {
  myAdamUpdate(myConv1_w,  myConv1_w_grad,  myConv1_w_m,  myConv1_w_v,  CONV1_WEIGHTS,  step);
  myAdamUpdate(myConv1_b,  myConv1_b_grad,  myConv1_b_m,  myConv1_b_v,  CONV1_FILTERS,  step);
  myAdamUpdate(myConv2_w,  myConv2_w_grad,  myConv2_w_m,  myConv2_w_v,  CONV2_WEIGHTS,  step);
  myAdamUpdate(myConv2_b,  myConv2_b_grad,  myConv2_b_m,  myConv2_b_v,  CONV2_FILTERS,  step);
  myAdamUpdate(myOutput_w, myOutput_w_grad, myOutput_w_m, myOutput_w_v, OUTPUT_WEIGHTS, step);
  myAdamUpdate(myOutput_b, myOutput_b_grad, myOutput_b_m, myOutput_b_v, NUM_CLASSES,    step);
}

// ======================================================
// TRAINING ACTION
//
// MOMENT / ALLOC BEHAVIOUR:
//   Menu entry        : resetMoments=true  — weights from SD or random, Adam cold
//   T=retrain tap     : NO realloc — weights and moments stay warm in RAM
//   L exit + re-entry : next call from menu → resetMoments=true again
//
// EXIT BEHAVIOUR:
//   IN PROGRESS : L/X or 3+ taps → exit WITHOUT saving
//   COMPLETE    : L/X or 3+ taps → exit to menu
//                 T or 1-2 taps  → train again (warm Adam)
// ======================================================
void myActionTrain() {
  Serial.println("\n>>> Training mode");
  Serial.println("  During training : L or 3+ taps = Exit WITHOUT saving");
  Serial.println("  After completion: T or tap     = Train again (warm resume)");
  Serial.println("                    L or 3+ taps = Exit to menu");

  myResetTouchState();

  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_6x10_tf);
    u8g2.drawStr(0, 12, "TRAINING MODE");
    u8g2.drawStr(0, 24, "Loading...");
  } while (u8g2.nextPage());

  bool freshEntry = true;   // true only on first pass through outer loop

  while (true) {

    if (freshEntry) {
      freshEntry = false;
      if (myLoadWeights(true)) {
        Serial.println("[train] Loaded saved weights (moments reset)");
      } else {
        myAllocateMemory(true);
        Serial.println("[train] No saved weights — fresh random init");
      }
    } else {
      Serial.println("[train] Warm resume — keeping weights + Adam moments");
    }

    // Load training data
    myTrainingData.clear();
    for (int i = 0; i < myCfg.numClasses; i++) {
      File root = SD.open("/images/" + myClassLabels[i]);
      if (root) {
        while (File file = root.openNextFile()) {
          if (!file.isDirectory()) {
            String fn = String(file.name());
            if (fn.endsWith(".jpg") || fn.endsWith(".JPG"))
              myTrainingData.push_back({file.path(), i});
          }
          file.close();
        }
        root.close();
      }
    }

    if (myTrainingData.empty()) {
      u8g2.firstPage();
      do { u8g2.drawStr(0, 20, "No Images!"); } while (u8g2.nextPage());
      delay(2000);
      myResetMenuState();
      return;
    }

    int total           = myTrainingData.size();
    int batchesPerEpoch = (total + BATCH_SIZE - 1) / BATCH_SIZE;
    int totalBatches    = TARGET_EPOCHS * batchesPerEpoch;

    Serial.printf("[train] %d images  %d epochs  %d total batches\n",
                  total, TARGET_EPOCHS, totalBatches);

    std::vector<int> indices;
    for (int i = 0; i < total; i++) indices.push_back(i);

    float runningLoss = 0;
    int   lossCount   = 0;
    bool  earlyExit   = false;

    // ---- Training loop ----
    for (int batch = 0; batch < totalBatches; batch++) {

      // Serial exit check
      if (Serial.available()) {
        char c = Serial.read();
        if (c == 'l' || c == 'L' || c == 'x' || c == 'X') {
          Serial.println("[train] Exiting without saving.");
          earlyExit = true; break;
        }
      }

      // Touch exit check
      myCheckTouchBackground();
      if (myPeekTouchAction() == 2) {
        myCheckTouchInput();
        Serial.println("[train] Long press — exiting without saving.");
        earlyExit = true; break;
      }

      // Shuffle at epoch boundary
      if (batch % batchesPerEpoch == 0) {
        int epoch = batch / batchesPerEpoch + 1;
        Serial.printf("\n--- Epoch %d/%d ---\n", epoch, TARGET_EPOCHS);
        for (int i = total - 1; i > 0; i--) {
          int j = random(i + 1);
          int tmp = indices[i]; indices[i] = indices[j]; indices[j] = tmp;
        }
      }

      int batchStart   = (batch % batchesPerEpoch) * BATCH_SIZE;
      int batchEnd     = min(batchStart + BATCH_SIZE, total);
      float batchLoss  = 0;
      int correctCount = 0;

      for (int i = batchStart; i < batchEnd; i++) {
        int idx = indices[i];
        TrainingItem& img = myTrainingData[idx];
        if (!myLoadImageFromFile(img.path.c_str(), myInputBuffer)) continue;

        float logits[8];
        myForwardPass(myInputBuffer, logits);

        float loss = -log(max(myDense_output[img.label], 1e-7f));
        batchLoss += loss;

        int pred = 0;
        for (int j = 1; j < NUM_CLASSES; j++)
          if (myDense_output[j] > myDense_output[pred]) pred = j;
        if (pred == img.label) correctCount++;

        myBackwardDense(img.label);
        myBackwardConv2();
        myBackwardPool1();
        myBackwardConv1();

        if (i % 3 == 0) myCheckTouchBackground();
      }

      myUpdateWeights(batch + 1);

      float avgLoss  = batchLoss / (batchEnd - batchStart);
      float batchAcc = (float)correctCount / (batchEnd - batchStart);
      runningLoss += avgLoss;
      lossCount++;

      if ((batch + 1) % 5 == 0) {
        float displayLoss = runningLoss / lossCount;
        u8g2.firstPage();
        do {
          u8g2.setFont(u8g2_font_6x10_tf);
          u8g2.setCursor(0, 12); u8g2.print("Training...");
          u8g2.setCursor(0, 24);
          u8g2.print("B:"); u8g2.print(batch+1);
          u8g2.print("/"); u8g2.print(totalBatches);
          u8g2.setCursor(0, 36);
          u8g2.print("L:"); u8g2.print(displayLoss, 3);
          u8g2.print(" A:"); u8g2.print((int)(batchAcc*100)); u8g2.print("%");
        } while (u8g2.nextPage());
        runningLoss = 0; lossCount = 0;
      }

      if ((batch + 1) % 10 == 0) {
        Serial.printf("Batch %d/%d — Loss: %.4f  Acc: %.1f%%\n",
                      batch+1, totalBatches, avgLoss, batchAcc*100);
      }
    }
    // ---- End training loop ----

    if (earlyExit) {
      u8g2.firstPage();
      do {
        u8g2.setFont(u8g2_font_6x10_tf);
        u8g2.drawStr(0, 12, "CANCELLED");
        u8g2.drawStr(0, 24, "Not saved");
      } while (u8g2.nextPage());
      delay(1500);
      myResetMenuState();
      return;
    }

    // Completed normally — save
    Serial.println("\n--- Training Complete ---");
    mySaveWeights();

    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_6x10_tf);
      u8g2.drawStr(0, 12, "DONE! Saved.");
      u8g2.drawStr(0, 24, "T/tap:Again");
      u8g2.drawStr(0, 36, "L/3taps:Exit");
    } while (u8g2.nextPage());

    myResetTouchState();
    Serial.println("[train] Done. T=train again (warm)  L=exit");

    while (true) {
      if (Serial.available()) {
        char c = Serial.read();
        if (c == 'l' || c == 'L' || c == 'x' || c == 'X') { myResetMenuState(); return; }
        else if (c == 't' || c == 'T') { Serial.println("[train] Warm retrain..."); break; }
      }
      int touchAction = myCheckTouchInput();
      if (touchAction == 2) { myResetMenuState(); return; }
      else if (touchAction == 1) { Serial.println("[train] Warm retrain..."); break; }
      delay(10);
    }
    // freshEntry stays false → top of outer loop skips realloc
  }
}


// ██████████████████████████████████████████████████████████████████████████████
// ██                                                                          ██
// ██  PART 3: INFERENCE                                                       ██
// ██                                                                          ██
// ██  Live camera feed shown on OLED every frame.                             ██
// ██  Prediction label overlaid on OLED every 10 frames.                     ██
// ██  Full inference result printed to Serial every frame.                   ██
// ██                                                                          ██
// ██████████████████████████████████████████████████████████████████████████████

// ======================================================
// PATCH: myActionInfer() replacement
// File: esp32-on-device-45.ino  (replaces Part 3)
//
// CHANGES:
//   - Every frame : grab fb, run CNN, print Serial, return fb
//   - Every 10th  : before returning fb, update OLED using that same fb
//   - overlayBuf  : updated every 10 frames with latest prediction
// ======================================================

void myActionInfer() {
  Serial.println("\n>>> Inference mode");
  Serial.println("  T or L = exit to menu");

  myResetTouchState();

  if (!myLoadWeights(true)) {
    u8g2.firstPage();
    do { u8g2.drawStr(0, 15, "NOT TRAINED!"); } while (u8g2.nextPage());
    delay(2000);
    myResetMenuState();
    return;
  }

  // Pre-compute resize lookup tables (once per inference session)
  int* sy_lookup = (int*)ps_malloc(myCfg.inputSize * sizeof(int));
  int* sx_lookup = (int*)ps_malloc(myCfg.inputSize * sizeof(int));
  if (!sy_lookup || !sx_lookup) {
    Serial.println("ERROR: lookup table alloc failed!");
    if (sy_lookup) free(sy_lookup);
    if (sx_lookup) free(sx_lookup);
    myResetMenuState();
    return;
  }
  for (int i = 0; i < INPUT_SIZE; i++) {
    sy_lookup[i] = min((int)((i + 0.5f) * 240.0f / INPUT_SIZE), 239);
    sx_lookup[i] = min((int)((i + 0.5f) * 240.0f / INPUT_SIZE), 239);
  }
  Serial.println("Lookup tables ready. Running inference...");

  int  frameIndex = 0;
  int  pred       = 0;
  char overlayBuf[24] = "...";

  while (true) {
    unsigned long frameStart = millis();

    // --- Serial exit check ---
    if (Serial.available()) {
      char c = Serial.read();
      if (c == 't' || c == 'T' || c == 'l' || c == 'L') {
        free(sy_lookup); free(sx_lookup);
        myResetMenuState(); return;
      }
    }

    // --- Grab camera frame ---
    camera_fb_t* fb = esp_camera_fb_get();
    if (!fb) { delay(10); continue; }

    if (!myRgbBuffer) {
      Serial.println("ERROR: myRgbBuffer not allocated!");
      esp_camera_fb_return(fb); delay(10); continue;
    }

    // --- Convert JPEG → RGB (into shared myRgbBuffer) ---
    bool converted = fmt2rgb888(fb->buf, fb->len, PIXFORMAT_JPEG, myRgbBuffer);

    if (converted) {

      // Every 10th frame: update OLED BEFORE returning fb
      // (fb is still valid here, myRgbBuffer has the decoded pixels)
      if (frameIndex == 0) {
        myDisplayLiveCameraOnOLED(fb, overlayBuf);
      }

      // Build normalised float input for CNN
      for (int y = 0; y < INPUT_SIZE; y++) {
        int sy        = sy_lookup[y];
        int sy_offset = sy * 240;
        int dst_y_off = y * INPUT_SIZE;
        for (int x = 0; x < INPUT_SIZE; x++) {
          int srcIdx = (sy_offset + sx_lookup[x]) * 3;
          int dstIdx = (dst_y_off  + x) * 3;
          myInputBuffer[dstIdx]   = myRgbBuffer[srcIdx]   * 0.003921569f;
          myInputBuffer[dstIdx+1] = myRgbBuffer[srcIdx+1] * 0.003921569f;
          myInputBuffer[dstIdx+2] = myRgbBuffer[srcIdx+2] * 0.003921569f;
        }
      }

      // Run inference
      float myLogits[8];
      myForwardPass(myInputBuffer, myLogits);

      pred = 0;
      for (int i = 1; i < NUM_CLASSES; i++)
        if (myDense_output[i] > myDense_output[pred]) pred = i;

      // Serial output every frame
      unsigned long frameMs = millis() - frameStart;
      Serial.printf("Frame %d: %lums (%.1fFPS) | %s %.0f%% | All:",
                    frameIndex + 1, frameMs, 1000.0f / max((unsigned long)1, frameMs),
                    myClassLabels[pred].c_str(), myDense_output[pred] * 100);
      for (int i = 0; i < NUM_CLASSES; i++)
        Serial.printf(" %.0f%%", myDense_output[i] * 100);
      Serial.println();
    }

    // --- Return frame buffer ---
    esp_camera_fb_return(fb);
    frameIndex++;

    // --- Every 10 frames: refresh overlay + check touch exit ---
    if (frameIndex >= 10) {
      snprintf(overlayBuf, sizeof(overlayBuf), "%s %d%%",
               myClassLabels[pred].c_str(),
               (int)(myDense_output[pred] * 100));

      int touchVal = myReadTouch();
      if (touchVal > myThresholdPress) {
        Serial.println("Touch — exiting inference");
        delay(200);
        free(sy_lookup); free(sx_lookup);
        myResetMenuState(); return;
      }

      frameIndex = 0;
    }
  }
}


// ██████████████████████████████████████████████████████████████████████████████
// ██                                                                          ██
// ██  PART 4: MENU SYSTEM                                                     ██
// ██                                                                          ██
// ██████████████████████████████████████████████████████████████████████████████

void myResetMenuState() {
  myIsSelected = false;
  myResetTouchState();
  myLastActivityTime = millis();
  myDrawMenu();
}

void myDrawMenu() {
  Serial.println("\n=== MENU ===");
  for (int i = 1; i <= myTotalItems; i++) {
    String label = (i <= myCfg.numClasses) ? myClassLabels[i-1]
                 : (i == myCfg.numClasses+1) ? "Train" : "Infer";
    Serial.printf("%s %d. %s\n", (i == myMenuIndex) ? " >" : "  ", i, label.c_str());
  }
  Serial.println("Commands: t=next  l=select  1-5=direct");

  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_6x10_tf);
    u8g2.drawStr(0, 8, "TAP:Next HOLD:Ok");
    int startItem = (myMenuIndex <= myCfg.numClasses) ? 1 : myMenuIndex - 2;
    for (int i = 0; i < 3; i++) {
      int cur = startItem + i;
      if (cur > myTotalItems) break;
      String label = (cur <= myCfg.numClasses) ? myClassLabels[cur-1]
                   : (cur == myCfg.numClasses+1) ? "Train" : "Infer";
      int y = 18 + i * 9;
      u8g2.drawStr(0, y, (cur == myMenuIndex ? "> " + label : "  " + label).c_str());
    }
  } while (u8g2.nextPage());
}

void myHandleMenuNavigation() {
  unsigned long now = millis();

  if (!myIsSelected && Serial.available()) {
    char c = Serial.read();
    if (c >= '1' && c <= '5') {
      int newIndex = c - '0';
      if (newIndex <= myTotalItems) {
        myMenuIndex = newIndex;
        myIsSelected = true;
        myLastActivityTime = now;
        if      (myMenuIndex == 1) myActionCollect(0);
        else if (myMenuIndex == 2) myActionCollect(1);
        else if (myMenuIndex == 3) myActionCollect(2);
        else if (myMenuIndex == 4) myActionTrain();
        else if (myMenuIndex == 5) myActionInfer();
      }
    } else if (c == 't' || c == 'T') {
      if (now - myLastTapTime > myTapCooldown) {
        myMenuIndex++;
        if (myMenuIndex > myTotalItems) myMenuIndex = 1;
        myDrawMenu();
        myLastTapTime = now;
        myLastActivityTime = now;
      }
    } else if (c == 'l' || c == 'L') {
      myIsSelected = true;
      myLastActivityTime = now;
      if      (myMenuIndex == 1) myActionCollect(0);
      else if (myMenuIndex == 2) myActionCollect(1);
      else if (myMenuIndex == 3) myActionCollect(2);
      else if (myMenuIndex == 4) myActionTrain();
      else if (myMenuIndex == 5) myActionInfer();
    }
  }

  if (!myIsSelected) {
    int touchAction = myCheckTouchInput();
    if (touchAction == 1) {
      if (now - myLastTapTime > myTapCooldown) {
        myMenuIndex++;
        if (myMenuIndex > myTotalItems) myMenuIndex = 1;
        myDrawMenu();
        myLastTapTime = now;
        myLastActivityTime = now;
      }
    } else if (touchAction == 2) {
      myIsSelected = true;
      myLastActivityTime = now;
      if      (myMenuIndex == 1) myActionCollect(0);
      else if (myMenuIndex == 2) myActionCollect(1);
      else if (myMenuIndex == 3) myActionCollect(2);
      else if (myMenuIndex == 4) myActionTrain();
      else if (myMenuIndex == 5) myActionInfer();
    }
  }
}
