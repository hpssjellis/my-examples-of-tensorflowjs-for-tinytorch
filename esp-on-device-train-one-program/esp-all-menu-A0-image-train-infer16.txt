#include "esp_camera.h"
#include "img_converters.h"
#include "FS.h"
#include "SD.h"
#include "SPI.h"
#include <vector>
#include <U8g2lib.h>
#include <Wire.h>

U8G2_SSD1306_72X40_ER_1_HW_I2C u8g2(U8G2_R2, U8X8_PIN_NONE);

// ======================================================
// CNN ARCHITECTURE CONSTANTS
// ======================================================
#define CONV1_KERNEL_SIZE 3
#define CONV1_FILTERS 4
#define CONV1_WEIGHTS (CONV1_KERNEL_SIZE * CONV1_KERNEL_SIZE * 3 * CONV1_FILTERS) // 108

#define CONV2_KERNEL_SIZE 3
#define CONV2_FILTERS 8
#define CONV2_WEIGHTS (CONV2_KERNEL_SIZE * CONV2_KERNEL_SIZE * 4 * CONV2_FILTERS) // 288

#define POOL1_SIZE 31
#define CONV2_OUTPUT_SIZE 29
#define FLATTENED_SIZE (CONV2_OUTPUT_SIZE * CONV2_OUTPUT_SIZE * CONV2_FILTERS) // 6728

#define NUM_CLASSES 3
#define OUTPUT_WEIGHTS (FLATTENED_SIZE * NUM_CLASSES) // 20184

// ======================================================
// CONFIGURATION & ML HYPERPARAMETERS
// ======================================================
const int myTotalItems = 5;      
const int myThresholdPress = 1100;    // Touch detected threshold
const int myThresholdRelease = 900;   // Touch release threshold (hysteresis)
const int myLongPressTime = 900;      // Increased from 450ms for clearer distinction
const unsigned long myScreenTimeout = 300000; 

String myClassLabels[3] = {"0finger", "1pen", "2wire"};

float LEARNING_RATE = 0.001;
int BATCH_SIZE = 6;
int TARGET_EPOCHS = 5;

// SYSTEM LOGIC VARIABLES
unsigned long myTouchStart = 0;
unsigned long myLastActivityTime = 0; 
bool myIsTouching = false;
bool myLongPressTriggered = false; 
int myMenuIndex = 1;
bool myIsSelected = false;

// ML Buffers (PSRAM)
float* myInputBuffer = nullptr;   
float* myConv1_w = nullptr;      
float* myConv1_b = nullptr;      
float* myConv2_w = nullptr;      
float* myConv2_b = nullptr;      
float* myOutput_w = nullptr;     
float* myOutput_b = nullptr;     

struct TrainingItem {
  String path;
  int label;
};
std::vector<TrainingItem> myTrainingData;

// XIAO ESP32-S3 Camera Pins
#define PWDN_GPIO_NUM     -1
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM     10
#define SIOD_GPIO_NUM     40
#define SIOC_GPIO_NUM     39
#define Y9_GPIO_NUM       48
#define Y8_GPIO_NUM       11
#define Y7_GPIO_NUM       12
#define Y6_GPIO_NUM       14
#define Y5_GPIO_NUM       16
#define Y4_GPIO_NUM       18
#define Y3_GPIO_NUM       17
#define Y2_GPIO_NUM       15
#define VSYNC_GPIO_NUM    38
#define HREF_GPIO_NUM     47
#define PCLK_GPIO_NUM     13

/* * ======================================================
 * TOUCH INPUT UTILITIES
 * ======================================================
 */

// Multi-sample averaging to reduce noise on capacitive touch
int myReadTouch() {
  int sum = 0;
  for(int i=0; i<3; i++) {
    sum += analogRead(A0);
    delayMicroseconds(100);
  }
  return sum / 3;
}

// Complete state reset when exiting menu actions
void myResetMenuState() {
  myIsSelected = false;
  myIsTouching = false;
  myLongPressTriggered = false;
  myLastActivityTime = millis();
}

/* * ======================================================
 * ML UTILITIES (Memory, Loading, Saving, Exporting)
 * ======================================================
 */

void myAllocateMemory() {
  if (myInputBuffer != nullptr) return;
  
  myInputBuffer = (float*)ps_malloc(64 * 64 * 3 * sizeof(float));
  myConv1_w = (float*)ps_malloc(CONV1_WEIGHTS * sizeof(float));
  myConv1_b = (float*)ps_malloc(CONV1_FILTERS * sizeof(float));
  myConv2_w = (float*)ps_malloc(CONV2_WEIGHTS * sizeof(float));
  myConv2_b = (float*)ps_malloc(CONV2_FILTERS * sizeof(float));
  myOutput_w = (float*)ps_malloc(OUTPUT_WEIGHTS * sizeof(float));
  myOutput_b = (float*)ps_malloc(NUM_CLASSES * sizeof(float));

  // Verify PSRAM allocation succeeded
  if (!myInputBuffer || !myConv1_w || !myConv2_w || !myOutput_w) {
    Serial.println("FATAL: PSRAM allocation failed!");
    u8g2.firstPage();
    do { u8g2.drawStr(0, 15, "PSRAM ERROR!"); } while (u8g2.nextPage());
    while(1) { delay(1000); }
  }

  // Default random initialization (fallback if no file exists)
  for(int i=0; i<CONV1_WEIGHTS; i++) myConv1_w[i] = ((rand()%1000)/5000.0f) - 0.1f;
  for(int i=0; i<CONV1_FILTERS; i++) myConv1_b[i] = 0;
  for(int i=0; i<CONV2_WEIGHTS; i++) myConv2_w[i] = ((rand()%1000)/5000.0f) - 0.1f;
  for(int i=0; i<CONV2_FILTERS; i++) myConv2_b[i] = 0;
  for(int i=0; i<OUTPUT_WEIGHTS; i++) myOutput_w[i] = ((rand()%1000)/5000.0f) - 0.1f;
  for(int i=0; i<NUM_CLASSES; i++) myOutput_b[i] = 0;
}

void myExportHeader() {
  if (!SD.exists("/header")) SD.mkdir("/header");
  File file = SD.open("/header/myModel.h", FILE_WRITE);
  if (!file) return;
  file.println("#ifndef MY_MODEL_H\n#define MY_MODEL_H");
  auto myDump = [&](const char* name, float* data, int size) {
    file.printf("const float %s[] = { ", name);
    for(int i=0; i<size; i++) {
      file.print(data[i], 6); file.print("f");
      if(i < size-1) file.print(", ");
      if((i+1)%8 == 0) file.println();
    }
    file.println(" };");
  };
  myDump("myConv1_w", myConv1_w, CONV1_WEIGHTS);
  myDump("myConv1_b", myConv1_b, CONV1_FILTERS);
  myDump("myConv2_w", myConv2_w, CONV2_WEIGHTS);
  myDump("myConv2_b", myConv2_b, CONV2_FILTERS);
  myDump("myOutput_w", myOutput_w, OUTPUT_WEIGHTS);
  myDump("myOutput_b", myOutput_b, NUM_CLASSES);
  file.println("#endif");
  file.close();
}

bool myLoadWeights() {
  if (!SD.exists("/header/myWeights.bin")) {
    Serial.println("No saved weights found - will initialize randomly");
    return false;
  }
  Serial.println("Loading weights from SD...");
  File f = SD.open("/header/myWeights.bin", FILE_READ);
  if (!f) return false;
  myAllocateMemory();
  f.read((uint8_t*)myConv1_w, CONV1_WEIGHTS*4); 
  f.read((uint8_t*)myConv1_b, CONV1_FILTERS*4);
  f.read((uint8_t*)myConv2_w, CONV2_WEIGHTS*4); 
  f.read((uint8_t*)myConv2_b, CONV2_FILTERS*4);
  f.read((uint8_t*)myOutput_w, OUTPUT_WEIGHTS*4); 
  f.read((uint8_t*)myOutput_b, NUM_CLASSES*4);
  f.close();
  Serial.println("Weights loaded successfully");
  return true;
}

void mySaveWeights() {
  if (!SD.exists("/header")) SD.mkdir("/header");
  File f = SD.open("/header/myWeights.bin", FILE_WRITE);
  if (f) {
    f.write((uint8_t*)myConv1_w, CONV1_WEIGHTS*4); 
    f.write((uint8_t*)myConv1_b, CONV1_FILTERS*4);
    f.write((uint8_t*)myConv2_w, CONV2_WEIGHTS*4); 
    f.write((uint8_t*)myConv2_b, CONV2_FILTERS*4);
    f.write((uint8_t*)myOutput_w, OUTPUT_WEIGHTS*4); 
    f.write((uint8_t*)myOutput_b, NUM_CLASSES*4);
    f.close();
    Serial.println("Weights saved to SD");
  }
  myExportHeader();
}

/* * ======================================================
 * CNN INFERENCE - Forward Pass Implementation
 * ======================================================
 */

void myForwardPass(float* input, float* logits) {
  // Conv1: 64x64x3 -> 62x62x4 (3x3 convolution, 4 filters)
  float* conv1_out = (float*)ps_malloc(62*62*CONV1_FILTERS*sizeof(float));
  if (!conv1_out) {
    Serial.println("Conv1 allocation failed");
    return;
  }
  
  for(int f=0; f<CONV1_FILTERS; f++) {
    for(int y=0; y<62; y++) {
      for(int x=0; x<62; x++) {
        float sum = 0;
        for(int ky=0; ky<3; ky++) {
          for(int kx=0; kx<3; kx++) {
            int inPos = ((y+ky)*64+(x+kx))*3;
            int wPos = f*27 + ky*9 + kx*3;
            sum += input[inPos]*myConv1_w[wPos] + 
                   input[inPos+1]*myConv1_w[wPos+1] + 
                   input[inPos+2]*myConv1_w[wPos+2];
          }
        }
        conv1_out[f*3844 + y*62 + x] = max(0.0f, sum + myConv1_b[f]); // ReLU
      }
    }
  }
  
  // Pool1: 62x62x4 -> 31x31x4 (2x2 max pooling)
  float* pool1_out = (float*)ps_malloc(POOL1_SIZE*POOL1_SIZE*CONV1_FILTERS*sizeof(float));
  if (!pool1_out) {
    free(conv1_out);
    Serial.println("Pool1 allocation failed");
    return;
  }
  
  for(int f=0; f<CONV1_FILTERS; f++) {
    for(int y=0; y<POOL1_SIZE; y++) {
      for(int x=0; x<POOL1_SIZE; x++) {
        int iy=y*2, ix=x*2;
        int base = f*3844;
        float maxVal = conv1_out[base + iy*62 + ix];
        maxVal = max(maxVal, conv1_out[base + iy*62 + ix+1]);
        maxVal = max(maxVal, conv1_out[base + (iy+1)*62 + ix]);
        maxVal = max(maxVal, conv1_out[base + (iy+1)*62 + ix+1]);
        pool1_out[f*961 + y*POOL1_SIZE + x] = maxVal;
      }
    }
  }
  
  // Conv2: 31x31x4 -> 29x29x8 (3x3 convolution, 8 filters)
  float* conv2_out = (float*)ps_malloc(CONV2_OUTPUT_SIZE*CONV2_OUTPUT_SIZE*CONV2_FILTERS*sizeof(float));
  if (!conv2_out) {
    free(conv1_out);
    free(pool1_out);
    Serial.println("Conv2 allocation failed");
    return;
  }
  
  for(int f=0; f<CONV2_FILTERS; f++) {
    for(int y=0; y<CONV2_OUTPUT_SIZE; y++) {
      for(int x=0; x<CONV2_OUTPUT_SIZE; x++) {
        float sum = 0;
        for(int c=0; c<CONV1_FILTERS; c++) {
          for(int ky=0; ky<3; ky++) {
            for(int kx=0; kx<3; kx++) {
              sum += pool1_out[c*961 + (y+ky)*POOL1_SIZE + (x+kx)] * 
                     myConv2_w[f*36 + c*9 + ky*3 + kx];
            }
          }
        }
        conv2_out[f*841 + y*CONV2_OUTPUT_SIZE + x] = max(0.0f, sum + myConv2_b[f]); // ReLU
      }
    }
  }
  
  // Dense: flatten 29x29x8=6728 -> 3 classes
  for(int c=0; c<NUM_CLASSES; c++) {
    float sum = 0;
    for(int i=0; i<FLATTENED_SIZE; i++) {
      sum += conv2_out[i] * myOutput_w[c*FLATTENED_SIZE + i];
    }
    logits[c] = sum + myOutput_b[c];
  }
  
  free(conv1_out);
  free(pool1_out);
  free(conv2_out);
}

/* * ======================================================
 * MENU ACTIONS
 * ======================================================
 */

void myActionCollect(int classIdx) {
  Serial.printf("\n>>> Entering collection mode for class: %s\n", myClassLabels[classIdx].c_str());
  String path = "/images/" + myClassLabels[classIdx];
  if (!SD.exists("/images")) SD.mkdir("/images");
  if (!SD.exists(path)) SD.mkdir(path);

  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_6x10_tf);
    u8g2.drawStr(0, 15, (": " + myClassLabels[classIdx]).c_str());
    u8g2.drawStr(0, 30, "TAP:Snap HOLD:Exit");
  } while (u8g2.nextPage());

  while (true) {
    if (myReadTouch() > myThresholdPress) {
      unsigned long start = millis();
      while (myReadTouch() > myThresholdPress) {
        if (millis() - start > myLongPressTime) {
          myResetMenuState();
          delay(200);
          return;
        }
      }
      
      // Short press - capture image
      camera_fb_t * fb = esp_camera_fb_get();
      if (fb) {
        String fileName = path + "/img_" + String(millis()) + ".jpg";
        File file = SD.open(fileName, FILE_WRITE);
        if (file) {
          size_t written = file.write(fb->buf, fb->len);
          file.close();
          
          if (written == fb->len) {
            u8g2.firstPage();
            do { u8g2.drawStr(0, 30, "Saved!"); } while (u8g2.nextPage());
            Serial.printf("Saved: %s\n", fileName.c_str());
          } else {
            u8g2.firstPage();
            do { u8g2.drawStr(0, 30, "Write Error!"); } while (u8g2.nextPage());
            Serial.println("File write error");
          }
          delay(200);
        } else {
          Serial.println("Failed to open file");
        }
        esp_camera_fb_return(fb);
      }
    }
    delay(10);
  }
}

void myActionTrain() {
  Serial.println("\n>>> Starting training mode");
  
  // Try to load existing weights first, otherwise init randomly
  if (myLoadWeights()) {
    Serial.println("Existing weights loaded from SD for continuous training.");
  } else {
    myAllocateMemory();
    Serial.println("No saved weights found. Starting fresh.");
  }

  while (true) {
    myTrainingData.clear();
    for(int i=0; i<3; i++) {
      File root = SD.open("/images/" + myClassLabels[i]);
      if (root) {
        while(File file = root.openNextFile()) {
          if(!file.isDirectory()) myTrainingData.push_back({file.path(), i});
          file.close();
        }
        root.close();
      }
    }
    
    if(myTrainingData.empty()) { 
      u8g2.firstPage();
      do { u8g2.drawStr(0, 20, "No Images!"); } while (u8g2.nextPage());
      delay(2000);
      myResetMenuState();
      return; 
    }

    Serial.printf("Training with %d images\n", myTrainingData.size());
    Serial.println("\n--- Starting Training Cycle ---");
    
    // TEMPORARY SIMULATION - Replace with actual backpropagation
    // TODO: Implement gradient descent on myConv1_w, myConv2_w, myOutput_w
    // Current training is simulated to test the pipeline
    for(int epoch = 1; epoch <= TARGET_EPOCHS; epoch++) {
      float totalLoss = 0;
      int correctCount = 0;
      
      for(size_t i=0; i<myTrainingData.size(); i++) {
        // Simulated loss decreases over epochs
        float currentLoss = (2.0f / (float)epoch) * ((rand() % 100) / 100.0f);
        totalLoss += currentLoss;
        // Simulated accuracy increases over epochs
        if ((rand() % 100) > (30 / epoch)) correctCount++;

        if(i % BATCH_SIZE == 0 || i == myTrainingData.size() - 1) {
          u8g2.firstPage();
          do {
            u8g2.setFont(u8g2_font_6x10_tf);
            u8g2.setCursor(0, 12); u8g2.print("Training...");
            u8g2.setCursor(0, 24); u8g2.print("Epoch: "); u8g2.print(epoch);
            u8g2.setCursor(0, 36); u8g2.print("Loss: "); u8g2.print(currentLoss, 4);
          } while (u8g2.nextPage());
        }
      }
      float accuracy = (float)correctCount / myTrainingData.size();
      Serial.printf("Epoch %d/%d - Loss: %.4f - Acc: %.2f%%\n", epoch, TARGET_EPOCHS, totalLoss / (float)myTrainingData.size(), accuracy * 100.0f);
    }
    
    mySaveWeights();

    u8g2.firstPage();
    do { 
      u8g2.drawStr(0, 15, "CYCLE DONE!"); 
      u8g2.drawStr(0, 30, "TAP:Again HOLD:Exit");
    } while (u8g2.nextPage());

    // Wait for interaction
    while (true) {
      if (myReadTouch() > myThresholdPress) {
        unsigned long start = millis();
        while (myReadTouch() > myThresholdPress) {
          if (millis() - start > myLongPressTime) {
            myResetMenuState();
            delay(200);
            return;
          }
        }
        break; 
      }
      delay(10);
    }
  }
}

void myActionInfer() {
  Serial.println("\n>>> Starting inference mode");
  
  if (!myLoadWeights()) {
    u8g2.firstPage();
    do { u8g2.drawStr(0, 15, "NOT TRAINED!"); } while (u8g2.nextPage());
    delay(2000);
    myResetMenuState();
    return;
  }
  
  while (true) {
    camera_fb_t * fb = esp_camera_fb_get();
    if (fb) {
      // Convert JPEG to RGB and resize to 64x64
      uint8_t* rgb = (uint8_t*)ps_malloc(240*240*3);
      if (rgb && fmt2rgb888(fb->buf, fb->len, PIXFORMAT_JPEG, rgb)) {
        // Resize 240x240 -> 64x64 and normalize to [0,1]
        for(int y=0; y<64; y++) {
          for(int x=0; x<64; x++) {
            int sy = (int)((y+0.5)*240.0/64.0);
            int sx = (int)((x+0.5)*240.0/64.0);
            if(sy>239) sy=239;
            if(sx>239) sx=239;
            int srcIdx = (sy*240 + sx)*3;
            int dstIdx = (y*64 + x)*3;
            myInputBuffer[dstIdx] = rgb[srcIdx]/255.0f;
            myInputBuffer[dstIdx+1] = rgb[srcIdx+1]/255.0f;
            myInputBuffer[dstIdx+2] = rgb[srcIdx+2]/255.0f;
          }
        }
        free(rgb);
        
        // Run inference
        float myLogits[3];
        myForwardPass(myInputBuffer, myLogits);
        
        // Softmax
        float myExpSum = 0;
        float myProbs[3];
        for(int i=0; i<3; i++) {
          myProbs[i] = exp(myLogits[i]);
          myExpSum += myProbs[i];
        }
        for(int i=0; i<3; i++) myProbs[i] /= myExpSum;
        
        // Get prediction
        int pred = 0;
        for(int i=1; i<3; i++) if(myProbs[i] > myProbs[pred]) pred = i;

        u8g2.firstPage();
        do {
          u8g2.setFont(u8g2_font_6x10_tf);
          u8g2.drawStr(0, 12, "RESULT:");
          u8g2.setFont(u8g2_font_7x14_tf);
          u8g2.drawStr(0, 28, myClassLabels[pred].c_str());
          u8g2.setFont(u8g2_font_5x7_tf);
          u8g2.setCursor(0, 38);
          u8g2.print((int)(myProbs[pred] * 100)); u8g2.print("% Conf");
        } while (u8g2.nextPage());
        
        Serial.printf("Prediction: %s (%.1f%%)\n", myClassLabels[pred].c_str(), myProbs[pred]*100);
      } else {
        if(rgb) free(rgb);
      }
      esp_camera_fb_return(fb);
    }

    if (myReadTouch() > myThresholdPress) {
      unsigned long start = millis();
      while (myReadTouch() > myThresholdPress) {
        if (millis() - start > myLongPressTime) {
          myResetMenuState();
          delay(200);
          return;
        }
      }
    }
    delay(10);
  }
}

/* * ======================================================
 * CORE SYSTEM & TOUCH LOGIC
 * ======================================================
 */

void setup() {
  Serial.begin(115200);
  while (!Serial && millis() < 3000); 
  
  Serial.println("\n=== XIAO ESP32-S3 ML System Starting ===");
  Serial.printf("Free heap: %d bytes\n", ESP.getFreeHeap());
  Serial.printf("Free PSRAM: %d bytes\n", ESP.getFreePsram());
  
  pinMode(A0, INPUT);
  u8g2.begin();
  
  if (!SD.begin(21)) {
    Serial.println("SD card initialization failed");
    u8g2.firstPage();
    do { u8g2.drawStr(0, 15, "SD CARD ERROR!"); } while (u8g2.nextPage());
    while(1) { delay(1000); }
  }
  Serial.println("SD card mounted successfully");

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM; config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM; config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM; config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM; config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM; config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM; config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM; config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM; config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000; config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size = FRAMESIZE_240X240; config.jpeg_quality = 12;
  config.fb_count = 1;
  esp_camera_init(&config);
  Serial.println("Camera initialized");
  
  myLastActivityTime = millis();
  Serial.println("System ready - use touch to navigate menu");
}

void loop() {
  unsigned long myCurrentMillis = millis();
  int val = myReadTouch();

  // Hysteresis: use different thresholds for press vs release
  bool touchActive = myIsTouching ? (val > myThresholdRelease) : (val > myThresholdPress);

  if (touchActive) {
    if (!myIsTouching) {
      myTouchStart = myCurrentMillis;
      myIsTouching = true;
      myLongPressTriggered = false;
    }
    myLastActivityTime = myCurrentMillis;

    if (!myLongPressTriggered && (myCurrentMillis - myTouchStart > myLongPressTime)) {
      delay(50);
      if (myReadTouch() > myThresholdPress) {
        myLongPressTriggered = true; 
        myIsSelected = true;
        
        if (myMenuIndex == 1) myActionCollect(0);
        else if (myMenuIndex == 2) myActionCollect(1);
        else if (myMenuIndex == 3) myActionCollect(2);
        else if (myMenuIndex == 4) myActionTrain();
        else if (myMenuIndex == 5) myActionInfer();
      }
    }
  } 
  else {
    if (myIsTouching) {
      if (!myLongPressTriggered && (myCurrentMillis - myTouchStart < myLongPressTime)) {
        if (!myIsSelected) {
          myMenuIndex++;
          if (myMenuIndex > myTotalItems) myMenuIndex = 1;
          Serial.printf("Menu: %d\n", myMenuIndex);
        }
      }
      myIsTouching = false;
      myLongPressTriggered = false;
      delay(50); 
    }
  }

  if (!myIsSelected) {
    u8g2.firstPage();
    do {
      if (myCurrentMillis - myLastActivityTime < myScreenTimeout) {
        u8g2.setFont(u8g2_font_6x10_tf);
        u8g2.drawStr(0, 10, "TAP:Next HOLD:Ok");
        int myStartItem = (myMenuIndex <= 3) ? 1 : myMenuIndex - 2;
        for (int i = 0; i < 3; i++) {
          int cur = myStartItem + i;
          if (cur > myTotalItems) break;
          String label = (cur <= 3) ? myClassLabels[cur-1] : (cur == 4 ? "Train" : "Infer");
          int myYPos = 22 + (i * 9);
          if (myMenuIndex == cur) u8g2.drawStr(0, myYPos, ("> " + label).c_str());
          else u8g2.drawStr(0, myYPos, ("  " + label).c_str());
        }
      }
    } while (u8g2.nextPage());
  }
}
