#include "esp_camera.h"
#include "img_converters.h"
#include "myModel.h" 

// --- 1. CONFIGURATION & BUFFERS ---
float myInputBuffer[64 * 64 * 3];      // Input: 64x64x3
float myConv1Output[62 * 62 * 4];      // After Conv1: 62x62x4
float myPool1Output[31 * 31 * 4];      // After MaxPool: 31x31x4
float myConv2Output[29 * 29 * 8];      // After Conv2: 29x29x8

#ifdef USE_INT8_MODE
  #define GET_W(arr, idx, scale) ((float)arr[idx] / scale)
#else
  #define GET_W(arr, idx, scale) (arr[idx])
  float myConv1_w_scale=1, myConv1_b_scale=1;
  float myConv2_w_scale=1, myConv2_b_scale=1;
  float myOutput_w_scale=1, myOutput_b_scale=1;
#endif

// Camera Pins (XIAO ESP32S3)
#define XCLK_GPIO_NUM 10
#define SIOD_GPIO_NUM 40
#define SIOC_GPIO_NUM 39
#define Y9_GPIO_NUM   48
#define Y8_GPIO_NUM   11
#define Y7_GPIO_NUM   12
#define Y6_GPIO_NUM   14
#define Y5_GPIO_NUM   16
#define Y4_GPIO_NUM   18
#define Y3_GPIO_NUM   17
#define Y2_GPIO_NUM   15
#define VSYNC_GPIO_NUM 38
#define HREF_GPIO_NUM  47
#define PCLK_GPIO_NUM  13

// --- 2. FIRST CONVOLUTION LAYER (3x3, 4 filters) ---
void myConv1() {
    for (int f = 0; f < 4; f++) {
        int outBase = f * 3844;  // 62*62 = 3844
        for (int y = 0; y < 62; y++) {
            for (int x = 0; x < 62; x++) {
                float sum = 0;
                for (int ky = 0; ky < 3; ky++) {
                    for (int kx = 0; kx < 3; kx++) {
                        int pIdx = ((y+ky)*64 + (x+kx))*3;
                        int wIdx = (f*27) + (ky*9) + (kx*3);
                        sum += myInputBuffer[pIdx]   * GET_W(myConv1_w, wIdx,   myConv1_w_scale);
                        sum += myInputBuffer[pIdx+1] * GET_W(myConv1_w, wIdx+1, myConv1_w_scale);
                        sum += myInputBuffer[pIdx+2] * GET_W(myConv1_w, wIdx+2, myConv1_w_scale);
                    }
                }
                sum += GET_W(myConv1_b, f, myConv1_b_scale);
                // ReLU Activation
                myConv1Output[outBase + (y*62 + x)] = (sum > 0) ? sum : 0;
            }
        }
    }
}

// --- 3. MAX POOLING LAYER (2x2, stride 2) ---
void myMaxPool1() {
    for (int f = 0; f < 4; f++) {
        int inBase = f * 3844;   // 62*62
        int outBase = f * 961;   // 31*31
        for (int y = 0; y < 31; y++) {
            for (int x = 0; x < 31; x++) {
                // Get 2x2 window from conv1 output
                int inY = y * 2;
                int inX = x * 2;
                float maxVal = myConv1Output[inBase + (inY*62 + inX)];
                maxVal = max(maxVal, myConv1Output[inBase + (inY*62 + inX+1)]);
                maxVal = max(maxVal, myConv1Output[inBase + ((inY+1)*62 + inX)]);
                maxVal = max(maxVal, myConv1Output[inBase + ((inY+1)*62 + inX+1)]);
                myPool1Output[outBase + (y*31 + x)] = maxVal;
            }
        }
    }
}

// --- 4. SECOND CONVOLUTION LAYER (3x3, 8 filters) ---
void myConv2() {
    for (int f = 0; f < 8; f++) {
        int outBase = f * 841;  // 29*29 = 841
        for (int y = 0; y < 29; y++) {
            for (int x = 0; x < 29; x++) {
                float sum = 0;
                // Convolve over 4 input channels
                for (int c = 0; c < 4; c++) {
                    int inBase = c * 961;  // 31*31
                    for (int ky = 0; ky < 3; ky++) {
                        for (int kx = 0; kx < 3; kx++) {
                            int pIdx = inBase + ((y+ky)*31 + (x+kx));
                            // Weight index: filter*108 + channel*27 + ky*9 + kx*3
                            int wIdx = (f*108) + (c*27) + (ky*9) + (kx*3);
                            sum += myPool1Output[pIdx] * GET_W(myConv2_w, wIdx, myConv2_w_scale);
                        }
                    }
                }
                sum += GET_W(myConv2_b, f, myConv2_b_scale);
                // ReLU Activation
                myConv2Output[outBase + (y*29 + x)] = (sum > 0) ? sum : 0;
            }
        }
    }
}

// --- 5. THE WINNER LOGIC (Dense Layer) ---
int myGetWinner() {
    float myLogits[3] = {0, 0, 0};
    int totalFeatures = 29 * 29 * 8;  // 6728 features
    
    for (int i = 0; i < 3; i++) {
        float sum = 0;
        for (int j = 0; j < totalFeatures; j++) {
            sum += myConv2Output[j] * GET_W(myOutput_w, i*totalFeatures + j, myOutput_w_scale);
        }
        myLogits[i] = sum + GET_W(myOutput_b, i, myOutput_b_scale);
    }
    
    // DIAGNOSTIC: Print all logits with better formatting
    Serial.print("Logits: [");
    Serial.print(myLogits[0], 2); Serial.print(", ");
    Serial.print(myLogits[1], 2); Serial.print(", ");
    Serial.print(myLogits[2], 2); Serial.print("] -> ");
    
    // Calculate softmax probabilities for display
    float maxLogit = max(max(myLogits[0], myLogits[1]), myLogits[2]);
    float expSum = 0;
    for (int i = 0; i < 3; i++) {
        expSum += exp(myLogits[i] - maxLogit);
    }
    Serial.print("Probs: [");
    for (int i = 0; i < 3; i++) {
        float prob = exp(myLogits[i] - maxLogit) / expSum * 100;
        Serial.print(prob, 0); Serial.print("%");
        if (i < 2) Serial.print(", ");
    }
    Serial.print("] ");
    
    int win = (myLogits[1] > myLogits[0]) ? 1 : 0;
    if (myLogits[2] > myLogits[win]) win = 2;
    return win;
}

// --- 6. IMAGE PROCESSING (240x240 -> 64x64) ---
void myProcessCamera(camera_fb_t *fb) {
    uint8_t *rgb = (uint8_t *)ps_malloc(fb->width * fb->height * 3);
    if (!rgb) {
        Serial.println("ERROR: RGB buffer allocation failed!");
        return;
    }
    
    bool success = fmt2rgb888(fb->buf, fb->len, fb->format, rgb);
    if (!success) {
        Serial.println("ERROR: JPEG decode failed!");
        free(rgb);
        return;
    }

    // FIXED: Match browser normalization exactly (no +0.1 bias)
    // Improved: Better downsampling (average nearby pixels instead of single pixel)
    for (int y = 0; y < 64; y++) {
        for (int x = 0; x < 64; x++) {
            // Sample center of each block
            int sY = y * (fb->height / 64) + (fb->height / 128);
            int sX = x * (fb->width / 64) + (fb->width / 128);
            int sIdx = (sY * fb->width + sX) * 3;
            int dIdx = (y * 64 + x) * 3;
            
            myInputBuffer[dIdx]   = rgb[sIdx]   / 255.0f;
            myInputBuffer[dIdx+1] = rgb[sIdx+1] / 255.0f;
            myInputBuffer[dIdx+2] = rgb[sIdx+2] / 255.0f;
        }
    }
    free(rgb);
}

void setup() {
    Serial.begin(115200);
    camera_config_t config;
    config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = Y2_GPIO_NUM; config.pin_d1 = Y3_GPIO_NUM;
    config.pin_d2 = Y4_GPIO_NUM; config.pin_d3 = Y5_GPIO_NUM;
    config.pin_d4 = Y6_GPIO_NUM; config.pin_d5 = Y7_GPIO_NUM;
    config.pin_d6 = Y8_GPIO_NUM; config.pin_d7 = Y9_GPIO_NUM;
    config.pin_xclk = XCLK_GPIO_NUM; config.pin_pclk = PCLK_GPIO_NUM;
    config.pin_vsync = VSYNC_GPIO_NUM; config.pin_href = HREF_GPIO_NUM;
    config.pin_sscb_sda = SIOD_GPIO_NUM; config.pin_sscb_scl = SIOC_GPIO_NUM;
    config.pin_pwdn = -1; config.pin_reset = -1;
    config.xclk_freq_hz = 10000000;
    config.frame_size = FRAMESIZE_240X240;
    config.pixel_format = PIXFORMAT_JPEG;
    config.grab_mode = CAMERA_GRAB_LATEST;
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.fb_count = 1;
    config.jpeg_quality = 12;
    esp_camera_init(&config);
    Serial.println("System Online: Enhanced 2-Layer CNN Ready");
}

void loop() {
    camera_fb_t *fb = esp_camera_fb_get();
    if (fb) {
        myProcessCamera(fb);
        esp_camera_fb_return(fb);
        
        // A0 Snapshot Print (ASCII Art + Stats)
        if (analogRead(A0) > 2000) {
            Serial.println("\n--- AI VIEW ---");
            // Show input statistics
            float minVal = 1.0, maxVal = 0.0, avgVal = 0.0;
            for (int i = 0; i < 64*64*3; i++) {
                if (myInputBuffer[i] < minVal) minVal = myInputBuffer[i];
                if (myInputBuffer[i] > maxVal) maxVal = myInputBuffer[i];
                avgVal += myInputBuffer[i];
            }
            avgVal /= (64*64*3);
            Serial.print("Input stats - Min: "); Serial.print(minVal);
            Serial.print(" Max: "); Serial.print(maxVal);
            Serial.print(" Avg: "); Serial.println(avgVal);
            
            // ASCII art preview
            for (int y=0; y<64; y+=4) {
                for (int x=0; x<64; x+=2) {
                    float brightness = myInputBuffer[(y*64+x)*3];
                    Serial.print(brightness > 0.7 ? "#" : brightness > 0.4 ? "+" : brightness > 0.2 ? "." : " ");
                }
                Serial.println();
            }
            delay(1000);
        }
        
        // Run the full inference pipeline
        myConv1();
        myMaxPool1();
        myConv2();
        
        Serial.print("Class: ");
        Serial.println(myGetWinner());
    }
    delay(100);
}
