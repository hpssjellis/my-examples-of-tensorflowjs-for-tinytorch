#include "esp_camera.h"
#include "img_converters.h"
#include "myModel.h"

// Logic Switcher: Automatically adjusts based on your .h file
#ifdef USE_INT8_MODE
  #define WEIGHT_TYPE int8_t
  // Helper to convert int8 back to float during math
  #define GET_W(arr, idx, scale) ((float)arr[idx] / scale)
#else
  #define WEIGHT_TYPE float
  #define GET_W(arr, idx, scale) (arr[idx])
#endif

float myInputBuffer[64 * 64 * 3]; 
float myConvOutput[62 * 62 * 4];

void myRunConv2D() {
    for (int f = 0; f < 4; f++) {
        int outputBase = f * 3844;
        for (int y = 0; y < 62; y++) {
            for (int x = 0; x < 62; x++) {
                float sum = 0;
                for (int ky = 0; ky < 3; ky++) {
                    int pixelRow = (y + ky) * 64;
                    int weightRow = (f * 27) + (ky * 9);
                    for (int kx = 0; kx < 3; kx++) {
                        int pIdx = (pixelRow + (x + kx)) * 3;
                        int wIdx = weightRow + (kx * 3);
                        
                        // Automatically handles Float or Int8 Scaling
                        sum += myInputBuffer[pIdx]     * GET_W(myConv1_w, wIdx, myConv1_w_scale);
                        sum += myInputBuffer[pIdx + 1] * GET_W(myConv1_w, wIdx + 1, myConv1_w_scale);
                        sum += myInputBuffer[pIdx + 2] * GET_W(myConv1_w, wIdx + 2, myConv1_w_scale);
                    }
                }
                sum += GET_W(myConv1_b, f, myConv1_b_scale);
                myConvOutput[outputBase + (y * 62 + x)] = (sum > 0) ? sum : 0;
            }
        }
    }
}

int myGetClassification() {
    float myLogits[3] = {0, 0, 0};
    int myFlattenSize = 15376; 
    for (int i = 0; i < 3; i++) {
        float sum = 0;
        int weightOffset = i * myFlattenSize;
        for (int j = 0; j < myFlattenSize; j++) {
            sum += myConvOutput[j] * GET_W(myOutput_w, weightOffset + j, myOutput_w_scale);
        }
        myLogits[i] = sum + GET_W(myOutput_b, i, myOutput_b_scale);
    }
    int winner = (myLogits[1] > myLogits[0]) ? 1 : 0;
    if (myLogits[2] > myLogits[winner]) winner = 2;
    return winner;
}

// ... Camera setup and loop remain the same ...
