<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0"></script>

<body style="font-family: sans-serif; background-color: #f0f2f5;">

<h2 align="center">torchjs25.html - Pro Memory Guard</h2>

<div style="font-size:15px; background-color:#fff3cd; width:92%; border:2px solid #ffeeba; padding:15px; margin:auto; border-radius: 10px; color: #856404; box-shadow: 0 4px 6px rgba(0,0,0,0.05);"> 
  <b>The Challenge:</b> AI models create thousands of Tensors. If you don't delete them, the hardware crashes.
  <br><br>
  1. Click <b>Run Leaking Loop</b> to see 300 blocks fill with red "Orphan Tensors." <br>
  2. Click <b>Run Smart Loop</b> to see the first block pulse <b>Green</b> (Work is happening, but memory is being saved!).<br>
  3. Click <b>Visual Clean</b> to watch the "Garbage Collector" scrub the GPU.
</div><br>

<div id="myCodeSpace">
  <div style="display: flex; gap: 20px; padding: 10px; flex-wrap: wrap; justify-content: center;">
    
    <div style="flex: 1; min-width: 300px; max-width: 400px; border: 1px solid #ccc; padding: 20px; border-radius: 15px; background: white; box-shadow: 0 10px 25px rgba(0,0,0,0.1);">
      <b style="color: #444; font-size: 1.2em;">Control Panel</b><hr style="opacity:0.2;">
      <input type="button" value="Run Leaking Loop (Dangerous)" onclick="myStartLeaking()" style="background:#ff4d4d; color:white; padding:15px; width:100%; cursor:pointer; font-weight:bold; border:none; border-radius:8px; margin-bottom:12px; transition: 0.3s;">
      
      <input type="button" value="Run Smart Loop (Safe)" onclick="myStartSmart()" style="background:#2ecc71; color:white; padding:15px; width:100%; cursor:pointer; font-weight:bold; border:none; border-radius:8px; margin-bottom:12px;">
      
      <input type="button" value="Visual Memory Clean" onclick="myVisualClean()" style="background:#3498db; color:white; padding:15px; width:100%; cursor:pointer; font-weight:bold; border:none; border-radius:8px;">
      
      <div id="myDivHistory" style="margin-top:20px; padding: 10px; font-family: monospace; font-size: 0.9em; background: #f8f9fa; border-radius: 5px; min-height: 50px; border: 1px solid #eee;">
        Status: Awaiting instructions...
      </div>
    </div>

    <div style="flex: 2; min-width: 400px; border: 4px solid #2c3e50; padding: 20px; border-radius: 15px; background: #1a1a1a; box-shadow: inset 0 0 20px #000;">
      <div style="display: flex; justify-content: space-between; color: #00ffcc; font-family: monospace; margin-bottom: 10px;">
        <b>GPU TENSOR CORE GRID (300 Units)</b>
        <span>MEM: <span id="myMemBytes">0.00</span> MB</span>
      </div>
      
      <div id="myGrid" style="display: grid; grid-template-columns: repeat(20, 1fr); gap: 3px; background: #111; padding: 10px; border: 1px solid #333;">
        </div>
      
      <div style="margin-top:15px; color: #aaa; font-family: monospace; font-size: 0.8em; text-align: center;">
        Active Tensors: <span id="myTensorCount" style="color:white; font-weight:bold;">0</span> | 
        Capacity: <span id="myCapacity">0</span>%
      </div>
    </div>
  </div>

  <script>
    var myMode = "stop";
    var myTrashCan = [];
    const myGridSize = 300;

    // Initialize the grid visually
    function mySetupGrid() {
      const myGrid = document.getElementById('myGrid');
      myGrid.innerHTML = "";
      for(let i=0; i<myGridSize; i++) {
        let myDiv = document.createElement('div');
        myDiv.id = "myBlock" + i;
        myDiv.style.width = "100%";
        myDiv.style.aspectRatio = "1/1";
        myDiv.style.backgroundColor = "#222";
        myDiv.style.borderRadius = "2px";
        myGrid.appendChild(myDiv);
      }
    }

    async function myStartLeaking() {
      myMode = "leak";
      document.getElementById('myDivHistory').innerHTML = "<b>ALERT:</b> Leaking memory. Tensors are piling up!";
      myMainLoop();
    }

    async function myStartSmart() {
      myMode = "smart";
      document.getElementById('myDivHistory').innerHTML = "<b>HEALTHY:</b> Processing & Disposing.";
      myMainLoop();
    }

    async function myVisualClean() {
      myMode = "stop";
      document.getElementById('myDivHistory').innerHTML = "<b>CLEANING:</b> Manually erasing orphaned tensors...";
      
      // Clean blocks backwards with a nice animation
      let myTotalToClean = myTrashCan.length;
      while(myTrashCan.length > 0) {
        let myT = myTrashCan.pop();
        myT.dispose();
        
        // Update the visual blocks every few disposals
        let myIndex = Math.floor(myTrashCan.length / (myTotalToClean / myGridSize));
        let myTarget = document.getElementById("myBlock" + Math.min(myIndex, myGridSize-1));
        if (myTarget) myTarget.style.backgroundColor = "#222";
        
        if (myTrashCan.length % 5 === 0) {
           myRefreshUI();
           await tf.nextFrame(); 
        }
      }
      
      document.getElementById('myDivHistory').innerHTML = "<b>DONE:</b> GPU Memory is 100% Optimized.";
      myRefreshUI();
    }

    async function myMainLoop() {
      if (myMode === "stop") return;

      if (myMode === "leak") {
        // Create 10 tensors and store them in the trash (Leak)
        for(let i=0; i<10; i++) {
          myTrashCan.push(tf.randomNormal([50, 50]));
        }
        // Fill red blocks based on leak size
        let myLeakedIndex = Math.floor(myTrashCan.length / 5);
        for(let j=0; j < myLeakedIndex && j < myGridSize; j++) {
           document.getElementById("myBlock" + j).style.backgroundColor = "#ff4d4d";
        }
      }

      if (myMode === "smart") {
        // Create and immediately dispose
        for(let i=0; i<10; i++) {
          let myTemp = tf.randomNormal([50, 50]);
          myTemp.dispose(); 
        }
        // FLASH THE FIRST BLOCK GREEN to show work is happening!
        let myPulse = document.getElementById("myBlock0");
        myPulse.style.backgroundColor = "#2ecc71";
        myPulse.style.boxShadow = "0 0 10px #2ecc71";
        setTimeout(() => { 
            myPulse.style.backgroundColor = "#222"; 
            myPulse.style.boxShadow = "none";
        }, 50);
      }

      myRefreshUI();
      if (myMode !== "stop") requestAnimationFrame(myMainLoop);
    }

    function myRefreshUI() {
      const myInfo = tf.memory();
      const myMB = (myInfo.numBytes / 1024 / 1024).toFixed(2);
      document.getElementById('myTensorCount').innerHTML = myInfo.numTensors;
      document.getElementById('myMemBytes').innerHTML = myMB;
      document.getElementById('myCapacity').innerHTML = Math.min((myMB / 10) * 100, 100).toFixed(0);
    }

    window.onload = mySetupGrid;
  </script>
</div>

<input id="myUpdateBtn" type="button" value="Update & Re-Initialize" style="visibility:hidden; background-color: gold; padding:10px; border-radius:8px; font-weight:bold; margin-left:10px;" onclick="myApplyAndRun()">

<textarea id="myTextarea1" wrap="off" rows="2" style="width:95%; background:black; color:white; font-family:monospace; margin:10px; border-radius:10px; padding:10px;" onclick="myToggleEditor()">
Click here to see how the "Pulse" and "Leak" logic works...
</textarea>

<script>
let myOnce = true;
function myToggleEditor() {
    if (myOnce) {
       myTextGrow('myTextarea1', 'myCodeSpace');
       document.getElementById('myUpdateBtn').style.visibility = 'visible';
       myOnce = false;
    }
}

function myApplyAndRun() {
  myMode = "stop";
  let myLines = document.getElementById('myTextarea1').value.split('\n');
  myLines.shift(); myLines.shift(); myLines.pop();   
  document.getElementById('myCodeSpace').innerHTML = myLines.join('\n');
  mySetupGrid(); // Re-draw the big grid
  document.getElementById('myDivHistory').innerHTML = "Logic Updated. Select a test mode.";
}

function myTextGrow(myT, myC) {
   const myArea = document.getElementById(myT);
   myArea.value = '\x3Cscript src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0">\x3C/script>\n\n' + document.getElementById(myC).innerHTML;
   myArea.rows = 20;
}
</script>

</body>