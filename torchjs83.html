<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>XIAO ML Kit â€” TorchJS v83</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
  :root {
    --bg: #0f1117;
    --panel: #181b24;
    --panel2: #1e2230;
    --border: #2a2f42;
    --accent: #3b82f6;
    --accent2: #10b981;
    --accent3: #f59e0b;
    --accent4: #8b5cf6;
    --red: #ef4444;
    --text: #e2e8f0;
    --text2: #94a3b8;
    --mono: 'Courier New', monospace;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--bg);
    color: var(--text);
    padding: 12px;
    min-height: 100vh;
  }
  h1.title {
    text-align: center;
    font-size: 1.4em;
    font-weight: 700;
    letter-spacing: 0.04em;
    padding: 10px 0 4px;
    color: #fff;
  }
  .subtitle { text-align: center; color: var(--text2); font-size: 0.82em; margin-bottom: 14px; }

  .grid { display: flex; gap: 12px; flex-wrap: wrap; align-items: flex-start; }
  .panel {
    flex: 1; min-width: 320px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 14px;
  }
  .panel-green  { border-color: #16533a; background: #111c17; }
  .panel-blue   { border-color: #1e3a5f; background: #0f1c2e; }
  .panel-purple { border-color: #3b2a60; background: #15102a; }

  .panel-title {
    font-weight: 700;
    font-size: 0.85em;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    margin-bottom: 10px;
    padding-bottom: 6px;
    border-bottom: 1px solid var(--border);
    color: var(--accent);
  }
  .panel-title.green  { color: var(--accent2); }
  .panel-title.amber  { color: var(--accent3); }
  .panel-title.purple { color: var(--accent4); }

  label { font-size: 0.82em; color: var(--text2); display: block; margin-bottom: 3px; }
  .row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 7px; gap: 8px; }
  .row label { margin: 0; }

  input[type=number], input[type=text], select, textarea {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 5px;
    color: var(--text);
    padding: 4px 7px;
    font-size: 0.82em;
    outline: none;
  }
  input[type=number]:focus, input[type=text]:focus, select:focus, textarea:focus {
    border-color: var(--accent);
  }
  select { width: 100%; padding: 5px 7px; margin-bottom: 7px; }

  .btn {
    display: block; width: 100%;
    padding: 9px 12px;
    border: none; border-radius: 6px;
    font-weight: 700; font-size: 0.83em;
    letter-spacing: 0.04em;
    cursor: pointer;
    transition: opacity 0.15s, transform 0.1s;
  }
  .btn:hover { opacity: 0.88; transform: translateY(-1px); }
  .btn:active { transform: translateY(0); }
  .btn-blue   { background: var(--accent);  color: #fff; }
  .btn-green  { background: var(--accent2); color: #fff; }
  .btn-amber  { background: var(--accent3); color: #000; }
  .btn-purple { background: var(--accent4); color: #fff; }
  .btn-red    { background: var(--red);     color: #fff; }
  .btn-dark   { background: #2a2f42;        color: var(--text); }
  .btn-sm { padding: 5px 8px; font-size: 0.77em; }
  .btn-half { width: 48%; display: inline-block; }
  .btn-third { width: 31%; display: inline-block; }
  .btn[disabled] { opacity: 0.4; cursor: not-allowed; }

  hr { border: none; border-top: 1px solid var(--border); margin: 10px 0; }

  .video-wrap { text-align: center; margin: 8px 0; }
  #myVideo1, #myCanvas1 {
    border: 2px solid var(--border);
    border-radius: 6px;
    background: #000;
    max-width: 100%;
  }

  .class-grid { display: flex; gap: 6px; }
  .class-col { flex: 1; text-align: center; }
  .class-col .btn { margin-bottom: 3px; }
  .sample-count { font-size: 0.75em; color: var(--text2); margin-top: 3px; }

  .progress-bar-wrap { height: 7px; background: #2a2f42; border-radius: 4px; overflow: hidden; margin-top: 8px; }
  .progress-bar { height: 100%; background: linear-gradient(90deg, var(--accent2), var(--accent)); transition: width 0.3s; width: 0%; }

  .log-box {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    height: 280px;
    overflow-y: auto;
    padding: 8px;
    font-family: var(--mono);
    font-size: 0.75em;
    color: #7dd3fc;
    word-break: break-all;
  }

  .output-box {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    min-height: 60px;
    padding: 10px;
    font-size: 0.88em;
  }

  /* WebSerial panel */
  #mySerialStatus {
    font-size: 0.78em;
    padding: 4px 8px;
    border-radius: 4px;
    display: inline-block;
    margin-bottom: 6px;
  }
  .serial-connected { background: #16533a; color: #6ee7b7; }
  .serial-disconnected { background: #3b1a1a; color: #fca5a5; }

  #mySerialLog {
    background: #050810;
    border: 1px solid #1e2a40;
    border-radius: 6px;
    height: 140px;
    overflow-y: auto;
    padding: 6px 8px;
    font-family: var(--mono);
    font-size: 0.72em;
    color: #4ade80;
  }

  #myEspCanvas {
    border: 2px solid var(--border);
    border-radius: 6px;
    background: #000;
    display: block;
    margin: 6px auto;
  }

  textarea.config-ta {
    width: 100%;
    font-family: var(--mono);
    font-size: 0.75em;
    background: var(--bg);
    color: #93c5fd;
    border: 1px solid #1e3a5f;
    border-radius: 5px;
    padding: 8px;
    resize: vertical;
  }

  .tag { font-size: 0.7em; padding: 2px 6px; border-radius: 3px; font-weight: 700; letter-spacing: 0.05em; }
  .tag-new   { background: #16533a; color: #6ee7b7; }
  .tag-legacy { background: #3b2a1a; color: #fbbf24; }

  .hint { font-size: 0.75em; color: var(--text2); margin: 2px 0 6px; }

  .badge-row { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 6px; }
  .badge { font-size: 0.72em; padding: 2px 7px; border-radius: 10px; font-weight: 600; }
  .badge-blue   { background: #1e3a5f; color: #7dd3fc; }
  .badge-green  { background: #16533a; color: #6ee7b7; }
  .badge-amber  { background: #3d2a00; color: #fbbf24; }

  /* Stat pills */
  .stat-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
  .stat-val { font-weight: 700; font-size: 0.9em; }

  #myResolutionHint { font-size: 0.75em; color: var(--text2); margin-bottom: 6px; }
</style>
</head>
<body>

<h1 class="title">âš¡ XIAO ML Kit â€” TorchJS v83</h1>
<p class="subtitle">Train a CNN in the browser Â· Export weights to ESP32 SD card Â· WebSerial ESP32 camera capture</p>

<div class="grid" id="myCodeSpace">

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       COLUMN 1 â€” CAMERA & DATA COLLECTION
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="panel" style="min-width:320px; max-width:380px;">
    <div class="panel-title">1 Â· Camera &amp; Data Collection</div>

    <!-- Grayscale toggle -->
    <div class="row">
      <label style="cursor:pointer; color:var(--text);">
        <input type="checkbox" id="myGrayscaleToggle" onchange="myCheckGrayscaleChange()">
        Use Grayscale Mode
      </label>
    </div>
    <p class="hint">Set BEFORE starting â€” 3Ã— smaller model, needs more data</p>

    <!-- Resolution -->
    <div class="row">
      <label style="color:var(--text);">Input Resolution:</label>
      <div style="display:flex; gap:4px; align-items:center;">
        <select id="myResolutionSelect" onchange="myOnResolutionSelect()" style="width:auto; padding:3px 5px;">
          <option value="64">64Ã—64 (~6 FPS)</option>
          <option value="96">96Ã—96 (~2.3 FPS)</option>
          <option value="112">112Ã—112 (~1.7 FPS)</option>
          <option value="128">128Ã—128 (~1.3 FPS)</option>
          <option value="144">144Ã—144 (~1.0 FPS)</option>
          <option value="160">160Ã—160 (~0.9 FPS)</option>
          <option value="192">192Ã—192 (~0.6 FPS)</option>
          <option value="240">240Ã—240 (~0.4 FPS)</option>
          <option value="custom">Customâ€¦</option>
        </select>
        <input type="number" id="myResolutionCustom" value="64" min="8" max="240" step="2"
               style="width:58px; display:none;" onchange="myOnResolutionCustom()">
      </div>
    </div>
    <div id="myResolutionHint">Training resolution: 64Ã—64 â€” conv2 out: 29Ã—29</div>

    <!-- Camera select â€” includes ESP32 WebSerial option -->
    <select id="myCameraSelect" title="Select webcam or ESP32 camera via WebSerial"></select>

    <!-- Video / canvas preview -->
    <div class="video-wrap">
      <video id="myVideo1" width="240" height="240" autoplay playsinline></video>
      <canvas id="myCanvas1" width="240" height="240" style="display:none;"></canvas>
      <!-- ESP32 live preview canvas (shown when ESP32 camera selected) -->
      <canvas id="myEspCanvas" width="240" height="240" style="display:none;" title="ESP32 Live Preview"></canvas>
    </div>

    <div style="display:flex; gap:6px; margin-bottom:8px;">
      <button class="btn btn-blue btn-half" id="myStartBtn" onclick="myStartAll()">â–¶ Start Camera &amp; Brain</button>
      <button class="btn btn-red btn-half" id="myStopCameraBtn" onclick="myStopCamera()" style="display:none;">â¹ Stop Camera</button>
    </div>

    <hr>
    <div class="row">
      <label style="color:var(--text);">Max Buffer per class:</label>
      <input type="number" id="myMaxBufferInput" value="100" min="10" max="500" style="width:70px;" onchange="myUpdateMaxBuffer()">
    </div>
    <p class="hint">Higher = more memory</p>

    <hr>
    <div style="display:flex; gap:6px; margin-bottom:8px;">
      <button class="btn btn-dark btn-half btn-sm" onclick="mySaveModel()">ğŸ’¾ Save TFJS</button>
      <button class="btn btn-dark btn-half btn-sm" onclick="myLoadModel()">ğŸ“‚ Load TFJS</button>
    </div>

    <hr>
    <button class="btn btn-green" style="margin-bottom:8px;" onclick="mySaveAllImages()">ğŸ’¾ Save ALL Classes â†’ images.zip</button>

    <!-- 3-class collect buttons -->
    <div class="class-grid">
      <div class="class-col" id="classCol0">
        <button class="btn btn-blue btn-sm" onclick="myCollect(0)">ğŸ“¸ Capture 0</button>
        <button class="btn btn-dark btn-sm" style="margin-top:2px;" onclick="myLoadImages(0)">Load</button>
        <button class="btn btn-dark btn-sm" style="margin-top:2px; background:#1e3a1a;" onclick="mySaveImages(0)">Saveâ†“</button>
        <button class="btn btn-dark btn-sm" style="margin-top:2px; background:#3a1a1a;" onclick="myClearImages(0)">Clear</button>
        <input type="text" id="myLabel0" value="0Blank" style="width:100%; margin-top:4px; text-align:center;">
        <div class="sample-count" id="myCount0">0 samples</div>
      </div>
      <div class="class-col" id="classCol1">
        <button class="btn btn-blue btn-sm" onclick="myCollect(1)">ğŸ“¸ Capture 1</button>
        <button class="btn btn-dark btn-sm" style="margin-top:2px;" onclick="myLoadImages(1)">Load</button>
        <button class="btn btn-dark btn-sm" style="margin-top:2px; background:#1e3a1a;" onclick="mySaveImages(1)">Saveâ†“</button>
        <button class="btn btn-dark btn-sm" style="margin-top:2px; background:#3a1a1a;" onclick="myClearImages(1)">Clear</button>
        <input type="text" id="myLabel1" value="1Circle" style="width:100%; margin-top:4px; text-align:center;">
        <div class="sample-count" id="myCount1">0 samples</div>
      </div>
      <div class="class-col" id="classCol2">
        <button class="btn btn-blue btn-sm" onclick="myCollect(2)">ğŸ“¸ Capture 2</button>
        <button class="btn btn-dark btn-sm" style="margin-top:2px;" onclick="myLoadImages(2)">Load</button>
        <button class="btn btn-dark btn-sm" style="margin-top:2px; background:#1e3a1a;" onclick="mySaveImages(2)">Saveâ†“</button>
        <button class="btn btn-dark btn-sm" style="margin-top:2px; background:#3a1a1a;" onclick="myClearImages(2)">Clear</button>
        <input type="text" id="myLabel2" value="2Square" style="width:100%; margin-top:4px; text-align:center;">
        <div class="sample-count" id="myCount2">0 samples</div>
      </div>
    </div>
    <p class="hint" style="margin-top:6px;">Saveâ†“ = per-class ZIP Â· Save ALL = one ZIP with all 3 folders â†’ SD card /images/ClassName/</p>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       COLUMN 2 â€” WEBSERIAL ESP32 PANEL  (NEW)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="panel panel-blue" style="min-width:300px; max-width:360px;">
    <div class="panel-title">2 Â· ESP32 WebSerial <span class="tag tag-new">NEW</span></div>

    <p class="hint">Connect your XIAO ESP32S3 Sense via USB Â· requires Chrome/Edge Â· <b>USB CDC On Boot: Enabled</b></p>

    <div id="mySerialStatus" class="serial-disconnected">â›” Not Connected</div>

    <div style="display:flex; gap:6px; margin-bottom:8px;">
      <button class="btn btn-blue btn-half btn-sm" onclick="myConnectSerial()">ğŸ”Œ Connect ESP32</button>
      <button class="btn btn-red btn-half btn-sm" onclick="myDisconnectSerial()">â Disconnect</button>
    </div>

    <!-- Send serial commands -->
    <div class="row" style="margin-bottom:6px;">
      <label style="color:var(--text); font-size:0.8em;">Send command:</label>
      <div style="display:flex; gap:4px;">
        <input type="text" id="mySerialCmd" placeholder="t, l, 1-5 â€¦" style="width:100px;">
        <button class="btn btn-dark btn-sm" style="padding:4px 8px;" onclick="mySendSerial()">Send</button>
      </div>
    </div>
    <div class="badge-row">
      <span class="badge badge-blue" style="cursor:pointer;" onclick="mySendSerialChar('t')" title="Next menu item">t = Next</span>
      <span class="badge badge-blue" style="cursor:pointer;" onclick="mySendSerialChar('l')" title="Select menu item">l = Select</span>
      <span class="badge badge-green" style="cursor:pointer;" onclick="mySendSerialChar('1')">1</span>
      <span class="badge badge-green" style="cursor:pointer;" onclick="mySendSerialChar('2')">2</span>
      <span class="badge badge-green" style="cursor:pointer;" onclick="mySendSerialChar('3')">3</span>
      <span class="badge badge-amber" style="cursor:pointer;" onclick="mySendSerialChar('4')">4=Train</span>
      <span class="badge badge-amber" style="cursor:pointer;" onclick="mySendSerialChar('5')">5=Infer</span>
    </div>

    <hr>
    <!-- ESP32 Camera image capture -->
    <p style="font-size:0.8em; font-weight:700; margin-bottom:4px; color:var(--accent3);">ğŸ“· Capture from ESP32 Camera</p>
    <p class="hint">ESP32 sends JPEG frames over Serial when you request them. Use this to capture training images directly from the device camera.</p>

    <canvas id="myEspPreview" width="240" height="180" style="width:100%; border-radius:5px; border:1px solid var(--border); background:#000; margin-bottom:6px; display:block;"></canvas>

    <div style="display:flex; gap:6px; margin-bottom:6px;">
      <button class="btn btn-amber btn-half btn-sm" onclick="myRequestEspFrame()">ğŸ“¡ Request Frame</button>
      <button class="btn btn-dark btn-half btn-sm" id="myEspAutoBtn" onclick="myToggleEspAuto()">â–¶ Auto Capture</button>
    </div>
    <div class="row" style="margin-bottom:4px;">
      <label style="color:var(--text);">Add to class:</label>
      <select id="myEspCaptureClass" style="width:auto; padding:3px;">
        <option value="0">Class 0</option>
        <option value="1">Class 1</option>
        <option value="2">Class 2</option>
      </select>
    </div>
    <button class="btn btn-green btn-sm" onclick="myAddEspFrameToClass()">âœš Add Last Frame to Class</button>

    <hr>
    <!-- Serial monitor log -->
    <p style="font-size:0.8em; font-weight:700; margin-bottom:4px; color:var(--accent2);">ğŸ“Ÿ Serial Monitor</p>
    <div id="mySerialLog">Serial output will appear hereâ€¦</div>
    <div style="display:flex; gap:6px; margin-top:4px;">
      <button class="btn btn-dark btn-sm btn-half" onclick="document.getElementById('mySerialLog').innerHTML=''">Clear Log</button>
      <label style="display:flex; align-items:center; gap:4px; font-size:0.75em; cursor:pointer; color:var(--text2);">
        <input type="checkbox" id="mySerialAutoScroll" checked> Auto-scroll
      </label>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       COLUMN 3 â€” TRAINING PROGRESS
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="panel panel-green" style="min-width:300px; max-width:360px;">
    <div class="panel-title green">3 Â· Training Progress</div>

    <div class="stat-row"><span>Batches Trained:</span><span class="stat-val" id="myEpochDisplay" style="color:var(--accent);">0</span></div>
    <div class="stat-row">
      <span>Min Samples:</span>
      <input type="number" id="myMinSamples" value="10" min="1" max="100" style="width:70px;">
    </div>

    <div style="margin-bottom:6px;">
      <label style="cursor:pointer; color:var(--text);">
        <input type="checkbox" id="myUseAllData" checked onchange="myToggleEpochMode()"> Use All Data (systematic epochs)
      </label>
    </div>
    <div id="myEpochControls">
      <div class="row">
        <label style="color:var(--text);">Target Epochs:</label>
        <input type="number" id="myTargetEpochs" value="10" min="0" step="0.5" style="width:70px;">
      </div>
      <p class="hint" id="myEpochHint"></p>
    </div>
    <div id="myBatchControls" style="display:none;">
      <div class="row">
        <label style="color:var(--text);">Max Batches:</label>
        <input type="number" id="myMaxBatches" value="40" min="0" style="width:70px;">
      </div>
    </div>
    <div class="row">
      <label style="color:var(--text);">Batch Size:</label>
      <input type="number" id="myBatchSize" value="6" min="3" max="30" step="3" style="width:70px;">
    </div>
    <div class="row">
      <label style="color:var(--text);">Learning Rate:</label>
      <input type="number" id="myLearningRate" value="0.001" min="0.00001" max="0.1" step="0.0001" style="width:90px;">
    </div>
    <div class="row">
      <label style="color:var(--text);">Dropout Rate:</label>
      <input type="number" id="myDropoutRate" value="0.3" min="0.0" max="0.9" step="0.1" style="width:70px;">
    </div>

    <div class="stat-row"><span>Avg Loss:</span><span class="stat-val" id="myLossDisplay" style="color:var(--accent3);">--</span></div>
    <div class="stat-row"><span>Status:</span><span id="myStatusDisplay" style="font-weight:700; color:#64748b; font-size:0.85em;">Waitingâ€¦</span></div>

    <div style="display:flex; gap:6px; margin: 8px 0;">
      <button class="btn btn-amber btn-half" id="myPauseBtn" onclick="myPauseTraining()" disabled>â¸ Pause</button>
      <button class="btn btn-green btn-half" id="myResumeBtn" onclick="myResumeTraining()" style="display:none;">â–¶ Resume</button>
    </div>
    <div class="progress-bar-wrap"><div class="progress-bar" id="myProgressBar"></div></div>

    <hr>
    <div id="myOutputDisplay" class="output-box">Readyâ€¦</div>

    <hr>
    <div style="display:flex; gap:6px; margin-bottom:6px;">
      <button class="btn btn-dark btn-half btn-sm" id="myStopAnalysisBtn" onclick="myStopAnalysis()" disabled>â¹ Stop Analysis</button>
      <button class="btn btn-blue btn-half btn-sm" id="myStartAnalysisBtn" onclick="myStartAnalysis()" style="display:none;">â–¶ Start Analysis</button>
    </div>
    <button class="btn btn-dark btn-sm" onclick="myDebugCurrentFrame()">ğŸ” Debug Current Frame</button>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       COLUMN 4 â€” ESP32 EXPORT
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="panel panel-purple" style="min-width:320px; max-width:400px;">
    <div class="panel-title purple">4 Â· ESP32 Export (v57 SD Format)</div>
    <p class="hint">Exports weights + config for the XIAO ESP32S3 Sense. Copy files to SD card <code style="color:var(--accent4);">/header/</code> folder.</p>

    <!-- Version -->
    <div class="row">
      <label style="color:var(--text);">Firmware Version:</label>
      <input type="number" id="myBinVersion" value="50" min="1" style="width:60px;" onchange="myRefreshConfigTextarea()">
    </div>

    <!-- Export options -->
    <label style="cursor:pointer; color:var(--text); margin-bottom:4px; display:block;">
      <input type="checkbox" id="myExportAugmentation" onchange="myRefreshConfigTextarea()"> useAugmentation (flip + brightness on ESP32)
    </label>
    <label style="cursor:pointer; color:var(--text); margin-bottom:4px; display:block;">
      <input type="checkbox" id="myExportGrayscale" onchange="myRefreshConfigTextarea()"> useGrayscale (must match model colour mode)
    </label>
    <!-- v57 new fields -->
    <label style="cursor:pointer; color:var(--text); margin-bottom:4px; display:block;">
      <input type="checkbox" id="myExportImagesToPsram" checked onchange="myRefreshConfigTextarea()"> imagesToPsram <span class="tag tag-new">v57</span>
    </label>
    <div class="row" style="margin-bottom:8px;">
      <label style="color:var(--text);">validationImages <span class="tag tag-new">v57</span>:</label>
      <input type="number" id="myExportValidationImages" value="3" min="0" max="20" style="width:60px;" onchange="myRefreshConfigTextarea()">
    </div>
    <p class="hint">imagesToPsram = preload all training images to PSRAM before training. validationImages = last N images per class held out for validation.</p>

    <hr>

    <!-- myWeights.bin export -->
    <button class="btn btn-purple" style="margin-bottom:4px;" onclick="myExportBin()">â¬‡ Export myWeights.bin â†’ SD /header/</button>
    <p class="hint">Binary: JSON header + float32 weights. Copy to <code>/header/myWeights.bin</code> on SD card.</p>

    <hr>

    <!-- config.json textarea + direct save -->
    <p style="font-size:0.82em; font-weight:700; color:var(--accent); margin-bottom:3px;">config.json <span class="tag tag-new">Direct Download</span></p>
    <p class="hint">Live textarea â€” edit freely before saving. Syncs from fields above.</p>
    <textarea id="myConfigTextarea" class="config-ta" rows="22" spellcheck="false"></textarea>
    <button class="btn btn-blue" style="margin-top:5px;" onclick="myExportConfigJson()">â¬‡ Save config.json â†’ Downloads</button>
    <p class="hint" style="margin-top:4px;">Saves directly to Downloads as config.json (no ZIP needed). Copy to SD card <code>/header/config.json</code>.</p>

    <hr>

    <!-- Header file export â€” legacy, still useful for hardcoded approach -->
    <p style="font-size:0.82em; font-weight:700; color:var(--accent3); margin-bottom:3px;">
      GENERATE .h Header File <span class="tag tag-legacy">Legacy / Optional</span>
    </p>
    <p class="hint">For older firmware that reads weights from a compiled-in C header instead of the SD card. Not needed for v57+ which reads from SD /header/myWeights.bin.</p>
    <div class="row">
      <label style="color:var(--text);">Use Int8:</label>
      <input type="checkbox" id="myInt8Toggle">
      <label style="color:var(--text); margin-left:10px;">Name:</label>
      <input type="text" id="myExportName" value="myModel" style="width:90px;"> .h
    </div>
    <button class="btn btn-amber btn-sm" onclick="myExportHeader()">â¬‡ Generate .h Header</button>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       COLUMN 5 â€” ACTIVITY LOG
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="panel" style="min-width:280px; max-width:340px;">
    <div class="panel-title">5 Â· Activity Log</div>
    <div class="log-box" id="myDivHistory">Logs will appear hereâ€¦</div>
    <button class="btn btn-dark btn-sm" style="margin-top:6px;" onclick="document.getElementById('myDivHistory').innerHTML=''">Clear Log</button>
  </div>

</div><!-- /grid -->

<!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<!--  Source code editor (collapsed by default)          -->
<!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div style="text-align:center; margin-top:14px;">
  <button class="btn btn-dark" style="width:auto; padding:7px 20px;" onclick="myToggleEditor()">{ } View / Edit Source Code</button>
  <button id="myUpdateBtn" class="btn btn-amber" style="display:none; width:auto; padding:7px 20px; margin-left:8px;" onclick="myApplyAndRun()">âš¡ Update &amp; Run</button>
</div>
<textarea id="myTextarea1" wrap="off" rows="2"
  style="width:98%; background:#050810; color:#93c5fd; font-family:var(--mono); margin:10px 1%; padding:10px; border-radius:8px; border:1px solid #1e2a40; display:none; resize:vertical;">
</textarea>

<footer style="text-align:center; margin-top:18px; padding:10px; color:var(--text2); font-size:0.78em; border-top:1px solid var(--border);">
  By <a href="https://github.com/hpssjellis" style="color:var(--accent);">Jeremy Ellis (hpssjellis)</a> Â· 
  <a href="https://www.linkedin.com/in/jeremy-ellis-4237a9bb/" style="color:var(--accent);">LinkedIn</a> Â· 
  <a href="https://opencollective.com/mlsysbook" style="color:var(--accent2);">Support opencollective/mlsysbook</a> Â· 
  <a href="https://www.seeedstudio.com/The-XIAOML-Kit.html" style="color:var(--accent3);">XIAO ML Kit $22 USD</a>
  Â· Use at your own risk Â· MIT
</footer>


<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     MAIN SCRIPT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// STATE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var myModel, myTimer, myLastID = -1;
var myTrainData = {0:[], 1:[], 2:[]};
var myRawData   = {0:[], 1:[], 2:[]};
var myMaxBuffer = 100;
var myEpochCount = 0;
var myLossHistory = [];
var myLossSum = 0, myLossCount = 0;
var myTrainingPaused = false;
var myAnalysisStopped = false;
var myIsGrayscaleMode = false;
var myGrayscaleRenderTimer = null;
var myAllDataIndex = 0;
var myCurrentEpoch = 0;
var myShuffledData = [];
var myCameraStopped = false;
var myInputSize = 64;

// WebSerial state
var mySerialPort = null;
var mySerialReader = null;
var mySerialWriter = null;
var mySerialReadLoop = null;
var mySerialBuffer = '';
var mySerialConnected = false;
var myEspLastFrame = null;    // ImageData of last received ESP32 JPEG frame
var myEspAutoCapture = false;
var myEspAutoTimer = null;
var myEspReceivingJpeg = false;
var myEspJpegBytes = [];

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RESOLUTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function myGetConv2Out(sz) { return Math.floor((sz - 2) / 2) - 2; }

function myUpdateResolutionHint() {
  const sz  = myInputSize;
  const c2  = myGetConv2Out(sz);
  const flat = c2 * c2 * 8;
  const hint = document.getElementById('myResolutionHint');
  if (!hint) return;
  const locked = !!myModel;
  hint.innerHTML = locked
    ? `<span style="color:#f87171;">ğŸ”’ Locked at ${sz}Ã—${sz} â€” rebuild model to change</span>`
    : `Resolution: ${sz}Ã—${sz} â€” conv2 out: ${c2}Ã—${c2} â€” flat: ${flat} â€” Set BEFORE starting`;
}

function myOnResolutionSelect() {
  if (myModel) {
    alert('âš ï¸ Resolution is locked once the model is built.\nRefresh the page to change.');
    const sel = document.getElementById('myResolutionSelect');
    const match = Array.from(sel.options).find(o => o.value === String(myInputSize));
    if (match) sel.value = myInputSize; else sel.value = 'custom';
    return;
  }
  const sel = document.getElementById('myResolutionSelect');
  const custom = document.getElementById('myResolutionCustom');
  if (sel.value === 'custom') {
    custom.style.display = 'inline-block';
    myInputSize = parseInt(custom.value) || 64;
  } else {
    custom.style.display = 'none';
    myInputSize = parseInt(sel.value);
  }
  myUpdateResolutionHint();
}

function myOnResolutionCustom() {
  if (myModel) return;
  const val = parseInt(document.getElementById('myResolutionCustom').value) || 64;
  myInputSize = Math.max(8, Math.min(240, val % 2 === 0 ? val : val - 1));
  document.getElementById('myResolutionCustom').value = myInputSize;
  myUpdateResolutionHint();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HELPERS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var myRawCanvas = document.createElement('canvas');
myRawCanvas.width = 240; myRawCanvas.height = 240;
var myRawCtx = myRawCanvas.getContext('2d');

function myLog(msg) {
  const div = document.getElementById('myDivHistory');
  const t = new Date().toLocaleTimeString();
  div.innerHTML = `<span style="color:#475569;">[${t}]</span> ${msg}<br>` + div.innerHTML;
}

function myUpdateMaxBuffer() {
  myMaxBuffer = parseInt(document.getElementById('myMaxBufferInput').value) || 100;
  myLog(`Max buffer â†’ ${myMaxBuffer} samples/class`);
}

function myToggleEpochMode() {
  const all = document.getElementById('myUseAllData').checked;
  document.getElementById('myEpochControls').style.display = all ? 'block' : 'none';
  document.getElementById('myBatchControls').style.display = all ? 'none' : 'block';
  myUpdateEpochHint();
}

function myUpdateEpochHint() {
  if (!document.getElementById('myUseAllData').checked) return;
  const counts = [myTrainData[0].length, myTrainData[1].length, myTrainData[2].length];
  const total  = counts.reduce((a,b) => a+b, 0);
  const bs     = parseInt(document.getElementById('myBatchSize').value) || 6;
  const bpe    = Math.ceil(total / bs);
  const ep     = parseFloat(document.getElementById('myTargetEpochs').value) || 10;
  const hint   = document.getElementById('myEpochHint');
  if (hint) hint.innerText = total > 0
    ? `â‰ˆ ${bpe} batches/epoch = ${Math.ceil(ep*bpe)} total batches`
    : 'Waiting for training dataâ€¦';
}

function myAugment(tensor) {
  return tf.tidy(() => {
    let a = tensor;
    if (Math.random() > 0.5) a = a.add((Math.random()-0.5)*0.2).clipByValue(0,1);
    if (Math.random() > 0.5) {
      const c = 0.8 + Math.random()*0.4;
      const m = a.mean();
      a = a.sub(m).mul(c).add(m).clipByValue(0,1);
    }
    return a;
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// WEBSERIAL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function mySerialLog(msg) {
  const box = document.getElementById('mySerialLog');
  box.innerHTML += `<span style="color:#475569;">${new Date().toLocaleTimeString()}</span> ${msg}\n`;
  if (document.getElementById('mySerialAutoScroll').checked)
    box.scrollTop = box.scrollHeight;
}

function mySetSerialStatus(connected) {
  mySerialConnected = connected;
  const el = document.getElementById('mySerialStatus');
  if (connected) {
    el.className = 'serial-connected';
    el.textContent = 'âœ… Connected';
    // Add ESP32 camera option to dropdown if not already there
    const sel = document.getElementById('myCameraSelect');
    if (!document.getElementById('opt-esp32-serial')) {
      const opt = document.createElement('option');
      opt.id = 'opt-esp32-serial';
      opt.value = '__esp32serial__';
      opt.text = 'ğŸ“¡ ESP32 Camera (WebSerial)';
      sel.insertBefore(opt, sel.firstChild);
    }
  } else {
    el.className = 'serial-disconnected';
    el.textContent = 'â›” Not Connected';
    // Remove ESP32 option from dropdown
    const opt = document.getElementById('opt-esp32-serial');
    if (opt) opt.remove();
  }
}

async function myConnectSerial() {
  if (!('serial' in navigator)) {
    alert('âŒ WebSerial not supported.\nPlease use Chrome or Edge on a desktop.');
    return;
  }
  try {
    mySerialPort = await navigator.serial.requestPort();
    await mySerialPort.open({ baudRate: 115200 });
    mySetSerialStatus(true);
    myLog('ESP32 Serial connected');
    mySerialLog('=== Connected at 115200 baud ===');

    // Start read loop
    const textDecoder = new TextDecoderStream();
    const readableStreamClosed = mySerialPort.readable.pipeTo(textDecoder.writable);
    mySerialReader = textDecoder.readable.getReader();

    mySerialReadLoop = (async () => {
      try {
        while (true) {
          const { value, done } = await mySerialReader.read();
          if (done) break;
          if (value) myHandleSerialData(value);
        }
      } catch (e) {
        if (mySerialConnected) myLog('Serial read error: ' + e.message);
      }
    })();

    // Setup writer
    const textEncoder = new TextEncoderStream();
    const writableStreamClosed = textEncoder.readable.pipeTo(mySerialPort.writable);
    mySerialWriter = textEncoder.writable.getWriter();

  } catch (e) {
    myLog('Serial connect failed: ' + e.message);
  }
}

async function myDisconnectSerial() {
  myEspAutoCapture = false;
  if (myEspAutoTimer) { clearInterval(myEspAutoTimer); myEspAutoTimer = null; }
  document.getElementById('myEspAutoBtn').textContent = 'â–¶ Auto Capture';
  try {
    if (mySerialReader) { await mySerialReader.cancel(); mySerialReader = null; }
    if (mySerialWriter) { await mySerialWriter.close(); mySerialWriter = null; }
    if (mySerialPort) { await mySerialPort.close(); mySerialPort = null; }
  } catch(e) {}
  mySetSerialStatus(false);
  myLog('ESP32 Serial disconnected');
}

async function mySendSerialChar(c) {
  if (!mySerialWriter) { myLog('Not connected to ESP32'); return; }
  try {
    await mySerialWriter.write(c);
    mySerialLog(`â†’ Sent: "${c}"`);
  } catch(e) { myLog('Serial write error: ' + e.message); }
}

async function mySendSerial() {
  const cmd = document.getElementById('mySerialCmd').value.trim();
  if (cmd) { await mySendSerialChar(cmd[0]); }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Handle incoming serial data â€” parse text lines + JPEG frames
// ESP32 sends: "IMG_START\n" <jpeg bytes> "IMG_END\n"
// OR just text lines for Serial monitor
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function myHandleSerialData(chunk) {
  // We handle two modes: text lines and binary JPEG
  // Since WebSerial TextDecoder may corrupt binary, 
  // we provide text-only monitoring and a separate binary mode for images.
  // For image capture, user should use "Request Frame" which triggers
  // the ESP32 to send a JPEG in a base64-encoded line:
  // "FRAME_B64:<base64data>\n"
  
  mySerialBuffer += chunk;
  const lines = mySerialBuffer.split('\n');
  mySerialBuffer = lines.pop(); // keep incomplete line

  for (const line of lines) {
    const l = line.trim();
    if (!l) continue;

    // Check for base64 encoded frame
    if (l.startsWith('FRAME_B64:')) {
      const b64 = l.substring(10).trim();
      myDecodeBase64Frame(b64);
      continue;
    }

    // Normal serial output â†’ show in monitor
    mySerialLog(l.replace(/</g,'&lt;').replace(/>/g,'&gt;'));
  }
}

async function myDecodeBase64Frame(b64) {
  try {
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    const blob = new Blob([bytes], {type:'image/jpeg'});
    const url  = URL.createObjectURL(blob);
    const img  = new Image();
    img.onload = () => {
      const preview = document.getElementById('myEspPreview');
      const ctx = preview.getContext('2d');
      ctx.drawImage(img, 0, 0, preview.width, preview.height);
      URL.revokeObjectURL(url);

      // Store as ImageData for later use (add to class)
      const tmp = document.createElement('canvas');
      tmp.width = 240; tmp.height = 240;
      const tc = tmp.getContext('2d');
      tc.drawImage(img, 0, 0, 240, 240);
      myEspLastFrame = tc.getImageData(0, 0, 240, 240);
      mySerialLog('Frame received and displayed');

      // If auto-capture is on, also add to class
      if (myEspAutoCapture) myAddEspFrameToClass();
    };
    img.src = url;
  } catch(e) {
    mySerialLog('Frame decode error: ' + e.message);
  }
}

async function myRequestEspFrame() {
  // Send 'f' command to ESP32 to request a single frame as base64 JPEG
  // (This requires the ESP32 firmware to support 'f' command â€” 
  //  currently v57 doesn't have this, so we show a note)
  if (!mySerialWriter) {
    myLog('âš ï¸ Not connected to ESP32. Connect first.');
    return;
  }
  // Try sending 'f' â€” if ESP32 supports it, it will respond with FRAME_B64:...
  await mySendSerialChar('f');
  mySerialLog('â†’ Requested frame (ESP32 must support FRAME_B64 response)');
  myLog('Frame request sent. If ESP32 firmware v57 does not respond, the frame feature requires a firmware update to support the "f" command.');
}

function myToggleEspAuto() {
  myEspAutoCapture = !myEspAutoCapture;
  const btn = document.getElementById('myEspAutoBtn');
  if (myEspAutoCapture) {
    btn.textContent = 'â¹ Stop Auto';
    btn.classList.remove('btn-dark'); btn.classList.add('btn-red');
    myEspAutoTimer = setInterval(myRequestEspFrame, 1500);
    myLog('ESP32 auto capture started (every 1.5s)');
  } else {
    btn.textContent = 'â–¶ Auto Capture';
    btn.classList.remove('btn-red'); btn.classList.add('btn-dark');
    if (myEspAutoTimer) { clearInterval(myEspAutoTimer); myEspAutoTimer = null; }
    myLog('ESP32 auto capture stopped');
  }
}

async function myAddEspFrameToClass() {
  if (!myEspLastFrame) { myLog('No ESP32 frame available yet'); return; }
  if (!myModel) { myLog('âš ï¸ Start Camera & Brain first to initialise the model before adding ESP32 frames'); }

  const cls = parseInt(document.getElementById('myEspCaptureClass').value);

  // Store raw 240x240
  if (myRawData[cls].length >= myMaxBuffer) myRawData[cls].shift();
  myRawData[cls].push(myEspLastFrame);

  // Build tensor from ImageData
  const tmp = document.createElement('canvas');
  tmp.width = 240; tmp.height = 240;
  const tc = tmp.getContext('2d');
  tc.putImageData(myEspLastFrame, 0, 0);

  let tensor = tf.browser.fromPixels(tmp).resizeBilinear([myInputSize, myInputSize]);
  if (myIsGrayscaleMode) {
    const old = tensor;
    tensor = tf.tidy(() => {
      const r = old.slice([0,0,0],[myInputSize,myInputSize,1]);
      const g = old.slice([0,0,1],[myInputSize,myInputSize,1]);
      const b = old.slice([0,0,2],[myInputSize,myInputSize,1]);
      return r.mul(0.299).add(g.mul(0.587)).add(b.mul(0.114));
    });
    old.dispose();
  }
  const old2 = tensor;
  tensor = tensor.div(255.0).expandDims(0);
  old2.dispose();

  if (myTrainData[cls].length < myMaxBuffer) {
    myTrainData[cls].push(tensor);
  } else {
    myTrainData[cls][0].dispose(); myTrainData[cls].shift();
    myTrainData[cls].push(tensor);
  }
  document.getElementById('myCount'+cls).innerHTML = `${myTrainData[cls].length} samples`;
  myLog(`ESP32 frame â†’ Class ${cls} (${document.getElementById('myLabel'+cls).value}), total: ${myTrainData[cls].length}`);
  myUpdateEpochHint();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CAMERA
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function myCheckGrayscaleChange() {
  if (myModel) {
    alert('âš ï¸ Changing colour mode requires restarting.\nRefresh the page.');
    document.getElementById('myGrayscaleToggle').checked = myIsGrayscaleMode;
  } else if (document.getElementById('myGrayscaleToggle').checked) {
    myLog('Grayscale mode enabled. Recommend: 20+ samples/class, 80â€“100 batches, LR 0.002â€“0.003');
  }
}

function myStopAnalysis() {
  myAnalysisStopped = true;
  document.getElementById('myStopAnalysisBtn').style.display = 'none';
  document.getElementById('myStartAnalysisBtn').style.display = 'block';
  document.getElementById('myOutputDisplay').innerHTML = '<span style="color:var(--text2);">Analysis Stopped</span>';
  myLog('Analysis Stopped');
}

function myStartAnalysis() {
  myAnalysisStopped = false;
  document.getElementById('myStopAnalysisBtn').style.display = 'block';
  document.getElementById('myStartAnalysisBtn').style.display = 'none';
  document.getElementById('myOutputDisplay').innerHTML = 'Analyzingâ€¦';
  myLog('Analysis Started');
}

function myStopCamera() {
  const v = document.getElementById('myVideo1');
  if (v.srcObject) { v.srcObject.getTracks().forEach(t=>t.stop()); v.srcObject = null; }
  if (myGrayscaleRenderTimer) { clearInterval(myGrayscaleRenderTimer); myGrayscaleRenderTimer = null; }
  myCameraStopped = true;
  document.getElementById('myStartBtn').style.display = 'block';
  document.getElementById('myStopCameraBtn').style.display = 'none';
  myLog('Camera Stopped â€” training continues');
}

async function myStartAll() {
  const myVideo  = document.getElementById('myVideo1');
  const myCanvas = document.getElementById('myCanvas1');
  const myCtx    = myCanvas.getContext('2d');
  const sel      = document.getElementById('myCameraSelect');

  // Check if ESP32 camera selected
  if (sel.value === '__esp32serial__') {
    if (!mySerialConnected) {
      alert('âš ï¸ Connect to ESP32 via WebSerial first (Column 2), then select the ESP32 camera.');
      return;
    }
    // Hide regular video, show ESP32 preview
    myVideo.style.display  = 'none';
    myCanvas.style.display = 'none';
    document.getElementById('myEspPreview').style.height = '240px';
    myCameraStopped = false;
    document.getElementById('myStartBtn').style.display   = 'none';
    document.getElementById('myStopCameraBtn').style.display = 'block';
    myLog('ESP32 camera mode â€” use Request Frame / Auto Capture in column 2 to collect images');
  } else if (!myVideo.srcObject) {
    myCameraStopped = false;
    const deviceId = sel.value;
    myVideo.srcObject = await navigator.mediaDevices.getUserMedia({
      video: { width:240, height:240, deviceId: deviceId ? {exact:deviceId} : undefined }
    });
    myLog('Webcam started');
    document.getElementById('myStartBtn').style.display   = 'none';
    document.getElementById('myStopCameraBtn').style.display = 'block';
    myIsGrayscaleMode = document.getElementById('myGrayscaleToggle').checked;
    if (myIsGrayscaleMode) {
      myVideo.style.display  = 'none';
      myCanvas.style.display = 'block';
      if (myGrayscaleRenderTimer) clearInterval(myGrayscaleRenderTimer);
      myGrayscaleRenderTimer = setInterval(() => {
        myCtx.drawImage(myVideo, 0, 0, 240, 240);
        const imgData = myCtx.getImageData(0,0,240,240);
        const d = imgData.data;
        for (let i=0; i<d.length; i+=4) {
          const g = d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114;
          d[i]=d[i+1]=d[i+2]=g;
        }
        myCtx.putImageData(imgData,0,0);
      }, 33);
    } else {
      myVideo.style.display  = 'block';
      myCanvas.style.display = 'none';
    }
  }

  if (!myModel) {
    const inCh = myIsGrayscaleMode ? 1 : 3;
    const lr   = parseFloat(document.getElementById('myLearningRate').value) || 0.001;
    const drop = parseFloat(document.getElementById('myDropoutRate').value) || 0.3;

    document.getElementById('myResolutionSelect').disabled = true;
    document.getElementById('myResolutionCustom').disabled = true;
    myUpdateResolutionHint();

    myModel = tf.sequential();
    myModel.add(tf.layers.conv2d({ inputShape:[myInputSize,myInputSize,inCh], kernelSize:3, filters:4, activation:null,
      kernelRegularizer:tf.regularizers.l2({l2:0.0001}), biasInitializer:'zeros' }));
    myModel.add(tf.layers.leakyReLU({alpha:0.1}));
    myModel.add(tf.layers.maxPooling2d({poolSize:2, strides:2}));
    myModel.add(tf.layers.conv2d({ kernelSize:3, filters:8, activation:null,
      kernelRegularizer:tf.regularizers.l2({l2:0.0001}), biasInitializer:'zeros' }));
    myModel.add(tf.layers.leakyReLU({alpha:0.1}));
    myModel.add(tf.layers.flatten());
    myModel.add(tf.layers.dropout({rate:drop}));
    myModel.add(tf.layers.dense({ units:3, activation:'softmax',
      kernelInitializer:'heNormal', biasInitializer:'zeros' }));
    myModel.compile({ optimizer:tf.train.adam(lr), loss:'categoricalCrossentropy', metrics:['accuracy'] });
    const c2 = myGetConv2Out(myInputSize);
    myLog(`Brain: ${myInputSize}Ã—${myInputSize} ${myIsGrayscaleMode?'Grayscale':'RGB'} CNN | conv2 out: ${c2}Ã—${c2} | flat: ${c2*c2*8} | Drop: ${drop} LR: ${lr}`);
  }

  if (myTimer) clearInterval(myTimer);
  myTimer = setInterval(async () => {
    let myInput = null;
    // Only capture from webcam (not ESP32 â€” that's manual)
    if (!myCameraStopped && myVideo.srcObject && sel.value !== '__esp32serial__') {
      myInput = tf.browser.fromPixels(myVideo).resizeBilinear([myInputSize,myInputSize]);
      if (myIsGrayscaleMode) {
        const old = myInput;
        myInput = tf.tidy(() => {
          const r = old.slice([0,0,0],[myInputSize,myInputSize,1]);
          const g = old.slice([0,0,1],[myInputSize,myInputSize,1]);
          const b = old.slice([0,0,2],[myInputSize,myInputSize,1]);
          return r.mul(0.299).add(g.mul(0.587)).add(b.mul(0.114));
        });
        old.dispose();
      }
      const old2 = myInput;
      myInput = myInput.div(255.0).expandDims(0);
      old2.dispose();
    }

    const minSamples = parseInt(document.getElementById('myMinSamples').value) || 10;
    const counts = [myTrainData[0].length, myTrainData[1].length, myTrainData[2].length];
    const minCount = Math.min(...counts);
    const maxCount = Math.max(...counts);
    let batchSz = parseInt(document.getElementById('myBatchSize').value) || 6;
    if (batchSz < 3) batchSz = 3;
    if (batchSz % 3 !== 0) batchSz = Math.ceil(batchSz/3)*3;
    const samplesPerClass = batchSz / 3;
    const useAll = document.getElementById('myUseAllData').checked;
    let maxBatches = 0;
    if (useAll) {
      const ep = parseFloat(document.getElementById('myTargetEpochs').value) || 0;
      const total = counts.reduce((a,b)=>a+b,0);
      const bpe   = total > 0 ? Math.ceil(total/batchSz) : 1;
      maxBatches = ep > 0 ? Math.ceil(ep*bpe) : 0;
    } else {
      maxBatches = parseInt(document.getElementById('myMaxBatches').value) || 0;
    }
    const reachedLimit = maxBatches > 0 && myEpochCount >= maxBatches;

    if (minCount >= minSamples && !myTrainingPaused && !reachedLimit) {
      if (maxCount > minCount*2 && Math.random() < 0.01)
        myLog(`âš  Imbalanced data [${counts[0]}, ${counts[1]}, ${counts[2]}]`);

      let myBatch = [], myLabels = [];
      if (useAll) {
        if (myAllDataIndex === 0) {
          myCurrentEpoch++;
          myShuffledData = [];
          for (let cls=0; cls<3; cls++)
            for (let i=0; i<myTrainData[cls].length; i++)
              myShuffledData.push({sample:myTrainData[cls][i], label:cls});
          for (let i=myShuffledData.length-1; i>0; i--) {
            const j = Math.floor(Math.random()*(i+1));
            [myShuffledData[i],myShuffledData[j]] = [myShuffledData[j],myShuffledData[i]];
          }
          myLog(`Epoch ${myCurrentEpoch} start (${myShuffledData.length} samples)`);
        }
        for (let i=0; i<batchSz && myAllDataIndex<myShuffledData.length; i++) {
          const item = myShuffledData[myAllDataIndex];
          myBatch.push(Math.random()>0.5 ? myAugment(item.sample) : tf.clone(item.sample));
          myLabels.push(item.label===0?[1,0,0]:item.label===1?[0,1,0]:[0,0,1]);
          myAllDataIndex++;
        }
        if (myAllDataIndex >= myShuffledData.length) myAllDataIndex = 0;
      } else {
        for (let cls=0; cls<3; cls++)
          for (let i=0; i<samplesPerClass; i++) {
            const idx = Math.floor(Math.random()*myTrainData[cls].length);
            myBatch.push(Math.random()>0.5 ? myAugment(myTrainData[cls][idx]) : tf.clone(myTrainData[cls][idx]));
            myLabels.push(cls===0?[1,0,0]:cls===1?[0,1,0]:[0,0,1]);
          }
      }

      const bt = tf.concat(myBatch);
      const lt = tf.tensor2d(myLabels);
      let loss = 0;
      try {
        const r = await myModel.trainOnBatch(bt, lt);
        loss = Array.isArray(r) ? r[0] : r;
        if (isNaN(loss)||!isFinite(loss)) { myLog('âš  Invalid loss, skipping'); loss=0; }
      } catch(e) { myLog('Training error: '+e.message); loss=0; }
      bt.dispose(); lt.dispose();
      myBatch.forEach(t => {
        let stored = false;
        for (let c=0; c<3; c++) if (myTrainData[c].includes(t)) { stored=true; break; }
        if (!stored) t.dispose();
      });
      myEpochCount++;
      if (loss>0) { myLossSum+=loss; myLossCount++; }

      if (myEpochCount % 10 === 0) {
        const avg = myLossCount>0 ? myLossSum/myLossCount : 0;
        if (avg>0&&isFinite(avg)) myLossHistory.push(avg);
        if (myLossHistory.length>20) myLossHistory.shift();
        const recAvg = myLossHistory.length>0 ? myLossHistory.reduce((a,b)=>a+b,0)/myLossHistory.length : 0;
        document.getElementById('myEpochDisplay').innerText = myEpochCount;
        document.getElementById('myLossDisplay').innerText  = myLossHistory.length>0 ? recAvg.toFixed(4) : '--';
        let status='', color='', pct=0;
        if (!myLossHistory.length)  { status='Initializingâ€¦'; color='#94a3b8'; pct=5; }
        else if (recAvg>1.0)        { status='Startingâ€¦';     color='#ef4444'; pct=10; }
        else if (recAvg>0.5)        { status='Trainingâ€¦';     color='#f59e0b'; pct=30; }
        else if (recAvg>0.2)        { status='Improvingâ€¦';    color='#eab308'; pct=60; }
        else if (recAvg>0.1)        { status='Convergingâ€¦';   color='#84cc16'; pct=80; }
        else                        { status='Well Trained âœ“'; color='#22c55e'; pct=100; }
        document.getElementById('myStatusDisplay').innerText     = status;
        document.getElementById('myStatusDisplay').style.color   = color;
        document.getElementById('myProgressBar').style.width     = pct+'%';
        document.getElementById('myPauseBtn').disabled = false;
        myLossSum = 0; myLossCount = 0;
      }
    } else if (reachedLimit) {
      if (!myTrainingPaused) {
        myPauseTraining();
        myLog(`Training complete â€” reached target`);
      }
      document.getElementById('myStatusDisplay').innerText   = `Completed (${myEpochCount} batches)`;
      document.getElementById('myStatusDisplay').style.color = '#22c55e';
    } else {
      if (myTrainingPaused) {
        document.getElementById('myStatusDisplay').innerText   = 'Paused';
        document.getElementById('myStatusDisplay').style.color = '#f59e0b';
      } else {
        const need = counts.map(c => Math.max(0, minSamples-c));
        document.getElementById('myStatusDisplay').innerText   = `Waiting (need: ${need[0]}, ${need[1]}, ${need[2]})`;
        document.getElementById('myStatusDisplay').style.color = '#64748b';
      }
    }

    if (myInput && !myAnalysisStopped) {
      document.getElementById('myStopAnalysisBtn').disabled = false;
      const pred  = myModel.predict(myInput);
      const probs = await pred.data();
      const id    = (await pred.argMax(1).data())[0];
      const pcts  = [0,1,2].map(i => (probs[i]*100).toFixed(1));
      const max   = Math.max(...probs)*100;
      const c     = max>80?'#22c55e':max>50?'#f59e0b':'#ef4444';
      const warn  = max<50 ? '<br><span style="color:#ef4444; font-size:0.8em;">âš  Low confidence</span>' : '';
      const labels = myGetLabels();
      document.getElementById('myOutputDisplay').innerHTML =
        `<div style="font-weight:700; margin-bottom:6px;">DETECTED: <span style="color:${c}">${labels[id]}</span></div>` +
        `<div style="font-family:var(--mono); font-size:0.82em; line-height:1.8;">` +
        [0,1,2].map(i => `${labels[i]}: <b style="color:${id===i?'#22c55e':'#64748b'}">${pcts[i]}%</b>`).join('<br>') +
        `</div>` + warn;
      pred.dispose();
    } else if (myCameraStopped || sel.value==='__esp32serial__') {
      document.getElementById('myOutputDisplay').innerHTML = '<span style="color:var(--text2);">Camera Stopped â€” training continuesâ€¦</span>';
    }
    if (myInput) myInput.dispose();
  }, 150);
}

function myPauseTraining() {
  myTrainingPaused = true;
  document.getElementById('myPauseBtn').style.display  = 'none';
  document.getElementById('myResumeBtn').style.display = 'block';
  myLog('Training Paused â€” safe to export model');
}

function myResumeTraining() {
  myTrainingPaused = false;
  document.getElementById('myPauseBtn').style.display  = 'block';
  document.getElementById('myResumeBtn').style.display = 'none';
  myLog('Training Resumed');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DEBUG
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function myDebugCurrentFrame() {
  const v = document.getElementById('myVideo1');
  if ((!v.srcObject || myCameraStopped) && !myEspLastFrame) { myLog('ERROR: No camera source running'); return; }
  if (!myModel) { myLog('ERROR: Model not initialised'); return; }
  myLog('========== WEB DEBUG ==========');
  let myInput;
  if (myEspLastFrame) {
    const tmp = document.createElement('canvas'); tmp.width=240; tmp.height=240;
    tmp.getContext('2d').putImageData(myEspLastFrame,0,0);
    myInput = tf.browser.fromPixels(tmp).resizeBilinear([myInputSize,myInputSize]);
  } else {
    myInput = tf.browser.fromPixels(v).resizeBilinear([myInputSize,myInputSize]);
  }
  if (myIsGrayscaleMode) {
    const old=myInput;
    myInput = tf.tidy(() => {
      const r=old.slice([0,0,0],[myInputSize,myInputSize,1]);
      const g=old.slice([0,0,1],[myInputSize,myInputSize,1]);
      const b=old.slice([0,0,2],[myInputSize,myInputSize,1]);
      return r.mul(0.299).add(g.mul(0.587)).add(b.mul(0.114));
    });
    old.dispose();
  }
  const old2=myInput; myInput=myInput.div(255.0).expandDims(0); old2.dispose();
  const pred = myModel.predict(myInput);
  const probs = await pred.data();
  myLog(`Probs: [${[0,1,2].map(i=>(probs[i]*100).toFixed(1)+'%').join(', ')}]`);
  myLog('========== END DEBUG ==========');
  myInput.dispose(); pred.dispose();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// COLLECT / LOAD / SAVE / CLEAR IMAGES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function myCollect(myID) {
  const v = document.getElementById('myVideo1');
  if (!v.srcObject || myCameraStopped) { myLog('ERROR: Camera not running'); return; }
  myRawCtx.drawImage(v, 0, 0, 240, 240);
  const raw = myRawCtx.getImageData(0,0,240,240);
  if (myRawData[myID].length >= myMaxBuffer) myRawData[myID].shift();
  myRawData[myID].push(raw);
  let t = tf.browser.fromPixels(v).resizeBilinear([myInputSize,myInputSize]);
  if (myIsGrayscaleMode) {
    const old=t;
    t = tf.tidy(() => { const r=old.slice([0,0,0],[myInputSize,myInputSize,1]); const g=old.slice([0,0,1],[myInputSize,myInputSize,1]); const b=old.slice([0,0,2],[myInputSize,myInputSize,1]); return r.mul(0.299).add(g.mul(0.587)).add(b.mul(0.114)); });
    old.dispose();
  }
  const old2=t; t=t.div(255.0).expandDims(0); old2.dispose();
  const data=t.dataSync();
  for (let i=0;i<data.length;i++) if (isNaN(data[i])||!isFinite(data[i])) { myLog('Bad frame, skipping'); t.dispose(); return; }
  if (myTrainData[myID].length < myMaxBuffer) { myTrainData[myID].push(t); }
  else { myTrainData[myID][0].dispose(); myTrainData[myID].shift(); myTrainData[myID].push(t); }
  document.getElementById('myCount'+myID).innerHTML = `${myTrainData[myID].length} samples`;
  myLog(`Class ${myID} captured (total: ${myTrainData[myID].length})`);
  myUpdateEpochHint();
}

function myLoadImages(myID) {
  const inp = document.createElement('input'); inp.type='file'; inp.multiple=true; inp.accept='image/*';
  inp.onchange = async (e) => {
    const files = Array.from(e.target.files);
    myLog(`Loading ${files.length} images for Class ${myID}â€¦`);
    let loaded = 0;
    const lc = document.createElement('canvas'); lc.width=240; lc.height=240;
    const lctx = lc.getContext('2d');
    for (const file of files) {
      try {
        const img = new Image();
        const url = URL.createObjectURL(file);
        await new Promise((res,rej) => {
          img.onload = () => {
            lctx.drawImage(img,0,0,240,240);
            const raw = lctx.getImageData(0,0,240,240);
            if (myRawData[myID].length>=myMaxBuffer) myRawData[myID].shift();
            myRawData[myID].push(raw);
            let t = tf.browser.fromPixels(img).resizeBilinear([myInputSize,myInputSize]);
            if (myIsGrayscaleMode) {
              const old=t; t=tf.tidy(()=>{ const r=old.slice([0,0,0],[myInputSize,myInputSize,1]); const g=old.slice([0,0,1],[myInputSize,myInputSize,1]); const b=old.slice([0,0,2],[myInputSize,myInputSize,1]); return r.mul(0.299).add(g.mul(0.587)).add(b.mul(0.114)); }); old.dispose();
            }
            const old2=t; t=t.div(255.0).expandDims(0); old2.dispose();
            if (myTrainData[myID].length<myMaxBuffer) myTrainData[myID].push(t);
            else { myTrainData[myID][0].dispose(); myTrainData[myID].shift(); myTrainData[myID].push(t); }
            loaded++;
            URL.revokeObjectURL(url); res();
          };
          img.onerror=()=>{ URL.revokeObjectURL(url); rej(); };
          img.src=url;
        });
      } catch(e) {}
    }
    document.getElementById('myCount'+myID).innerHTML = `${myTrainData[myID].length} samples`;
    myLog(`Class ${myID}: loaded ${loaded}/${files.length} (total: ${myTrainData[myID].length})`);
    myUpdateEpochHint();
  };
  inp.click();
}

function myClearImages(myID) {
  if (!myTrainData[myID].length) { myLog(`Class ${myID}: already empty`); return; }
  myTrainData[myID].forEach(t=>t.dispose()); myTrainData[myID]=[];
  myRawData[myID]=[];
  document.getElementById('myCount'+myID).innerHTML='0 samples';
  myLog(`Class ${myID}: cleared`);
  myUpdateEpochHint();
}

async function mySaveImages(myID) {
  const label = myGetLabels()[myID];
  if (typeof JSZip==='undefined') { myLog('ERROR: JSZip not loaded'); return; }
  const useRaw = myRawData[myID].length>0;
  const cnt = useRaw ? myRawData[myID].length : myTrainData[myID].length;
  if (!cnt) { myLog(`Class ${myID}: no images`); return; }
  myLog(`Class ${myID}: saving ${cnt} imagesâ€¦`);
  const zip = new JSZip();
  const folder = zip.folder(label);
  const ex = document.createElement('canvas'); ex.width=240; ex.height=240;
  const exc = ex.getContext('2d');
  let conv = 0;
  for (let i=0;i<cnt;i++) {
    try {
      if (useRaw) exc.putImageData(myRawData[myID][i],0,0);
      else {
        const t=myTrainData[myID][i].squeeze([0]);
        const sh=t.shape; const h=sh[0],w=sh[1],ch=sh[2]||1;
        const px=await tf.tidy(()=>t.mul(255).clipByValue(0,255).cast('int32')).data();
        t.dispose();
        const tmp=document.createElement('canvas'); tmp.width=w; tmp.height=h;
        const tc=tmp.getContext('2d'); const id=tc.createImageData(w,h);
        for (let py=0;py<h;py++) for (let px2=0;px2<w;px2++) {
          const si=(py*w+px2)*ch,di=(py*w+px2)*4;
          id.data[di]=ch===1?px[si]:px[si]; id.data[di+1]=ch===1?px[si]:px[si+1]; id.data[di+2]=ch===1?px[si]:px[si+2]; id.data[di+3]=255;
        }
        tc.putImageData(id,0,0); exc.imageSmoothingEnabled=false; exc.drawImage(tmp,0,0,240,240);
      }
      const blob=await new Promise(r=>ex.toBlob(r,'image/jpeg',0.92));
      folder.file(`img_${String(i+1).padStart(4,'0')}.jpg`,blob); conv++;
    } catch(e) { myLog(`Skip img ${i+1}: ${e.message}`); }
  }
  if (!conv) { myLog('Nothing converted'); return; }
  const zblob=await zip.generateAsync({type:'blob',compression:'STORE'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(zblob); a.download=`${label}_images.zip`;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  myLog(`âœ“ ${label}_images.zip (${conv} images) â€” copy folder to SD /images/${label}/`);
}

async function mySaveAllImages() {
  if (typeof JSZip==='undefined') { myLog('ERROR: JSZip not loaded'); return; }
  const labels=myGetLabels();
  const total=[0,1,2].reduce((s,i)=>s+(myRawData[i].length||myTrainData[i].length),0);
  if (!total) { myLog('No images collected'); return; }
  const zip=new JSZip();
  const ex=document.createElement('canvas'); ex.width=240; ex.height=240;
  const exc=ex.getContext('2d');
  let grand=0;
  for (const id of [0,1,2]) {
    const lbl=labels[id], useRaw=myRawData[id].length>0;
    const cnt=useRaw?myRawData[id].length:myTrainData[id].length;
    if (!cnt) { myLog(`Class ${id}: 0 â€” skipped`); continue; }
    const folder=zip.folder(lbl); let conv=0;
    for (let i=0;i<cnt;i++) {
      try {
        if (useRaw) exc.putImageData(myRawData[id][i],0,0);
        else {
          const t=myTrainData[id][i].squeeze([0]);
          const sh=t.shape; const h=sh[0],w=sh[1],ch=sh[2]||1;
          const px=await tf.tidy(()=>t.mul(255).clipByValue(0,255).cast('int32')).data();
          t.dispose();
          const tmp=document.createElement('canvas'); tmp.width=w; tmp.height=h;
          const tc=tmp.getContext('2d'); const imgd=tc.createImageData(w,h);
          for (let py=0;py<h;py++) for (let px2=0;px2<w;px2++) {
            const si=(py*w+px2)*ch,di=(py*w+px2)*4;
            imgd.data[di]=ch===1?px[si]:px[si]; imgd.data[di+1]=ch===1?px[si]:px[si+1]; imgd.data[di+2]=ch===1?px[si]:px[si+2]; imgd.data[di+3]=255;
          }
          tc.putImageData(imgd,0,0); exc.imageSmoothingEnabled=false; exc.drawImage(tmp,0,0,240,240);
        }
        const blob=await new Promise(r=>ex.toBlob(r,'image/jpeg',0.92));
        folder.file(`img_${String(i+1).padStart(4,'0')}.jpg`,blob); conv++;
      } catch(e) { myLog(`Skip cls ${id} img ${i+1}: ${e.message}`); }
    }
    myLog(`  Class ${id} (${lbl}): ${conv} images`); grand+=conv;
  }
  if (!grand) { myLog('Nothing to save'); return; }
  const zblob=await zip.generateAsync({type:'blob',compression:'STORE'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(zblob); a.download='images.zip';
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  myLog(`âœ“ images.zip â€” ${grand} images â€” unzip and copy folders to SD /images/`);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MODEL SAVE / LOAD (TFJS)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function mySaveModel() {
  if (!myModel) { myLog('No model yet'); return; }
  await myModel.save('downloads://my-tfjs-model');
  myLog('TFJS model saved');
}

async function myLoadModel() {
  const inp=document.createElement('input'); inp.type='file'; inp.multiple=true;
  inp.onchange=async(e)=>{ myModel=await tf.loadLayersModel(tf.io.browserFiles(e.target.files)); myLog('TFJS model loaded'); };
  inp.click();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// LABELS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function myGetLabels() {
  return [
    document.getElementById('myLabel0').value || '0Blank',
    document.getElementById('myLabel1').value || '1Circle',
    document.getElementById('myLabel2').value || '2Square'
  ];
}

function toCString(s) {
  return s.substring(0,20).replace(/\\/g,'\\\\').replace(/"/g,'\\"').replace(/\n/g,'\\n');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONFIG.JSON â€” build, refresh textarea, direct download
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function myBuildConfigObj() {
  const labels = myGetLabels();
  const version = parseInt(document.getElementById('myBinVersion').value) || 50;
  const lr      = parseFloat(document.getElementById('myLearningRate').value) || 0.00005;
  const bs      = parseInt(document.getElementById('myBatchSize').value) || 12;
  const ep      = parseFloat(document.getElementById('myTargetEpochs').value) || 10;
  const useAug  = document.getElementById('myExportAugmentation').checked;
  const useGray = document.getElementById('myExportGrayscale').checked;
  const toPsram = document.getElementById('myExportImagesToPsram').checked;
  const valImgs = parseInt(document.getElementById('myExportValidationImages').value) || 3;
  return {
    version:          version,
    minVersion:       version,
    inputSize:        myInputSize,
    numClasses:       3,
    conv1Filters:     4,
    conv2Filters:     8,
    learningRate:     lr,
    batchSize:        bs,
    targetEpochs:     Math.ceil(ep),
    thresholdPress:   1100,
    thresholdRelease: 900,
    screenTimeout:    300000,
    weightsFile:      "myWeights.bin",
    useAugmentation:  useAug,
    useGrayscale:     useGray,
    imagesToPsram:    toPsram,
    validationImages: valImgs,
    numLabels:        3,
    classLabels:      labels
  };
}

function myRefreshConfigTextarea() {
  const ta = document.getElementById('myConfigTextarea');
  if (ta) ta.value = JSON.stringify(myBuildConfigObj(), null, 2);
}

async function myExportConfigJson() {
  const ta = document.getElementById('myConfigTextarea');
  const jsonText = ta ? ta.value : JSON.stringify(myBuildConfigObj(), null, 2);
  try { JSON.parse(jsonText); }
  catch(e) {
    myLog('ERROR: Invalid JSON in config textarea â€” ' + e.message);
    alert('âš ï¸ Invalid JSON in config.json textarea.\n\nError: ' + e.message);
    return;
  }
  // Direct download â€” no zip needed
  const blob = new Blob([jsonText], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'config.json';
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  URL.revokeObjectURL(a.href);
  const cfg = JSON.parse(jsonText);
  myLog(`âœ“ config.json saved directly to Downloads`);
  myLog(`  â†’ Copy to SD card: /header/config.json`);
  myLog(`  version=${cfg.version} | useGrayscale=${cfg.useGrayscale} | imagesToPsram=${cfg.imagesToPsram} | validationImages=${cfg.validationImages}`);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// myWeights.bin EXPORT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function myTransposeConvWeights(data, ky, kx, inCh, outCh) {
  const out=new Float32Array(data.length);
  for (let f=0;f<outCh;f++) for (let r=0;r<ky;r++) for (let c=0;c<kx;c++) for (let ic=0;ic<inCh;ic++) {
    const si=r*kx*inCh*outCh+c*inCh*outCh+ic*outCh+f;
    const di=f*ky*kx*inCh+r*kx*inCh+c*inCh+ic;
    out[di]=data[si];
  }
  return out;
}

function myTransposeDenseWeights(data, outH, outW, numFilters, numClasses) {
  const flatSize=outH*outW*numFilters;
  const out=new Float32Array(data.length);
  for (let cls=0;cls<numClasses;cls++) for (let f=0;f<numFilters;f++) for (let y=0;y<outH;y++) for (let x=0;x<outW;x++) {
    const flatCL=y*outW*numFilters+x*numFilters+f;
    const flatCF=f*outH*outW+y*outW+x;
    out[cls*flatSize+flatCF]=data[flatCL*numClasses+cls];
  }
  return out;
}

async function myGetWeightLayers() {
  if (!myModel) { myLog('ERROR: No model to export'); return null; }
  const wl = myModel.layers.filter(l=>l.getWeights().length>0);
  if (wl.length<3) { myLog('ERROR: Expected 3 weight layers, found '+wl.length); return null; }
  const [conv1L,conv2L,denseL] = wl;
  const [c1w,c1b] = conv1L.getWeights();
  const [c2w,c2b] = conv2L.getWeights();
  const [dw,db]   = denseL.getWeights();
  const inCh = myIsGrayscaleMode ? 1 : 3;
  const c2out = myGetConv2Out(myInputSize);
  return {
    conv1W: myTransposeConvWeights(await c1w.data(), 3, 3, inCh, 4),
    conv1B: new Float32Array(await c1b.data()),
    conv2W: myTransposeConvWeights(await c2w.data(), 3, 3, 4, 8),
    conv2B: new Float32Array(await c2b.data()),
    denseW: myTransposeDenseWeights(await dw.data(), c2out, c2out, 8, 3),
    denseB: new Float32Array(await db.data())
  };
}

async function myExportBin() {
  const weights = await myGetWeightLayers();
  if (!weights) return;
  const labels  = myGetLabels();
  const version = parseInt(document.getElementById('myBinVersion').value) || 50;
  const inCh    = myIsGrayscaleMode ? 1 : 3;

  // Build header matching v57 format exactly
  const headerObj = {
    version:       version,
    inputSize:     myInputSize,
    numClasses:    3,
    conv1Filters:  4,
    conv2Filters:  8,
    inputChannels: inCh,
    quantization:  "float32",
    labels:        labels
  };
  const headerText =
    "--- WEIGHTS HEADER BEGIN ---\n" +
    JSON.stringify(headerObj) + "\n" +
    "--- WEIGHTS HEADER END ---\n\n";

  const enc  = new TextEncoder();
  const hdr  = enc.encode(headerText);
  const nf   = weights.conv1W.length + weights.conv1B.length +
               weights.conv2W.length + weights.conv2B.length +
               weights.denseW.length + weights.denseB.length;
  const bin  = new Uint8Array(nf*4);
  const dv   = new DataView(bin.buffer);
  let off = 0;
  const wf = arr => { for (const v of arr) { dv.setFloat32(off,v,true); off+=4; } };
  wf(weights.conv1W); wf(weights.conv1B);
  wf(weights.conv2W); wf(weights.conv2B);
  wf(weights.denseW); wf(weights.denseB);

  const blob = new Blob([hdr,bin], {type:'application/octet-stream'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'myWeights.bin';
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  URL.revokeObjectURL(a.href);
  myLog(`âœ“ myWeights.bin exported â€” version=${version} | channels=${inCh} | labels=[${labels.join(', ')}]`);
  myLog(`  â†’ Copy to SD card: /header/myWeights.bin`);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HEADER FILE EXPORT (legacy .h â€” still useful for older firmware)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function myExportHeader() {
  if (!myModel) { myLog('Error: no model to export'); return; }
  const isInt8 = document.getElementById('myInt8Toggle').checked;
  const isGray = document.getElementById('myGrayscaleToggle').checked;
  if (isGray && !myIsGrayscaleMode) {
    alert('âš ï¸ Model was trained in RGB mode. Export as RGB or retrain in grayscale.');
    document.getElementById('myGrayscaleToggle').checked=false; return;
  }
  myLog(`Generating ${isInt8?'Int8':'Float32'} ${isGray?'Grayscale':'RGB'} headerâ€¦`);
  const [l0,l1,l2] = myGetLabels().map(toCString);
  let txt = `// Overflow-Protected 2-Layer CNN Model with Labels\n#ifndef MY_MODEL_H\n#define MY_MODEL_H\n\n`;
  txt += `const char* myClassLabels[3] = {\n  "${l0}",\n  "${l1}",\n  "${l2}"\n};\n\n`;
  if (isInt8) txt += `#define USE_INT8_MODE\n`;
  if (isGray) txt += `#define USE_GRAYSCALE_MODE\n`;
  txt += `\n`;
  const names = ["myConv1_w","myConv1_b","myConv2_w","myConv2_b","myOutput_w","myOutput_b"];
  let ni = 0;
  for (const l of myModel.layers) {
    if (!l.getWeights().length) continue;
    for (const w of l.getWeights()) {
      let d = Array.from(await w.data());
      const maxAbs = Math.max(...d.map(Math.abs));
      if (maxAbs>10) { myLog(`WARNING: large weights (${maxAbs.toFixed(2)}), clipping`); d=d.map(v=>Math.max(-10,Math.min(10,v))); }
      if (isInt8) {
        const scale = 127/(maxAbs||1);
        txt += `const float ${names[ni]}_scale = ${scale.toFixed(6)}f;\n`;
        txt += `const int8_t ${names[ni]}[] = { ${d.map(v=>Math.round(v*scale)).join(', ')} };\n\n`;
      } else {
        txt += `const float ${names[ni]}[] = { ${d.map(v=>v.toFixed(6)).join(', ')} };\n\n`;
      }
      ni++;
    }
  }
  txt += `#endif`;
  const a=document.createElement('a');
  a.href=URL.createObjectURL(new Blob([txt]));
  a.download=(document.getElementById('myExportName').value||'myModel')+'.h';
  a.click();
  myLog(`âœ“ Header exported: ${a.download}`);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOURCE CODE EDITOR
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let myEditorOpen = false;
function myToggleEditor() {
  const ta = document.getElementById('myTextarea1');
  const btn = document.getElementById('myUpdateBtn');
  if (!myEditorOpen) {
    ta.value = document.getElementById('myCodeSpace').innerHTML;
    ta.rows = 30;
    ta.style.display = 'block';
    btn.style.display = 'inline-block';
    myEditorOpen = true;
  } else {
    ta.style.display = 'none';
    btn.style.display = 'none';
    myEditorOpen = false;
  }
}
function myApplyAndRun() {
  document.getElementById('myCodeSpace').innerHTML = document.getElementById('myTextarea1').value;
  myLog('Code updated & restartingâ€¦');
  myStartAll();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INIT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(async function init() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const sel = document.getElementById('myCameraSelect');
  devices.filter(d=>d.kind==='videoinput').forEach((d,i) => {
    const o = document.createElement('option');
    o.value = d.deviceId;
    o.text  = d.label || `Camera ${i+1}`;
    sel.appendChild(o);
  });
  myUpdateResolutionHint();
  myRefreshConfigTextarea();

  // Keep config textarea live on label/param changes
  ['myLabel0','myLabel1','myLabel2','myLearningRate','myBatchSize','myTargetEpochs',
   'myExportValidationImages'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('input', myRefreshConfigTextarea);
  });

  // Check WebSerial availability
  if (!('serial' in navigator)) {
    const notice = document.getElementById('mySerialStatus');
    notice.textContent = 'âš ï¸ WebSerial not supported (use Chrome/Edge)';
    notice.className = 'serial-disconnected';
  }
})();
</script>
</body>
</html>
