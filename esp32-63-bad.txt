#include "esp_camera.h"
#include "img_converters.h"
#include "myModel.h" 

// --- 1. CONFIGURATION & BUFFERS ---
#ifdef USE_GRAYSCALE_MODE
  float myInputBuffer[64 * 64];
#else
  float myInputBuffer[64 * 64 * 3];
#endif

float myConv1Output[62 * 62 * 4];
float myPool1Output[31 * 31 * 4];
float myConv2Output[29 * 29 * 8];

// OVERFLOW PROTECTION
inline float clipValue(float val, float minVal = -100.0f, float maxVal = 100.0f) {
    if (isnan(val) || isinf(val)) return 0.0f;
    if (val < minVal) return minVal;
    if (val > maxVal) return maxVal;
    return val;
}

#ifdef USE_INT8_MODE
  #define GET_W(arr, idx, scale) ((float)arr[idx] / scale)
#else
  #define GET_W(arr, idx, scale) (arr[idx])
  float myConv1_w_scale=1, myConv1_b_scale=1;
  float myConv2_w_scale=1, myConv2_b_scale=1;
  float myOutput_w_scale=1, myOutput_b_scale=1;
#endif

// Camera Pins (XIAO ESP32S3 Sense)
#define XCLK_GPIO_NUM 10
#define SIOD_GPIO_NUM 40
#define SIOC_GPIO_NUM 39
#define Y9_GPIO_NUM   48
#define Y8_GPIO_NUM   11
#define Y7_GPIO_NUM   12
#define Y6_GPIO_NUM   14
#define Y5_GPIO_NUM   16
#define Y4_GPIO_NUM   18
#define Y3_GPIO_NUM   17
#define Y2_GPIO_NUM   15
#define VSYNC_GPIO_NUM 38
#define HREF_GPIO_NUM  47
#define PCLK_GPIO_NUM  13

// --- 2. CONV1 (UNCHANGED) ---
void myConv1() {
    for (int f = 0; f < 4; f++) {
        int outBase = f * 3844;
        for (int y = 0; y < 62; y++) {
            for (int x = 0; x < 62; x++) {
                float sum = 0;

#ifdef USE_GRAYSCALE_MODE
                for (int ky = 0; ky < 3; ky++)
                    for (int kx = 0; kx < 3; kx++)
                        sum += myInputBuffer[(y+ky)*64 + (x+kx)] *
                               GET_W(myConv1_w, (f*9)+(ky*3)+kx, myConv1_w_scale);
#else
                for (int ky = 0; ky < 3; ky++)
                    for (int kx = 0; kx < 3; kx++) {
                        int p = ((y+ky)*64 + (x+kx))*3;
                        int w = (f*27)+(ky*9)+(kx*3);
                        sum += myInputBuffer[p]   * GET_W(myConv1_w, w,   myConv1_w_scale);
                        sum += myInputBuffer[p+1] * GET_W(myConv1_w, w+1, myConv1_w_scale);
                        sum += myInputBuffer[p+2] * GET_W(myConv1_w, w+2, myConv1_w_scale);
                    }
#endif
                sum += GET_W(myConv1_b, f, myConv1_b_scale);
                sum = clipValue(sum);
                myConv1Output[outBase + y*62 + x] = (sum > 0) ? sum : 0;
            }
        }
    }
}

// --- 3. MAXPOOL (UNCHANGED) ---
void myMaxPool1() {
    for (int f = 0; f < 4; f++) {
        int inBase = f * 3844;
        int outBase = f * 961;
        for (int y = 0; y < 31; y++)
            for (int x = 0; x < 31; x++) {
                int iy=y*2, ix=x*2;
                float m = myConv1Output[inBase + iy*62 + ix];
                m = max(m, myConv1Output[inBase + iy*62 + ix+1]);
                m = max(m, myConv1Output[inBase + (iy+1)*62 + ix]);
                m = max(m, myConv1Output[inBase + (iy+1)*62 + ix+1]);
                myPool1Output[outBase + y*31 + x] = m;
            }
    }
}

// --- 4. CONV2 (ONLY CHANGE: LeakyReLU) ---
void myConv2() {
    for (int f = 0; f < 8; f++) {
        int outBase = f * 841;
        for (int y = 0; y < 29; y++) {
            for (int x = 0; x < 29; x++) {
                float sum = 0;
                for (int c = 0; c < 4; c++) {
                    int inBase = c * 961;
                    for (int ky = 0; ky < 3; ky++)
                        for (int kx = 0; kx < 3; kx++)
                            sum += myPool1Output[inBase + (y+ky)*31 + (x+kx)] *
                                   GET_W(myConv2_w, (f*36)+(c*9)+(ky*3)+kx, myConv2_w_scale);
                }
                sum += GET_W(myConv2_b, f, myConv2_b_scale);
                sum = clipValue(sum);

                // ðŸ”¹ CHANGE #2: LeakyReLU (single line behavioral change)
                myConv2Output[outBase + y*29 + x] =
                    (sum > 0) ? sum : (0.1f * sum);
            }
        }
    }
}

// --- 5. DENSE (UNCHANGED) ---
int myGetWinner() {
    float myLogits[3] = {0,0,0};
    int total = 29*29*8;

    for (int i = 0; i < 3; i++) {
        double sum=0, c=0;
        for (int j = 0; j < total; j++) {
            double term = (double)myConv2Output[j] *
                          GET_W(myOutput_w, i*total+j, myOutput_w_scale);
            double y = term - c;
            double t = sum + y;
            c = (t - sum) - y;
            sum = t;
        }
        myLogits[i] = clipValue(sum + GET_W(myOutput_b, i, myOutput_b_scale), -50, 50);
    }

    int win = (myLogits[1] > myLogits[0]) ? 1 : 0;
    if (myLogits[2] > myLogits[win]) win = 2;
    return win;
}

// --- 6. IMAGE PROCESSING (ONLY CHANGE: GRAYSCALE NORMALIZATION) ---
void myProcessCamera(camera_fb_t *fb) {
    uint8_t *rgb = (uint8_t *)ps_malloc(fb->width * fb->height * 3);
    if (!rgb) return;
    if (!fmt2rgb888(fb->buf, fb->len, fb->format, rgb)) { free(rgb); return; }

    float sy=(float)fb->height/64, sx=(float)fb->width/64;

    for (int y=0;y<64;y++)
        for (int x=0;x<64;x++) {
            int py=(int)((y+0.5f)*sy);
            int px=(int)((x+0.5f)*sx);
            int idx=(py*fb->width+px)*3;
            float r=rgb[idx], g=rgb[idx+1], b=rgb[idx+2];

#ifdef USE_GRAYSCALE_MODE
            float gray = (r*0.299f)+(g*0.587f)+(b*0.114f);
            float norm = (gray - 127.5f) / 127.5f;   // ðŸ”¹ CHANGE #1
            myInputBuffer[y*64+x] = norm;
#else
            int o=(y*64+x)*3;
            myInputBuffer[o]=r/255.0f;
            myInputBuffer[o+1]=g/255.0f;
            myInputBuffer[o+2]=b/255.0f;
#endif
        }
    free(rgb);
}

// --- SETUP (UNCHANGED) ---
void setup() {
    Serial.begin(115200);

    camera_config_t config;
    config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = Y2_GPIO_NUM; config.pin_d1 = Y3_GPIO_NUM;
    config.pin_d2 = Y4_GPIO_NUM; config.pin_d3 = Y5_GPIO_NUM;
    config.pin_d4 = Y6_GPIO_NUM; config.pin_d5 = Y7_GPIO_NUM;
    config.pin_d6 = Y8_GPIO_NUM; config.pin_d7 = Y9_GPIO_NUM;
    config.pin_xclk = XCLK_GPIO_NUM;
    config.pin_pclk = PCLK_GPIO_NUM;
    config.pin_vsync = VSYNC_GPIO_NUM;
    config.pin_href = HREF_GPIO_NUM;
    config.pin_sscb_sda = SIOD_GPIO_NUM;
    config.pin_sscb_scl = SIOC_GPIO_NUM;
    config.pin_pwdn = -1;
    config.pin_reset = -1;
    config.xclk_freq_hz = 10000000;
    config.frame_size = FRAMESIZE_QVGA;
    config.pixel_format = PIXFORMAT_JPEG;
    config.grab_mode = CAMERA_GRAB_LATEST;
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.fb_count = 1;
    config.jpeg_quality = 12;

    esp_camera_init(&config);
}

// --- LOOP (UNCHANGED + A0 DEBUG ONLY) ---
void loop() {
    camera_fb_t *fb = esp_camera_fb_get();
    if (!fb) return;

    myProcessCamera(fb);
    esp_camera_fb_return(fb);

    myConv1();
    myMaxPool1();
    myConv2();

    if (analogRead(A0) > 2000) {
        int zeroCount = 0;
        for (int i = 0; i < 29*29*8; i++)
            if (myConv2Output[i] == 0.0f) zeroCount++;

        Serial.print("Conv2 zero rate: ");
        Serial.print((zeroCount * 100) / (29*29*8));
        Serial.println("%");
        delay(1500);
    }

    int result = myGetWinner();
    Serial.print("Class: ");
    Serial.println(result);

    delay(100);
}
