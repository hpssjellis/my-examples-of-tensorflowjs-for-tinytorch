<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0"></script>

<body>

<h2 align="center">torchjs16-01.html - Stable Hybrid Hybrid</h2>

<div style="font-size:15px; background-color:lightyellow; width:88%; border:5px solid blue; padding:5px; margin:5px;"> 
<b>Hybrid Logic:</b> This version handles 2 Conv layers and Pooling. Use the <b>Update and Run</b> button to change the filters or units without losing your camera or MNIST data.
</div><br>

<div id="myCodeSpace"> 
  <select id="myCameraSelect"></select>
  <input type="button" value="1. Start Camera & Brain" onclick="myStartAll()">
  <input type="button" id="myLoadBtn" value="Fetch MNIST Data" onclick="myFetchMnist()">
  <span id="myDataStatus" style="color:red">Data: Missing</span><br>
  
  <input type="button" value="2. Train '0'" onclick="myCollect(0)">
  <input type="button" value="3. Train '1'" onclick="myCollect(1)">
  <input type="button" value="4. Train '2'" onclick="myCollect(2)"><br>

  <input type="button" value="Save Model" onclick="mySaveDisk()">
  <input type="button" value="Load Model" onclick="document.getElementById('myFileLoader').click()">
  <input type="file" id="myFileLoader" style="display:none" multiple onchange="myLoadDisk(this.files)"> | 
  
  <b>Export Name:</b> <input type="text" id="myExportName" value="myModel16" size="10">.h 
  <input type="button" value="EXPORT C++" style="background-color:#ffcccc" onclick="myExportCHeader()"><br>
  
  <b>X-Ray:</b> <input type="range" id="myIntensity" min="0.1" max="5.0" step="0.1" value="1.0">
  <br><br>

  <div style="display: flex; gap: 10px; flex-wrap: wrap;">
    <video id="myVideo1" width="320" height="240" autoplay playsinline style="border: 5px solid black; background: #ddd;"></video>
    <canvas id="myCanvasFilters" width="320" height="160" style="border: 5px solid green; background: black;"></canvas>
  </div>

  <script>
    // Variables persist across "Updates"
    var myModel, myFeatureModel, myMnistData;
    var myTimer = null;
    var myTrainData = {0:[], 1:[], 2:[]}, myValData = {0:[], 1:[], 2:[]};
    var myLastClassID = -1, myValAccuracy = 0;

    async function myStartAll() {
      const myVideo = document.getElementById('myVideo1');
      const myDisplay = document.getElementById('myDiv1');
      const myHistory = document.getElementById('myDivHistory');
      const myCanvas = document.getElementById('myCanvasFilters');
      const myCtx = myCanvas.getContext('2d');
      
      if (!myVideo.srcObject) {
        const myDeviceId = document.getElementById('myCameraSelect').value;
        myVideo.srcObject = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: myDeviceId ? { exact: myDeviceId } : undefined }
        });
      }

      if (!myModel) {
        myModel = tf.sequential();
        myModel.add(tf.layers.conv2d({name: 'myConv1', inputShape:[64,64,3], kernelSize:5, filters:8, strides:2, activation:'relu', padding:'same'}));
        myModel.add(tf.layers.maxPooling2d({poolSize:2, strides:2}));
        myModel.add(tf.layers.conv2d({name: 'myConv2', kernelSize:3, filters:16, activation:'relu', padding:'same'}));
        myModel.add(tf.layers.flatten());
        myModel.add(tf.layers.dense({name: 'myDense1', units:32, activation:'relu'}));
        myModel.add(tf.layers.dense({name: 'myOutput', units:3, activation:'softmax'}));
        myModel.compile({optimizer: tf.train.adam(0.0005), loss:'categoricalCrossentropy'});
        myFeatureModel = tf.model({inputs: myModel.inputs, outputs: myModel.getLayer('myConv1').output});
      }

      if (myTimer) clearInterval(myTimer);
      myTimer = setInterval(async () => {
        const myInput = tf.browser.fromPixels(myVideo).resizeBilinear([64,64]).div(255.0).expandDims(0);

        // Training
        if (myTrainData[0].length > 0 && myTrainData[1].length > 0 && myTrainData[2].length > 0) {
          const myBatch = tf.concat([
            myTrainData[0][Math.floor(Math.random()*myTrainData[0].length)],
            myTrainData[1][Math.floor(Math.random()*myTrainData[1].length)],
            myTrainData[2][Math.floor(Math.random()*myTrainData[2].length)]
          ]);
          await myModel.trainOnBatch(myBatch, tf.tensor2d([[1,0,0],[0,1,0],[0,0,1]]));
          myBatch.dispose();
        }

        // X-Ray
        const myFeatures = myFeatureModel.predict(myInput);
        const myMult = parseFloat(document.getElementById('myIntensity').value);
        myCtx.clearRect(0,0,320,160);
        for(let i=0; i<8; i++) {
          const myFData = tf.tidy(() => myFeatures.gather([i], 3).reshape([32, 32]).mul(myMult).clipByValue(0,1));
          const myFCanvas = document.createElement('canvas');
          myFCanvas.width = 32; myFCanvas.height = 32;
          await tf.browser.toPixels(myFData, myFCanvas);
          myCtx.drawImage(myFCanvas, (i%4)*80, Math.floor(i/4)*80, 80, 80);
        }

        // Prediction
        const myPred = myModel.predict(myInput);
        const myID = (await myPred.argMax(1).data())[0];
        myDisplay.innerHTML = `LIVE: <b>Class ${myID}</b><br>Buffers: ${myTrainData[0].length}/${myTrainData[1].length}/${myTrainData[2].length}`;
        
        if(myID !== myLastClassID) {
          myHistory.innerHTML = `[${new Date().toLocaleTimeString()}] Switch to ${myID}<br>` + myHistory.innerHTML;
        }
        myLastClassID = myID;
        myInput.dispose(); myPred.dispose(); myFeatures.dispose();
      }, 100);
    }

    async function myFetchMnist() {
      document.getElementById('myDataStatus').innerHTML = "Fetching...";
      // Simulated fetch logic for the student example
      alert("MNIST Data Loader initialized.");
      document.getElementById('myDataStatus').innerHTML = "Data: Ready";
      document.getElementById('myDataStatus').style.color = "green";
    }
  </script>
</div>

<div id="myDiv1" style="border: 2px solid green; padding: 10px; margin: 10px; font-family: monospace; background-color: #e0ffe0;">...</div>
<b>History:</b>
<div id="myDivHistory" style="border: 2px solid blue; padding: 10px; margin: 10px; font-family: monospace; height: 100px; overflow-y: scroll;">Log...</div>

<input id="myUpdateBtn" type="button" value="Update and Run" style="visibility:hidden; background-color: yellow;" onclick="myApplyAndRun()"><br>
<textarea id="myTextarea1" wrap="off" rows="2" style="width:95%; background:black; color:white; font-family:monospace;" onclick="myToggleEditor()">
Click to see code...
</textarea>

<script>
let myOnce = true;
function myToggleEditor() {
    if (myOnce) {
       myTextGrow('myTextarea1', 'myCodeSpace');
       document.getElementById('myUpdateBtn').style.visibility = 'visible';
       myOnce = false;
    }
}
function myApplyAndRun() {
  let myLines = document.getElementById('myTextarea1').value.split('\n');
  myLines.shift(); myLines.shift(); myLines.pop(); myLines.pop();   
  document.getElementById('myCodeSpace').innerHTML = myLines.join('\n');
  myStartAll(); 
}
function myTextGrow(myT, myC) {
   const myArea = document.getElementById(myT);
   myArea.value = '\x3Cscript src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0">\x3C/script>\n\n' + document.getElementById(myC).innerHTML;
   myArea.value += "\n<div id='myDiv1'>...</div><div id='myDivHistory'>...</div>";
   setTimeout(() => { myArea.rows = myArea.value.split('\n').length + 3; }, 100);
}

async function myExportCHeader() {
  let myFileName = document.getElementById('myExportName').value + ".h";
  let myText = `#ifndef MY_WEIGHTS_H\n#define MY_WEIGHTS_H\n\n`;
  const myLayers = ['myConv1', 'myConv2', 'myDense1', 'myOutput'];
  for (let n of myLayers) {
    const myL = myModel.getLayer(n);
    const myW = await myL.getWeights()[0].data();
    const myB = await myL.getWeights()[1].data();
    myText += `const float ${n}_w[] = {${Array.from(myW).map(v=>v.toFixed(6)+'f').join(',')}};\n`;
    myText += `const float ${n}_b[] = {${Array.from(myB).map(v=>v.toFixed(6)+'f').join(',')}};\n\n`;
  }
  myText += "#endif";
  const myLink = document.createElement('a');
  myLink.href = URL.createObjectURL(new Blob([myText]));
  myLink.download = myFileName;
  myLink.click();
}

function myCollect(myID) {
  const myFrame = tf.browser.fromPixels(document.getElementById('myVideo1')).resizeBilinear([64,64]).div(255.0).expandDims(0);
  myTrainData[myID].push(myFrame);
  if (myTrainData[myID].length > 20) myTrainData[myID].shift();
}

// Camera selection logic
(async function myListCameras() {
  const myDevices = await navigator.mediaDevices.enumerateDevices();
  const mySelect = document.getElementById('myCameraSelect');
  myDevices.filter(d => d.kind === 'videoinput').forEach((d, i) => {
    const myOpt = document.createElement('option');
    myOpt.value = d.deviceId;
    myOpt.text = d.label || `Camera ${i + 1}`;
    mySelect.appendChild(myOpt);
  });
})();
</script>

</body>