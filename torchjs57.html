<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0"></script>

<body style="font-family: sans-serif; background-color: #fdfdfd; padding: 10px;">

<h2 align="center">Rocksetta Pro: Overflow-Protected Optimizer</h2>

<div id="myCodeSpace"> 
  <div style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; padding: 10px;">
    
    <div style="flex: 1; min-width: 350px; border: 1px solid #ccc; padding: 15px; background: white; border-radius: 10px;">
      <label style="font-weight: bold; color: darkblue; cursor: pointer; display: block; margin-bottom: 8px;">
        <input type="checkbox" id="myGrayscaleToggle" onchange="myCheckGrayscaleChange()"> Use Grayscale Mode
      </label>
      <p style="font-size: 11px; margin-top: -5px; color: #666;">(Set BEFORE starting camera - 3x smaller model)</p>
      <select id="myCameraSelect" style="width: 100%; margin-bottom: 5px;"></select>
      <div align="center">
          <video id="myVideo1" width="240" height="240" autoplay playsinline style="border: 2px solid black; background: #000; border-radius: 5px;"></video>
          <canvas id="myCanvas1" width="240" height="240" style="display:none; border: 2px solid black; border-radius: 5px;"></canvas>
      </div>
      <br>
      <input type="button" value="1. Start Camera & Brain" onclick="myStartAll()" style="width:100%; font-weight:bold; padding:12px; background:#e1f5fe; border-radius: 5px; cursor:pointer;">
      <hr>
      <div style="display: flex; justify-content: space-between;">
          <input type="button" value="Save TFJS" onclick="mySaveModel()" style="width:48%;">
          <input type="button" value="Load TFJS" onclick="myLoadModel()" style="width:48%;">
      </div>
      <hr>
      <b>Training:</b><br>
      <div style="display: flex; justify-content: space-between; margin-top:5px; text-align:center;">
        <div style="flex:1;">
          <input type="button" value="Train 0" onclick="myCollect(0)" style="width:90%; margin-bottom:3px;">
          <br><input type="button" value="Load" onclick="myLoadImages(0)" style="width:44%; font-size:10px; padding:3px;">
          <input type="button" value="Clear" onclick="myClearImages(0)" style="width:44%; font-size:10px; padding:3px; background:#ffebee;">
          <br><input type="text" id="myLabel0" value="Class 0" size="8" style="margin-top:3px;">
          <br><span id="myCount0" style="font-size:11px; color:#666;">0 samples</span>
        </div>
        <div style="flex:1;">
          <input type="button" value="Train 1" onclick="myCollect(1)" style="width:90%; margin-bottom:3px;">
          <br><input type="button" value="Load" onclick="myLoadImages(1)" style="width:44%; font-size:10px; padding:3px;">
          <input type="button" value="Clear" onclick="myClearImages(1)" style="width:44%; font-size:10px; padding:3px; background:#ffebee;">
          <br><input type="text" id="myLabel1" value="Class 1" size="8" style="margin-top:3px;">
          <br><span id="myCount1" style="font-size:11px; color:#666;">0 samples</span>
        </div>
        <div style="flex:1;">
          <input type="button" value="Train 2" onclick="myCollect(2)" style="width:90%; margin-bottom:3px;">
          <br><input type="button" value="Load" onclick="myLoadImages(2)" style="width:44%; font-size:10px; padding:3px;">
          <input type="button" value="Clear" onclick="myClearImages(2)" style="width:44%; font-size:10px; padding:3px; background:#ffebee;">
          <br><input type="text" id="myLabel2" value="Class 2" size="8" style="margin-top:3px;">
          <br><span id="myCount2" style="font-size:11px; color:#666;">0 samples</span>
        </div>
      </div>
    </div>

    <div style="flex: 1; min-width: 350px; border: 2px solid green; padding: 15px; background: #f1f8e9; border-radius: 10px;">
      <b>2. Training Progress</b><hr>
      <div style="background: white; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
          <span><b>Batches Trained:</b></span>
          <span id="myEpochDisplay" style="font-weight: bold; color: #2196F3;">0</span>
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px; align-items: center;">
          <span><b>Min Samples:</b></span>
          <input type="number" id="myMinSamples" value="10" min="1" max="100" style="width: 80px; padding: 2px;" title="Minimum samples per class before training">
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px; align-items: center;">
          <span><b>Max Batches:</b></span>
          <input type="number" id="myMaxBatches" value="40" min="0" style="width: 80px; padding: 2px;" title="0 = Train Forever">
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px; align-items: center;">
          <span><b>Batch Size:</b></span>
          <input type="number" id="myBatchSize" value="6" min="3" max="30" step="3" style="width: 80px; padding: 2px;" title="Total samples per batch (multiple of 3)">
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px; align-items: center;">
          <span><b>Learning Rate:</b></span>
          <input type="number" id="myLearningRate" value="0.001" min="0.0001" max="0.1" step="0.0001" style="width: 80px; padding: 2px;" title="How fast the model learns">
        </div>
        <div style="margin-bottom: 5px;">
          <label style="cursor: pointer;">
            <input type="checkbox" id="myUseAllData" checked> Use All Data (systematic epochs)
          </label>
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
          <span><b>Avg Loss:</b></span>
          <span id="myLossDisplay" style="font-weight: bold; color: #FF9800;">--</span>
        </div>
        <div style="display: flex; justify-content: space-between;">
          <span><b>Training Status:</b></span>
          <span id="myStatusDisplay" style="font-weight: bold; color: #9E9E9E;">Waiting...</span>
        </div>
        <div style="margin-top: 10px; display: flex; gap: 5px;">
          <input type="button" id="myPauseBtn" value="⏸ Pause Training" onclick="myPauseTraining()" style="flex: 1; padding: 8px; background: #FF9800; color: white; font-weight: bold; border-radius: 5px; cursor: pointer;" disabled>
          <input type="button" id="myResumeBtn" value="▶ Resume Training" onclick="myResumeTraining()" style="flex: 1; padding: 8px; background: #4CAF50; color: white; font-weight: bold; border-radius: 5px; cursor: pointer; display: none;">
        </div>
        <div style="margin-top: 10px; height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden;">
          <div id="myProgressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); transition: width 0.3s;"></div>
        </div>
      </div>
      <hr>
      <b>Edge AI Export</b><br>
      <label style="font-weight: bold; color: darkgreen; cursor: pointer;">
        <input type="checkbox" id="myInt8Toggle"> Use Int8 Quantization
      </label>
      <p style="font-size: 11px;">(Saves memory on ESP32)</p>
      <b>Export Name:</b><br>
      <input type="text" id="myExportName" value="myModel" style="width:70%;"> .h
      <br><br>
      <input type="button" value="GENERATE (.h)" style="background-color:#4CAF50; color:white; width:100%; padding:15px; font-weight:bold; border-radius: 5px; cursor:pointer;" onclick="myExportHeader()">
      <hr>
      <div style="margin-bottom: 10px; display: flex; gap: 5px;">
        <input type="button" id="myStopAnalysisBtn" value="⏹ Stop Analysis" onclick="myStopAnalysis()" style="flex: 1; padding: 8px; background: #F44336; color: white; font-weight: bold; border-radius: 5px; cursor: pointer;" disabled>
        <input type="button" id="myStartAnalysisBtn" value="▶ Start Analysis" onclick="myStartAnalysis()" style="flex: 1; padding: 8px; background: #2196F3; color: white; font-weight: bold; border-radius: 5px; cursor: pointer; display: none;">
      </div>
      <div id="myOutputDisplay" style="border: 1px solid green; padding: 10px; background: white; min-height: 50px;">Ready...</div>
    </div>

    <div style="flex: 1; min-width: 350px; border: 1px solid #ccc; padding: 15px; background: white; border-radius: 10px;">
      <b>3. Activity Logs</b><hr>
      <div id="myDivHistory" style="border: 1px solid blue; padding: 8px; height: 300px; overflow-y: scroll; font-family: monospace; font-size: 0.85em; background: #f1f8ff; border-radius: 5px;">
        Logs will appear here...
      </div>
    </div>
  </div>

  <script>
    var myModel, myTimer, myLastID = -1;
    var myTrainData = {0:[], 1:[], 2:[]};
    var myMaxBuffer = 100;
    var myEpochCount = 0;
    var myLossHistory = [];
    var myAccuracyHistory = [];
    var myLossSum = 0;
    var myLossCount = 0;
    var myTrainingPaused = false;
    var myAnalysisStopped = false;
    var myIsGrayscaleMode = false;
    var myGrayscaleRenderTimer = null;
    var myAllDataIndex = 0;
    var myCurrentEpoch = 0;

    function myLog(myMsg) {
        const myDiv = document.getElementById('myDivHistory');
        const myTime = new Date().toLocaleTimeString();
        myDiv.innerHTML = `[${myTime}] ${myMsg}<br>` + myDiv.innerHTML;
    }

    function myAugment(tensor) {
      return tf.tidy(() => {
        let augmented = tensor;
        
        if (Math.random() > 0.5) {
          const brightness = (Math.random() - 0.5) * 0.2;
          augmented = augmented.add(brightness).clipByValue(0, 1);
        }
        
        if (Math.random() > 0.5) {
          const contrast = 0.8 + Math.random() * 0.4;
          const mean = augmented.mean();
          augmented = augmented.sub(mean).mul(contrast).add(mean).clipByValue(0, 1);
        }
        
        return augmented;
      });
    }

    function myStopAnalysis() {
      myAnalysisStopped = true;
      document.getElementById('myStopAnalysisBtn').style.display = 'none';
      document.getElementById('myStartAnalysisBtn').style.display = 'block';
      document.getElementById('myOutputDisplay').innerHTML = '<span style="color:#666;">Analysis Stopped</span>';
      myLog("Analysis Stopped - Reduced resource usage");
    }

    function myStartAnalysis() {
      myAnalysisStopped = false;
      document.getElementById('myStopAnalysisBtn').style.display = 'block';
      document.getElementById('myStartAnalysisBtn').style.display = 'none';
      document.getElementById('myOutputDisplay').innerHTML = 'Analyzing...';
      myLog("Analysis Started");
    }

    function myCheckGrayscaleChange() {
      if (myModel) {
        alert('⚠️ Changing color mode requires restarting Camera & Brain.\n\nPlease refresh the page or clear all training data to switch modes.');
        document.getElementById('myGrayscaleToggle').checked = myIsGrayscaleMode;
      }
    }

    async function myStartAll() {
      const myVideo = document.getElementById('myVideo1');
      const myCanvas = document.getElementById('myCanvas1');
      const myCtx = myCanvas.getContext('2d');
      
      if (!myVideo.srcObject) {
        const myDeviceId = document.getElementById('myCameraSelect').value;
        myVideo.srcObject = await navigator.mediaDevices.getUserMedia({video: { width: 240, height: 240, deviceId: myDeviceId ? { exact: myDeviceId } : undefined }});
        myLog("Camera Started");
        
        // Setup grayscale video preview if needed
        myIsGrayscaleMode = document.getElementById('myGrayscaleToggle').checked;
        if (myIsGrayscaleMode) {
          myVideo.style.display = 'none';
          myCanvas.style.display = 'block';
          
          // Render grayscale video preview
          if (myGrayscaleRenderTimer) clearInterval(myGrayscaleRenderTimer);
          myGrayscaleRenderTimer = setInterval(() => {
            myCtx.drawImage(myVideo, 0, 0, 240, 240);
            const myImageData = myCtx.getImageData(0, 0, 240, 240);
            const myData = myImageData.data;
            
            for (let i = 0; i < myData.length; i += 4) {
              const myGray = myData[i] * 0.299 + myData[i+1] * 0.587 + myData[i+2] * 0.114;
              myData[i] = myGray;
              myData[i+1] = myGray;
              myData[i+2] = myGray;
            }
            myCtx.putImageData(myImageData, 0, 0);
          }, 33);
        } else {
          myVideo.style.display = 'block';
          myCanvas.style.display = 'none';
        }
      }
      
      if (!myModel) {
        const inputChannels = myIsGrayscaleMode ? 1 : 3;
        const myCurrentLearningRate = parseFloat(document.getElementById('myLearningRate').value) || 0.001;
        
        myModel = tf.sequential();
        myModel.add(tf.layers.conv2d({
          inputShape:[64,64,inputChannels], 
          kernelSize:3, 
          filters:4, 
          activation:'relu',
          kernelRegularizer: tf.regularizers.l2({l2: 0.0001}),  // Much weaker!
          biasInitializer: 'zeros'
        }));
        myModel.add(tf.layers.maxPooling2d({poolSize:2, strides:2}));
        myModel.add(tf.layers.conv2d({
          kernelSize:3, 
          filters:8, 
          activation:'relu',
          kernelRegularizer: tf.regularizers.l2({l2: 0.0001}),  // Much weaker!
          biasInitializer: 'zeros'
        }));
        myModel.add(tf.layers.flatten());
        myModel.add(tf.layers.dropout({rate: 0.3}));
        myModel.add(tf.layers.dense({
          units:3, 
          activation:'softmax',
          // NO regularization on output layer for small datasets!
          kernelInitializer: 'heNormal',
          biasInitializer: 'zeros'
        }));
        
        myModel.compile({
          optimizer: tf.train.adam(myCurrentLearningRate), 
          loss:'categoricalCrossentropy',
          metrics: ['accuracy']
        });
        myLog(`Brain Initialized (${myIsGrayscaleMode ? 'Grayscale' : 'RGB'} 2-Layer CNN, LR: ${myCurrentLearningRate})`);
      }

      if (myTimer) clearInterval(myTimer);
      myTimer = setInterval(async () => {
        let myInput = tf.browser.fromPixels(myVideo).resizeBilinear([64,64]);
        
        // Convert to grayscale if in grayscale mode
        if (myIsGrayscaleMode) {
          const myOldInput = myInput;
          myInput = tf.tidy(() => {
            const r = myOldInput.slice([0, 0, 0], [64, 64, 1]);
            const g = myOldInput.slice([0, 0, 1], [64, 64, 1]);
            const b = myOldInput.slice([0, 0, 2], [64, 64, 1]);
            return r.mul(0.299).add(g.mul(0.587)).add(b.mul(0.114));
          });
          myOldInput.dispose();
        }
        
        const myOldInput2 = myInput;
        myInput = myInput.div(255.0).expandDims(0);
        myOldInput2.dispose();
        
        const minSamples = parseInt(document.getElementById('myMinSamples').value) || 10;
        const counts = [myTrainData[0].length, myTrainData[1].length, myTrainData[2].length];
        const minCount = Math.min(...counts);
        const maxCount = Math.max(...counts);
        
        const maxBatches = parseInt(document.getElementById('myMaxBatches').value) || 0;
        const reachedLimit = maxBatches > 0 && myEpochCount >= maxBatches;
        
        // Get batch size and calculate samples per class
        let myBatchSize = parseInt(document.getElementById('myBatchSize').value) || 6;
        if (myBatchSize < 3) myBatchSize = 3;
        if (myBatchSize % 3 !== 0) myBatchSize = Math.ceil(myBatchSize / 3) * 3;
        const mySamplesPerClass = myBatchSize / 3;
        
        if (minCount >= minSamples && !myTrainingPaused && !reachedLimit) {
          if (maxCount > minCount * 2) {
            if (Math.random() < 0.01) {
              myLog(`WARNING: Imbalanced data [${counts[0]}, ${counts[1]}, ${counts[2]}]`);
            }
          }
          
          let myBatch = [];
          let myLabels = [];
          
          const myUseAllData = document.getElementById('myUseAllData').checked;
          
          if (myUseAllData) {
            // Systematic "Use All Data" mode
            // Create flat array of all samples with their labels
            if (myAllDataIndex === 0) {
              myCurrentEpoch++;
            }
            
            let myAllSamples = [];
            for (let cls = 0; cls < 3; cls++) {
              for (let i = 0; i < myTrainData[cls].length; i++) {
                myAllSamples.push({sample: myTrainData[cls][i], label: cls});
              }
            }
            
            // Shuffle at start of each epoch
            if (myAllDataIndex === 0) {
              for (let i = myAllSamples.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [myAllSamples[i], myAllSamples[j]] = [myAllSamples[j], myAllSamples[i]];
              }
            }
            
            // Get next batch from shuffled data
            for (let i = 0; i < myBatchSize && myAllDataIndex < myAllSamples.length; i++) {
              const item = myAllSamples[myAllDataIndex];
              const augmented = (Math.random() > 0.5) ? myAugment(item.sample) : tf.clone(item.sample);
              myBatch.push(augmented);
              myLabels.push(item.label === 0 ? [1,0,0] : item.label === 1 ? [0,1,0] : [0,0,1]);
              myAllDataIndex++;
            }
            
            // Reset index when we've used all samples
            if (myAllDataIndex >= myAllSamples.length) {
              myAllDataIndex = 0;
            }
            
          } else {
            // Random sampling mode (original behavior)
            for (let cls = 0; cls < 3; cls++) {
              for (let i = 0; i < mySamplesPerClass; i++) {
                const randomIdx = Math.floor(Math.random() * myTrainData[cls].length);
                const sample = myTrainData[cls][randomIdx];
                
                const augmented = (Math.random() > 0.5) ? myAugment(sample) : tf.clone(sample);
                myBatch.push(augmented);
                myLabels.push(cls === 0 ? [1,0,0] : cls === 1 ? [0,1,0] : [0,0,1]);
              }
            }
          }
          
          const myBatchTensor = tf.concat(myBatch);
          const myLabelsTensor = tf.tensor2d(myLabels);

          let currentLoss = 0;
          try {
            const trainResult = await myModel.trainOnBatch(myBatchTensor, myLabelsTensor);
            currentLoss = Array.isArray(trainResult) ? trainResult[0] : trainResult;
            
            if (isNaN(currentLoss) || !isFinite(currentLoss)) {
              myLog("WARNING: Invalid loss detected, skipping batch");
              currentLoss = 0;
            }
          } catch (error) {
            myLog("ERROR during training: " + error.message);
            currentLoss = 0;
          }
          
          myBatchTensor.dispose();
          myLabelsTensor.dispose();
          myBatch.forEach(t => {
            let isStoredSample = false;
            for (let cls = 0; cls < 3; cls++) {
              if (myTrainData[cls].includes(t)) {
                isStoredSample = true;
                break;
              }
            }
            if (!isStoredSample) t.dispose();
          });
          
          myEpochCount++;
          if (currentLoss > 0) {
            myLossSum += currentLoss;
            myLossCount++;
          }
          
          if (myEpochCount % 10 === 0) {
            const avgLoss = myLossCount > 0 ? myLossSum / myLossCount : 0;
            
            if (avgLoss > 0 && isFinite(avgLoss)) {
              myLossHistory.push(avgLoss);
            }
            
            if (myLossHistory.length > 20) myLossHistory.shift();
            
            const recentAvgLoss = myLossHistory.length > 0 
              ? myLossHistory.reduce((a,b) => a+b, 0) / myLossHistory.length 
              : 0;
            
            document.getElementById('myEpochDisplay').innerText = myEpochCount;
            document.getElementById('myLossDisplay').innerText = 
              myLossHistory.length > 0 ? recentAvgLoss.toFixed(4) : '--';
            
            let status = '';
            let statusColor = '';
            let progressPercent = 0;
            
            if (myLossHistory.length === 0) {
              status = 'Initializing...';
              statusColor = '#9E9E9E';
              progressPercent = 5;
            } else if (recentAvgLoss > 1.0) {
              status = 'Starting...';
              statusColor = '#FF5722';
              progressPercent = 10;
            } else if (recentAvgLoss > 0.5) {
              status = 'Training...';
              statusColor = '#FF9800';
              progressPercent = 30;
            } else if (recentAvgLoss > 0.2) {
              status = 'Improving...';
              statusColor = '#FFC107';
              progressPercent = 60;
            } else if (recentAvgLoss > 0.1) {
              status = 'Converging...';
              statusColor = '#8BC34A';
              progressPercent = 80;
            } else {
              status = 'Well Trained ✓';
              statusColor = '#4CAF50';
              progressPercent = 100;
            }
            
            document.getElementById('myStatusDisplay').innerText = status;
            document.getElementById('myStatusDisplay').style.color = statusColor;
            document.getElementById('myProgressBar').style.width = progressPercent + '%';
            
            document.getElementById('myPauseBtn').disabled = false;
            
            myLossSum = 0;
            myLossCount = 0;
          }
        } else if (reachedLimit) {
          if (!myTrainingPaused) {
            myPauseTraining();
            myLog(`Training stopped: Reached ${maxBatches} batches`);
          }
          document.getElementById('myStatusDisplay').innerText = `Completed (${maxBatches} batches)`;
          document.getElementById('myStatusDisplay').style.color = '#4CAF50';
        } else {
          if (myTrainingPaused) {
            document.getElementById('myStatusDisplay').innerText = 'Paused';
            document.getElementById('myStatusDisplay').style.color = '#FF9800';
          } else {
            // Show how many more samples needed for each class
            const myNeeds = [
              Math.max(0, minSamples - counts[0]),
              Math.max(0, minSamples - counts[1]),
              Math.max(0, minSamples - counts[2])
            ];
            document.getElementById('myStatusDisplay').innerText = `Waiting (need: ${myNeeds[0]}, ${myNeeds[1]}, ${myNeeds[2]} more)`;
            document.getElementById('myStatusDisplay').style.color = '#9E9E9E';
          }
        }

        // Only run analysis if not stopped
        if (!myAnalysisStopped) {
          document.getElementById('myStopAnalysisBtn').disabled = false;
          
          const myPred = myModel.predict(myInput);
          const myProbs = await myPred.data();
          const myID = (await myPred.argMax(1).data())[0];
          
          const conf0 = (myProbs[0] * 100).toFixed(1);
          const conf1 = (myProbs[1] * 100).toFixed(1);
          const conf2 = (myProbs[2] * 100).toFixed(1);
          
          const maxConf = Math.max(myProbs[0], myProbs[1], myProbs[2]) * 100;
          const confColor = maxConf > 80 ? 'green' : maxConf > 50 ? 'orange' : 'red';
          const uncertainWarning = maxConf < 50 ? '<br><span style="color:red;">⚠ Low Confidence - Need More Training?</span>' : '';
          
          document.getElementById('myOutputDisplay').innerHTML = 
            `DETECTED: <b style="color:${confColor}">${document.getElementById('myLabel'+myID).value}</b><br>` +
            `[${conf0}%, ${conf1}%, ${conf2}%]` +
            uncertainWarning;
          
          myPred.dispose();
        }
        
        myInput.dispose();
      }, 150);
    }

    function myPauseTraining() {
      myTrainingPaused = true;
      document.getElementById('myPauseBtn').style.display = 'none';
      document.getElementById('myResumeBtn').style.display = 'block';
      myLog("Training Paused - Safe to export model");
    }

    function myResumeTraining() {
      myTrainingPaused = false;
      document.getElementById('myPauseBtn').style.display = 'block';
      document.getElementById('myResumeBtn').style.display = 'none';
      myLog("Training Resumed");
    }

    function toCString(str) {
      str = str.substring(0, 20);
      return str.replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/\t/g, '\\t');
    }

    async function myExportHeader() {
      if(!myModel) { myLog("Error: No Model to export"); return; }
      const myIsInt8 = document.getElementById('myInt8Toggle').checked;
      const myIsGrayscale = document.getElementById('myGrayscaleToggle').checked;
      
      // WARNING: Can only export grayscale if model was trained in grayscale mode
      if (myIsGrayscale && !myIsGrayscaleMode) {
        alert('⚠️ Warning: Model was trained in RGB mode.\n\nTo export grayscale, please:\n1. Check "Use Grayscale" BEFORE starting Camera & Brain\n2. Retrain the model\n3. Then export\n\nExporting RGB model instead...');
        myLog("ERROR: Cannot convert RGB model to grayscale - exporting RGB");
        document.getElementById('myGrayscaleToggle').checked = false;
        return;
      }
      
      myLog(`Exporting ${myIsInt8 ? "Int8" : "Float"} ${myIsGrayscale ? "Grayscale" : "RGB"} Header with Labels...`);
      
      const label0 = toCString(document.getElementById('myLabel0').value);
      const label1 = toCString(document.getElementById('myLabel1').value);
      const label2 = toCString(document.getElementById('myLabel2').value);
      
      let myText = `// Overflow-Protected 2-Layer CNN Model with Labels\n`;
      myText += `#ifndef MY_MODEL_H\n#define MY_MODEL_H\n\n`;
      
      myText += `// Class Labels\n`;
      myText += `const char* myClassLabels[3] = {\n`;
      myText += `  "${label0}",\n`;
      myText += `  "${label1}",\n`;
      myText += `  "${label2}"\n`;
      myText += `};\n\n`;
      
      if (myIsInt8) { myText += `#define USE_INT8_MODE\n`; }
      if (myIsGrayscale) { myText += `#define USE_GRAYSCALE_MODE\n`; }
      myText += `\n`;
      
      const myNames = ["myConv1_w", "myConv1_b", "myConv2_w", "myConv2_b", "myOutput_w", "myOutput_b"];
      let myNameIdx = 0;
      
      for (let myL of myModel.layers) {
          if (myL.getWeights().length === 0) continue;
          
          for (let myW of myL.getWeights()) {
              let myData = await myW.data();
              let myDataArray = Array.from(myData);
              
              const maxAbsWeight = Math.max(...myDataArray.map(Math.abs));
              if (maxAbsWeight > 10.0) {
                myLog(`WARNING: Large weights detected (${maxAbsWeight.toFixed(2)}), clipping...`);
                myDataArray = myDataArray.map(v => Math.max(-10.0, Math.min(10.0, v)));
              }
              
              if (myIsInt8) {
                  const myMax = Math.max(...myDataArray.map(Math.abs));
                  const myScale = 127.0 / (myMax || 1);
                  myText += `const float ${myNames[myNameIdx]}_scale = ${myScale.toFixed(6)}f;\n`;
                  myText += `const int8_t ${myNames[myNameIdx]}[] = { `;
                  myText += myDataArray.map(v => Math.round(v * myScale)).join(', ');
              } else {
                  myText += `const float ${myNames[myNameIdx]}[] = { `;
                  myText += myDataArray.map(v => v.toFixed(6)).join(', ');
              }
              myText += ` };\n\n`;
              myNameIdx++;
          }
      }
      myText += `#endif`;
      
      const myLink = document.createElement('a');
      myLink.href = URL.createObjectURL(new Blob([myText]));
      myLink.download = document.getElementById('myExportName').value + ".h";
      myLink.click();
      myLog(`Export Successful with Labels: [${label0}, ${label1}, ${label2}]`);
    }

    function myCollect(myID) {
      const myVideo = document.getElementById('myVideo1');
      if (!myVideo.srcObject) {
        myLog("ERROR: Camera not started!");
        return;
      }
      
      let myFrame = tf.browser.fromPixels(myVideo).resizeBilinear([64,64]);
      
      // Convert to grayscale if in grayscale mode
      if (myIsGrayscaleMode) {
        const myOldFrame = myFrame;
        myFrame = tf.tidy(() => {
          const r = myOldFrame.slice([0, 0, 0], [64, 64, 1]);
          const g = myOldFrame.slice([0, 0, 1], [64, 64, 1]);
          const b = myOldFrame.slice([0, 0, 2], [64, 64, 1]);
          return r.mul(0.299).add(g.mul(0.587)).add(b.mul(0.114));
        });
        myOldFrame.dispose();
      }
      
      const myOldFrame2 = myFrame;
      myFrame = myFrame.div(255.0).expandDims(0);
      myOldFrame2.dispose();
      
      const frameData = myFrame.dataSync();
      let hasNaN = false;
      for (let i = 0; i < frameData.length; i++) {
        if (isNaN(frameData[i]) || !isFinite(frameData[i])) {
          hasNaN = true;
          break;
        }
      }
      
      if (hasNaN) {
        myLog("ERROR: Invalid camera frame detected, skipping");
        myFrame.dispose();
        return;
      }
      
      if (myTrainData[myID].length < myMaxBuffer) {
        myTrainData[myID].push(myFrame);
      } else {
        myTrainData[myID][0].dispose();
        myTrainData[myID].shift();
        myTrainData[myID].push(myFrame);
      }
      
      document.getElementById('myCount' + myID).innerHTML = `${myTrainData[myID].length} samples`;
      myLog(`Class ${myID} Captured (Total: ${myTrainData[myID].length})`);
    }

    function myLoadImages(myID) {
      const myInput = document.createElement('input');
      myInput.type = 'file';
      myInput.multiple = true;
      myInput.accept = 'image/*';
      
      myInput.onchange = async (e) => {
        const files = Array.from(e.target.files);
        myLog(`Loading ${files.length} images for Class ${myID}...`);
        
        let loaded = 0;
        for (const file of files) {
          try {
            const img = new Image();
            const url = URL.createObjectURL(file);
            
            await new Promise((resolve, reject) => {
              img.onload = () => {
                try {
                  let tensor = tf.browser.fromPixels(img).resizeBilinear([64,64]);
                  
                  // Convert to grayscale if in grayscale mode
                  if (myIsGrayscaleMode) {
                    const myOldTensor = tensor;
                    tensor = tf.tidy(() => {
                      const r = myOldTensor.slice([0, 0, 0], [64, 64, 1]);
                      const g = myOldTensor.slice([0, 0, 1], [64, 64, 1]);
                      const b = myOldTensor.slice([0, 0, 2], [64, 64, 1]);
                      return r.mul(0.299).add(g.mul(0.587)).add(b.mul(0.114));
                    });
                    myOldTensor.dispose();
                  }
                  
                  const myOldTensor2 = tensor;
                  tensor = tensor.div(255.0).expandDims(0);
                  myOldTensor2.dispose();
                  
                  // Validate tensor
                  const data = tensor.dataSync();
                  let isValid = true;
                  for (let i = 0; i < data.length; i++) {
                    if (isNaN(data[i]) || !isFinite(data[i])) {
                      isValid = false;
                      break;
                    }
                  }
                  
                  if (isValid) {
                    if (myTrainData[myID].length < myMaxBuffer) {
                      myTrainData[myID].push(tensor);
                    } else {
                      myTrainData[myID][0].dispose();
                      myTrainData[myID].shift();
                      myTrainData[myID].push(tensor);
                    }
                    loaded++;
                  } else {
                    tensor.dispose();
                  }
                  
                  URL.revokeObjectURL(url);
                  resolve();
                } catch (err) {
                  URL.revokeObjectURL(url);
                  reject(err);
                }
              };
              img.onerror = () => {
                URL.revokeObjectURL(url);
                reject(new Error('Failed to load image'));
              };
              img.src = url;
            });
          } catch (err) {
            console.error('Error loading image:', err);
          }
        }
        
        document.getElementById('myCount' + myID).innerHTML = `${myTrainData[myID].length} samples`;
        myLog(`Class ${myID}: Loaded ${loaded}/${files.length} images (Total: ${myTrainData[myID].length})`);
      };
      
      myInput.click();
    }

    function myClearImages(myID) {
      if (myTrainData[myID].length === 0) {
        myLog(`Class ${myID}: Already empty`);
        return;
      }
      
      const count = myTrainData[myID].length;
      
      // Dispose all tensors
      myTrainData[myID].forEach(tensor => tensor.dispose());
      myTrainData[myID] = [];
      
      document.getElementById('myCount' + myID).innerHTML = `0 samples`;
      myLog(`Class ${myID}: Cleared ${count} samples`);
    }

    async function mySaveModel() { await myModel.save('downloads://my-tfjs-model'); myLog("TFJS Model Saved"); }
    async function myLoadModel() {
        const myU = document.createElement('input'); myU.type = 'file'; myU.multiple = true;
        myU.onchange = async (e) => { 
            myModel = await tf.loadLayersModel(tf.io.browserFiles(e.target.files)); 
            myLog("TFJS Model Loaded");
        };
        myU.click();
    }
  </script>
</div>

<div align="center">
  <input id="myUpdateBtn" type="button" value="Update & Run Code" style="visibility:hidden; background-color: yellow; font-weight:bold; padding:12px; border-radius:8px; cursor:pointer;" onclick="myApplyAndRun()">
</div>

<textarea id="myTextarea1" wrap="off" rows="2" style="width:95%; background:black; color:white; font-family:monospace; margin:15px; padding:10px; border-radius:10px;" onclick="myToggleEditor()">
Click here to see/edit the Source Code...
</textarea>

<script>
let myOnce = true;
function myToggleEditor() {
    if (myOnce) {
       myTextGrow('myTextarea1', 'myCodeSpace');
       document.getElementById('myUpdateBtn').style.visibility = 'visible';
       myOnce = false;
    }
}
function myApplyAndRun() {
  let myLines = document.getElementById('myTextarea1').value.split('\n');
  myLines.shift(); myLines.shift(); myLines.pop();   
  document.getElementById('myCodeSpace').innerHTML = myLines.join('\n');
  myLog("Code Updated & Restarting...");
  myStartAll();
}
function myTextGrow(myT, myC) {
   const myArea = document.getElementById(myT);
   myArea.value = '\x3Cscript src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0">\x3C/script>\n\n' + document.getElementById(myC).innerHTML;
   myArea.rows = 20;
}
(async function init() {
  const myDevices = await navigator.mediaDevices.enumerateDevices();
  const mySelect = document.getElementById('myCameraSelect');
  myDevices.filter(d => d.kind === 'videoinput').forEach((d, i) => {
    const myOpt = document.createElement('option');
    myOpt.value = d.deviceId;
    myOpt.text = d.label || `Camera ${i + 1}`;
    mySelect.appendChild(myOpt);
  });
})();
</script>

<h2>By Jeremy Ellis, Use at your own Risk</h2>
<a href="https://github.com/hpssjellis">github Profile hpssjellis</a><br>
<a href="https://www.linkedin.com/in/jeremy-ellis-4237a9bb/">LinkedIn jeremy-ellis-4237a9bb</a> <br>
</body>
