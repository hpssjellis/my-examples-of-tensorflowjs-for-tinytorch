#include "esp_camera.h"
#include "img_converters.h"
#include "myModel.h" 

// --- 1. CONFIGURATION & BUFFERS ---
#ifdef USE_GRAYSCALE_MODE
  float myInputBuffer[64 * 64 * 1];  // Single channel
#else
  float myInputBuffer[64 * 64 * 3];  // RGB channels
#endif

float myConv1Output[62 * 62 * 4];
float myPool1Output[31 * 31 * 4];
float myConv2Output[29 * 29 * 8];

// OVERFLOW PROTECTION: Clip helper function
inline float clipValue(float val, float minVal = -100.0f, float maxVal = 100.0f) {
    if (isnan(val) || isinf(val)) return 0.0f;
    if (val < minVal) return minVal;
    if (val > maxVal) return maxVal;
    return val;
}

#ifdef USE_INT8_MODE
  #define GET_W(arr, idx, scale) ((float)arr[idx] / scale)
#else
  #define GET_W(arr, idx, scale) (arr[idx])
  float myConv1_w_scale=1, myConv1_b_scale=1;
  float myConv2_w_scale=1, myConv2_b_scale=1;
  float myOutput_w_scale=1, myOutput_b_scale=1;
#endif

// Camera Pins (XIAO ESP32S3 Sense)
#define XCLK_GPIO_NUM 10
#define SIOD_GPIO_NUM 40
#define SIOC_GPIO_NUM 39
#define Y9_GPIO_NUM   48
#define Y8_GPIO_NUM   11
#define Y7_GPIO_NUM   12
#define Y6_GPIO_NUM   14
#define Y5_GPIO_NUM   16
#define Y4_GPIO_NUM   18
#define Y3_GPIO_NUM   17
#define Y2_GPIO_NUM   15
#define VSYNC_GPIO_NUM 38
#define HREF_GPIO_NUM  47
#define PCLK_GPIO_NUM  13

// --- 2. FIRST CONVOLUTION LAYER (3x3, 4 filters) ---
void myConv1() {
    for (int f = 0; f < 4; f++) {
        int outBase = f * 3844;
        for (int y = 0; y < 62; y++) {
            for (int x = 0; x < 62; x++) {
                float sum = 0;
                
                #ifdef USE_GRAYSCALE_MODE
                  // Grayscale: 1 channel, 9 weights per filter
                  for (int ky = 0; ky < 3; ky++) {
                      for (int kx = 0; kx < 3; kx++) {
                          int pIdx = (y+ky)*64 + (x+kx);
                          int wIdx = (f*9) + (ky*3) + kx;
                          sum += myInputBuffer[pIdx] * GET_W(myConv1_w, wIdx, myConv1_w_scale);
                      }
                  }
                #else
                  // RGB: 3 channels, 27 weights per filter
                  for (int ky = 0; ky < 3; ky++) {
                      for (int kx = 0; kx < 3; kx++) {
                          int pIdx = ((y+ky)*64 + (x+kx))*3;
                          int wIdx = (f*27) + (ky*9) + (kx*3);
                          sum += myInputBuffer[pIdx]   * GET_W(myConv1_w, wIdx,   myConv1_w_scale);
                          sum += myInputBuffer[pIdx+1] * GET_W(myConv1_w, wIdx+1, myConv1_w_scale);
                          sum += myInputBuffer[pIdx+2] * GET_W(myConv1_w, wIdx+2, myConv1_w_scale);
                      }
                  }
                #endif
                
                sum += GET_W(myConv1_b, f, myConv1_b_scale);
                sum = clipValue(sum, -100.0f, 100.0f);  // Increased from 50 to 100
                myConv1Output[outBase + (y*62 + x)] = (sum > 0) ? sum : 0;
            }
        }
    }
}

// --- 3. MAX POOLING LAYER (2x2, stride 2) ---
void myMaxPool1() {
    for (int f = 0; f < 4; f++) {
        int inBase = f * 3844;
        int outBase = f * 961;
        for (int y = 0; y < 31; y++) {
            for (int x = 0; x < 31; x++) {
                int inY = y * 2;
                int inX = x * 2;
                float maxVal = myConv1Output[inBase + (inY*62 + inX)];
                maxVal = max(maxVal, myConv1Output[inBase + (inY*62 + inX+1)]);
                maxVal = max(maxVal, myConv1Output[inBase + ((inY+1)*62 + inX)]);
                maxVal = max(maxVal, myConv1Output[inBase + ((inY+1)*62 + inX+1)]);
                myPool1Output[outBase + (y*31 + x)] = maxVal;
            }
        }
    }
}

// --- 4. SECOND CONVOLUTION LAYER (3x3, 8 filters) --- FIXED!
void myConv2() {
    for (int f = 0; f < 8; f++) {
        int outBase = f * 841;
        for (int y = 0; y < 29; y++) {
            for (int x = 0; x < 29; x++) {
                float sum = 0;
                for (int c = 0; c < 4; c++) {
                    int inBase = c * 961;
                    for (int ky = 0; ky < 3; ky++) {
                        for (int kx = 0; kx < 3; kx++) {
                            int pIdx = inBase + ((y+ky)*31 + (x+kx));
                            // CRITICAL FIX: Was (f*108)+(c*27)+(ky*9)+(kx*3)
                            // Correct: 8 filters, 4 channels, 3x3 kernel = 36 weights per filter
                            int wIdx = (f*36) + (c*9) + (ky*3) + kx;
                            sum += myPool1Output[pIdx] * GET_W(myConv2_w, wIdx, myConv2_w_scale);
                        }
                    }
                }
                sum += GET_W(myConv2_b, f, myConv2_b_scale);
                sum = clipValue(sum, -100.0f, 100.0f);  // Increased from 50 to 100
                myConv2Output[outBase + (y*29 + x)] = (sum > 0) ? sum : 0;
            }
        }
    }
}

// --- 5. THE WINNER LOGIC (Dense Layer with Overflow Protection) ---
int myGetWinner() {
    float myLogits[3] = {0, 0, 0};
    int totalFeatures = 29 * 29 * 8;
    
    for (int i = 0; i < 3; i++) {
        double sum = 0.0;
        double compensation = 0.0;
        
        for (int j = 0; j < totalFeatures; j++) {
            double term = (double)myConv2Output[j] *
                          GET_W(myOutput_w, i*totalFeatures + j, myOutput_w_scale);
            double y = term - compensation;
            double t = sum + y;
            compensation = (t - sum) - y;
            sum = t;
        }
        
        myLogits[i] = clipValue(
            (float)sum + GET_W(myOutput_b, i, myOutput_b_scale),
            -50.0f, 50.0f
        );
    }
    
    Serial.print("Logits: [");
    Serial.print(myLogits[0], 2); Serial.print(", ");
    Serial.print(myLogits[1], 2); Serial.print(", ");
    Serial.print(myLogits[2], 2); Serial.print("] -> ");

    float maxLogit = max(max(myLogits[0], myLogits[1]), myLogits[2]);
    float expSum = exp(myLogits[0]-maxLogit) +
                   exp(myLogits[1]-maxLogit) +
                   exp(myLogits[2]-maxLogit);

    Serial.print("Probs: [");
    for (int i = 0; i < 3; i++) {
        float p = exp(myLogits[i]-maxLogit) / expSum * 100.0f;
        Serial.print(p, 0); Serial.print("%");
        if (i < 2) Serial.print(", ");
    }
    Serial.print("] ");

    int win = (myLogits[1] > myLogits[0]) ? 1 : 0;
    if (myLogits[2] > myLogits[win]) win = 2;
    return win;
}

// --- 6. IMAGE PROCESSING (QVGA 320x240 â†’ 64x64) ---
void myProcessCamera(camera_fb_t *fb) {
    uint8_t *rgb = (uint8_t *)ps_malloc(fb->width * fb->height * 3);
    if (!rgb) return;

    if (!fmt2rgb888(fb->buf, fb->len, fb->format, rgb)) {
        free(rgb);
        return;
    }

    float scaleY = (float)fb->height / 64.0f;
    float scaleX = (float)fb->width  / 64.0f;

    for (int y = 0; y < 64; y++) {
        float srcY = (y + 0.5f) * scaleY - 0.5f;
        int y0 = (int)srcY;
        int y1 = min(y0 + 1, (int)fb->height - 1);
        float dy = srcY - y0;

        for (int x = 0; x < 64; x++) {
            float srcX = (x + 0.5f) * scaleX - 0.5f;
            int x0 = (int)srcX;
            int x1 = min(x0 + 1, (int)fb->width - 1);
            float dx = srcX - x0;

            int idx00 = (y0 * fb->width + x0) * 3;
            int idx01 = (y0 * fb->width + x1) * 3;
            int idx10 = (y1 * fb->width + x0) * 3;
            int idx11 = (y1 * fb->width + x1) * 3;

            // Calculate interpolated R, G, B
            float r = (1.0f - dy) * ((1.0f - dx) * rgb[idx00] + dx * rgb[idx01]) +
                      dy * ((1.0f - dx) * rgb[idx10] + dx * rgb[idx11]);
            float g = (1.0f - dy) * ((1.0f - dx) * rgb[idx00 + 1] + dx * rgb[idx01 + 1]) +
                      dy * ((1.0f - dx) * rgb[idx10 + 1] + dx * rgb[idx11 + 1]);
            float b = (1.0f - dy) * ((1.0f - dx) * rgb[idx00 + 2] + dx * rgb[idx01 + 2]) +
                      dy * ((1.0f - dx) * rgb[idx10 + 2] + dx * rgb[idx11 + 2]);

            #ifdef USE_GRAYSCALE_MODE
              // Convert to Grayscale - MATCH WEB TRAINER EXACTLY
              float gray = (r * 0.299f) + (g * 0.587f) + (b * 0.114f);
              float norm = gray / 255.0f;
              myInputBuffer[y * 64 + x] = norm;
            #else
              // Store RGB separately
              int baseIdx = (y * 64 + x) * 3;
              myInputBuffer[baseIdx]     = r / 255.0f;
              myInputBuffer[baseIdx + 1] = g / 255.0f;
              myInputBuffer[baseIdx + 2] = b / 255.0f;
            #endif
        }
    }
    free(rgb);
}

void setup() {
    Serial.begin(115200);

    camera_config_t config;
    config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = Y2_GPIO_NUM; config.pin_d1 = Y3_GPIO_NUM;
    config.pin_d2 = Y4_GPIO_NUM; config.pin_d3 = Y5_GPIO_NUM;
    config.pin_d4 = Y6_GPIO_NUM; config.pin_d5 = Y7_GPIO_NUM;
    config.pin_d6 = Y8_GPIO_NUM; config.pin_d7 = Y9_GPIO_NUM;
    config.pin_xclk = XCLK_GPIO_NUM;
    config.pin_pclk = PCLK_GPIO_NUM;
    config.pin_vsync = VSYNC_GPIO_NUM;
    config.pin_href = HREF_GPIO_NUM;
    config.pin_sscb_sda = SIOD_GPIO_NUM;
    config.pin_sscb_scl = SIOC_GPIO_NUM;
    config.pin_pwdn = -1;
    config.pin_reset = -1;

    config.xclk_freq_hz = 10000000;
    config.frame_size = FRAMESIZE_QVGA;   
    config.pixel_format = PIXFORMAT_JPEG;
    config.grab_mode = CAMERA_GRAB_LATEST;
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.fb_count = 1;
    config.jpeg_quality = 12;

    esp_camera_init(&config);

    // Display mode info
    Serial.print("System Online: CNN (");
    #ifdef USE_GRAYSCALE_MODE
      Serial.print("Grayscale");
    #else
      Serial.print("RGB");
    #endif
    Serial.print(" / ");
    #ifdef USE_INT8_MODE
      Serial.print("Int8");
    #else
      Serial.print("Float");
    #endif
    Serial.println(" mode)");
    
    Serial.println("Classes:");
    Serial.print("[0] "); Serial.println(myClassLabels[0]);
    Serial.print("[1] "); Serial.println(myClassLabels[1]);
    Serial.print("[2] "); Serial.println(myClassLabels[2]);
}

void loop() {
    camera_fb_t *fb = esp_camera_fb_get();
    if (!fb) return;

    myProcessCamera(fb);
    esp_camera_fb_return(fb);

    // A0 DEBUG MODE - Press A0 button for detailed analysis
    if (analogRead(A0) > 2000) {
        Serial.println("\n========== DETAILED DEBUG ==========");
        
        // Print mode info
        Serial.print("MODE: ");
        #ifdef USE_GRAYSCALE_MODE
          Serial.print("Grayscale");
        #else
          Serial.print("RGB");
        #endif
        Serial.print(" / ");
        #ifdef USE_INT8_MODE
          Serial.println("Int8");
        #else
          Serial.println("Float");
        #endif
        
        // 1. INPUT BUFFER STATISTICS
        float minVal = 1.0, maxVal = 0.0, avgVal = 0.0;
        #ifdef USE_GRAYSCALE_MODE
            int totalPixels = 64 * 64;
        #else
            int totalPixels = 64 * 64 * 3;
        #endif
        
        for (int i = 0; i < totalPixels; i++) {
            float val = myInputBuffer[i];
            if (val < minVal) minVal = val;
            if (val > maxVal) maxVal = val;
            avgVal += val;
        }
        avgVal /= totalPixels;
        
        Serial.println("\n--- INPUT BUFFER ---");
        Serial.print("Min: "); Serial.print(minVal, 4);
        Serial.print(" | Max: "); Serial.print(maxVal, 4);
        Serial.print(" | Avg: "); Serial.println(avgVal, 4);
        
        // 2. CONV1 OUTPUT STATISTICS
        minVal = 1e6; maxVal = -1e6; avgVal = 0;
        int zeroCount = 0;
        int totalConv1 = 62 * 62 * 4;
        for (int i = 0; i < totalConv1; i++) {
            float val = myConv1Output[i];
            if (val < minVal) minVal = val;
            if (val > maxVal) maxVal = val;
            avgVal += val;
            if (val == 0.0f) zeroCount++;
        }
        avgVal /= totalConv1;
        
        Serial.println("\n--- CONV1 OUTPUT ---");
        Serial.print("Min: "); Serial.print(minVal, 2);
        Serial.print(" | Max: "); Serial.print(maxVal, 2);
        Serial.print(" | Avg: "); Serial.print(avgVal, 2);
        Serial.print(" | Zeros: "); Serial.print(zeroCount);
        Serial.print("/"); Serial.print(totalConv1);
        Serial.print(" ("); Serial.print((zeroCount * 100) / totalConv1);
        Serial.println("%)");
        
        // 3. CONV2 OUTPUT STATISTICS
        minVal = 1e6; maxVal = -1e6; avgVal = 0;
        zeroCount = 0;
        int totalConv2 = 29 * 29 * 8;
        for (int i = 0; i < totalConv2; i++) {
            float val = myConv2Output[i];
            if (val < minVal) minVal = val;
            if (val > maxVal) maxVal = val;
            avgVal += val;
            if (val == 0.0f) zeroCount++;
        }
        avgVal /= totalConv2;
        
        Serial.println("\n--- CONV2 OUTPUT ---");
        Serial.print("Min: "); Serial.print(minVal, 2);
        Serial.print(" | Max: "); Serial.print(maxVal, 2);
        Serial.print(" | Avg: "); Serial.print(avgVal, 2);
        Serial.print(" | Zeros: "); Serial.print(zeroCount);
        Serial.print("/"); Serial.print(totalConv2);
        Serial.print(" ("); Serial.print((zeroCount * 100) / totalConv2);
        Serial.println("%)");
        
        // 4. WEIGHT SANITY CHECK
        Serial.println("\n--- WEIGHT SAMPLES ---");
        Serial.print("Conv1_w[0-9]: ");
        for (int i = 0; i < 10; i++) {
            Serial.print(GET_W(myConv1_w, i, myConv1_w_scale), 3);
            Serial.print(" ");
        }
        Serial.println();
        
        Serial.print("Conv1_b[0-3]: ");
        for (int i = 0; i < 4; i++) {
            Serial.print(GET_W(myConv1_b, i, myConv1_b_scale), 3);
            Serial.print(" ");
        }
        Serial.println();
        
        Serial.print("Conv2_w[0-9]: ");  // Added Conv2 weight check
        for (int i = 0; i < 10; i++) {
            Serial.print(GET_W(myConv2_w, i, myConv2_w_scale), 3);
            Serial.print(" ");
        }
        Serial.println();
        
        Serial.print("Output_w[0-19]: ");
        for (int i = 0; i < 20; i++) {
            Serial.print(GET_W(myOutput_w, i, myOutput_w_scale), 4);
            Serial.print(" ");
        }
        Serial.println();
        
        Serial.print("Output_b[0-2]: ");
        for (int i = 0; i < 3; i++) {
            Serial.print(GET_W(myOutput_b, i, myOutput_b_scale), 3);
            Serial.print(" ");
        }
        Serial.println();
        
        // 5. ASCII PREVIEW OF INPUT (32x16)
        Serial.println("\n--- INPUT PREVIEW (32x16 downsampled) ---");
        for (int y = 0; y < 64; y += 4) {
            for (int x = 0; x < 64; x += 2) {
                #ifdef USE_GRAYSCALE_MODE
                    float val = myInputBuffer[y * 64 + x];
                #else
                    int idx = (y * 64 + x) * 3;
                    float val = (myInputBuffer[idx] + myInputBuffer[idx+1] + myInputBuffer[idx+2]) / 3.0f;
                #endif
                
                if (val > 0.75) Serial.print("#");
                else if (val > 0.5) Serial.print("+");
                else if (val > 0.25) Serial.print(".");
                else Serial.print(" ");
            }
            Serial.println();
        }
        
        Serial.println("\n========== END DEBUG ==========\n");
        delay(2000);
    }

    myConv1();
    myMaxPool1();
    myConv2();

    int result = myGetWinner();
    Serial.print("Class: ");
    Serial.print(result);
    Serial.print(" (");
    Serial.print(myClassLabels[result]);
    Serial.println(")");

    delay(100);
}
